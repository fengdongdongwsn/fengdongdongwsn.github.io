<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>我在一个构造方法里面写了30个参数，老板看了想骂人</title>
    <link href="/2020/12/26/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%88%91%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E5%86%99%E4%BA%8630%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%81%E6%9D%BF%E7%9C%8B%E4%BA%86%E6%83%B3%E9%AA%82%E4%BA%BA/"/>
    <url>/2020/12/26/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%88%91%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E5%86%99%E4%BA%8630%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%81%E6%9D%BF%E7%9C%8B%E4%BA%86%E6%83%B3%E9%AA%82%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文基于《Effective java》第二条</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般我们写参数如果写个一两个，那就可以了，如果写七八个，那就有点难受了。如果写十几个？尼玛，难受，我要去缓缓。</p><p><img src="https://s3.ax1x.com/2020/12/26/rhBVgK.png"></p><p>于是乎，一种新的方法策略运用而生。那就是builder模式，在构造方法的参数过多时，可以方便的进行创建一个类对象。所以本文的中心主旨一句话总结：<strong>当构造方法的参数过多时，推荐使用builder模式</strong></p><p>既然推荐使用builder模式，那我们一个一个来，分析一下如果不使用builder模式有什么缺点。</p><h2 id="一、传统方式的缺点"><a href="#一、传统方式的缺点" class="headerlink" title="一、传统方式的缺点"></a>一、传统方式的缺点</h2><h3 id="1、可伸缩构造方法"><a href="#1、可伸缩构造方法" class="headerlink" title="1、可伸缩构造方法"></a>1、可伸缩构造方法</h3><p>可伸缩构造方法就是我们平时书写最常见的那种，请看下文代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">//可选</span><br><span class="hljs-comment">//构造函数1：默认构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br><span class="hljs-comment">//构造方法2：必要字段构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-comment">//构造方法3：全部字段构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> sclass, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">float</span> weight, <span class="hljs-keyword">float</span> score)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">this</span>.sclass = sclass;<br><span class="hljs-keyword">this</span>.height = height;<br><span class="hljs-keyword">this</span>.weight = weight;<br><span class="hljs-keyword">this</span>.score = score;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面如果我们要创建一个Student类，一般这样创建，看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//1、可伸缩构造方法</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;愚公要移山&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1</span>,<span class="hljs-number">175</span>,<span class="hljs-number">120</span>,<span class="hljs-number">99</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们列举了一个具有七个字段的例子，比较容易理解，现在我们来分析一下，他有什么缺点：</p><h4 id="缺点1：反转字段，编译器不会报错"><a href="#缺点1：反转字段，编译器不会报错" class="headerlink" title="缺点1：反转字段，编译器不会报错"></a>缺点1：反转字段，编译器不会报错</h4><p>比如上面的字段里面有一个weight和一个score，都是float类型，如果再new一个Student类时，不小心写反了，编译器不会察觉。</p><h4 id="缺点2：难以理解"><a href="#缺点2：难以理解" class="headerlink" title="缺点2：难以理解"></a>缺点2：难以理解</h4><p>这里只是七个字段，如果有十几个，我们就需要不断地去Student类中去查看，看看第几个参数应该写哪些东西，实在是比较麻烦。用户在看到这个Student(2,”愚公要移山”,18,1,175,120,99)无法理解每一个字段属性代表的是什么含义。</p><h4 id="缺点3：不想设置的参数，却不得不设置值"><a href="#缺点3：不想设置的参数，却不得不设置值" class="headerlink" title="缺点3：不想设置的参数，却不得不设置值"></a>缺点3：不想设置的参数，却不得不设置值</h4><p>有时候我们的Student只想着设置ID、name和age字段，其他的无关紧要，但是这种模式必须要设置所有的属性值。</p><p>既然上面有这些缺点，我们可能还想到另外一种方式，那就是javaBean。</p><h3 id="2、javaBean模式"><a href="#2、javaBean模式" class="headerlink" title="2、javaBean模式"></a>2、javaBean模式</h3><p>先看javaBean模式如何写的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">//可选</span><br><span class="hljs-comment">//构造函数1：默认构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">//getter和setter方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> id;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> age;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSclass</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> sclass;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSclass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sclass)</span> </span>&#123;<span class="hljs-keyword">this</span>.sclass = sclass;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> height;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height)</span> </span>&#123;<span class="hljs-keyword">this</span>.height = height;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> weight;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">float</span> weight)</span> </span>&#123;<span class="hljs-keyword">this</span>.weight = weight;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> score;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">float</span> score)</span> </span>&#123;<span class="hljs-keyword">this</span>.score = score;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式，看起来还比较舒服，只是设置了相应的getter和setter方法。再来看看如何使用这种方式去new一个Student类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//2、javaBean模式</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>student1.setId(<span class="hljs-number">1</span>);<br>student1.setName(<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>student1.setSclass(<span class="hljs-number">1</span>);<br>student1.setWeight(<span class="hljs-number">180</span>);<br>student1.setHeight(<span class="hljs-number">175</span>);<br>student1.setScore(<span class="hljs-number">100</span>);<br>student1.setAge(<span class="hljs-number">20</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看起来还可以，不过这只是我自己一个一个敲出来的。实际在用的时候就知道同样恶心了，现在来总结一波他的缺点。</p><h4 id="缺点1：构造过程中-JavaBean可能处于不一致的状态"><a href="#缺点1：构造过程中-JavaBean可能处于不一致的状态" class="headerlink" title="缺点1：构造过程中 JavaBean可能处于不一致的状态"></a>缺点1：构造过程中 JavaBean可能处于不一致的状态</h4><p>JavaBeans 模式本身有严重的缺陷。由于构造方法在多次调用中被分割，所以在构造过程中 JavaBean<br>可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来执行一致性的选项。在不一致的状态下尝试使用对象可能会导致与包含 bug 的代码大相径庭的错误，因此很难调试。</p><p>说一下我对其的理解，在上面的例子中，我们的student1对象被多次调用了set方法，但是可能有时候在用到这个bean时，剩下的setter方法还没有做完，于是再次调用时发现同一个javaBean呈现出了两种状态。于是处于一种不一致的状态。</p><h4 id="缺点2：无法保证javaBean的不可变性"><a href="#缺点2：无法保证javaBean的不可变性" class="headerlink" title="缺点2：无法保证javaBean的不可变性"></a>缺点2：无法保证javaBean的不可变性</h4><p>使用第一种模式可伸缩构造方法实例化之后不会更改可变性，所有的数据都是确定好了的。也可以保证线程安全。但是提供了setter方法，就不能保证了。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//2、javaBean模式</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>student1.setId(<span class="hljs-number">1</span>);<br>student1.setName(<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>student1.setSclass(<span class="hljs-number">1</span>);<br>student1.setWeight(<span class="hljs-number">180</span>);<br>student1.setHeight(<span class="hljs-number">175</span>);<br>student1.setScore(<span class="hljs-number">100</span>);<br>student1.setAge(<span class="hljs-number">20</span>);<br>System.out.println(student1.getName());<br>student1.setName(<span class="hljs-string">&quot;冯冬冬&quot;</span>);<br>System.out.println(student1.getName());<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出结果：愚公要移山  冯冬冬</span><br></code></pre></td></tr></table></figure><p>可以看到，我们可以对Student对象设置多次name，前后是不一致的状态。</p><p>既然前面两种都存在各种各样的问题。现在我们再来看今天的主题builder模式，</p><h2 id="二、builder模式"><a href="#二、builder模式" class="headerlink" title="二、builder模式"></a>二、builder模式</h2><p>还是老样子，我们先看看builder模式长得什么样子。再来分析一下他的优缺点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">// 可选</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = builder.id;<br><span class="hljs-keyword">this</span>.name = builder.name;<br><span class="hljs-keyword">this</span>.age = builder.age;<br><span class="hljs-keyword">this</span>.sclass = builder.sclass;<br><span class="hljs-keyword">this</span>.height = builder.height;<br><span class="hljs-keyword">this</span>.weight = builder.weight;<br><span class="hljs-keyword">this</span>.score = builder.score;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">// 可选</span><br><span class="hljs-comment">// 必要参数的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setSclass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sclass)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.sclass = sclass;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.height = height;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">float</span> weight)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.weight = weight;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">float</span> score)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.score = score;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 对外提供的</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码是在内部构造了一个Builder类，然后我们看看如何去使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//3、Builder模式</span><br>Student stu = <span class="hljs-keyword">new</span> Student.Builder(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;愚公要移山&quot;</span>)<br>.setAge(<span class="hljs-number">20</span>)<br>.setHeight(<span class="hljs-number">175</span>)<br>.setSclass(<span class="hljs-number">1</span>)<br>.setScore(<span class="hljs-number">100</span>)<br>.setWeight(<span class="hljs-number">100</span>).build();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这本书中对其的缺点也进行了介绍，很直观可以看到，Student类中的代码量增加了很多。但是Student类，我们只需要写一次，这却为我们创建对象带来了方便。</p><h3 id="优点1：不存在反转字段的情况"><a href="#优点1：不存在反转字段的情况" class="headerlink" title="优点1：不存在反转字段的情况"></a>优点1：不存在反转字段的情况</h3><p>上面可以看出，每次添加新字段值的时候是通过set方式进行的。具有javaBean的优点。</p><h3 id="优点2：灵活构造参数"><a href="#优点2：灵活构造参数" class="headerlink" title="优点2：灵活构造参数"></a>优点2：灵活构造参数</h3><p>我们把必要的字段一写，那些非必要的字段我们可以自己选择是不是要set。</p><h3 id="优点3：不存在不一致状态"><a href="#优点3：不存在不一致状态" class="headerlink" title="优点3：不存在不一致状态"></a>优点3：不存在不一致状态</h3><p>使用builder模式，对象的创建必须要等到build完成才可以。</p><h3 id="优点4：使用灵活"><a href="#优点4：使用灵活" class="headerlink" title="优点4：使用灵活"></a>优点4：使用灵活</h3><p>单个 builder 可以重复使用来构建多个对象。 builder 的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在性能关键的情况下可能会出现问题。而且，builder 模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。</p><p>但是，如果从构造方法或静态工厂开始，并切换到 builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂就会面临尴尬的处境。因此，所以，最好从一开始就创建一个 builder。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们的参数比较多时，builder模式是一个不错的选择，如果比较少时，由于Builder本身也是个对象占用一定的资源，所以还是使用可伸缩或者是javaBean的那种模式比较好。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>写代码的建议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么MongoDB使用B树，而Mysql使用B+树？（干活总结）</title>
    <link href="/2020/12/26/%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/3%E3%80%81MongoDB/%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%EF%BC%8C%E8%80%8CMysql%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F%EF%BC%88%E5%B9%B2%E6%B4%BB%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2020/12/26/%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/3%E3%80%81MongoDB/%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%EF%BC%8C%E8%80%8CMysql%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F%EF%BC%88%E5%B9%B2%E6%B4%BB%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《MongoDB学习系列》专栏中</strong></p></blockquote><p>本文献给准备面试或者是还在面试的你。常见面试题，送分题目，不拿白不拿。</p><h2 id="一、B树和B-树的区别"><a href="#一、B树和B-树的区别" class="headerlink" title="一、B树和B+树的区别"></a><strong>一、B树和B+树的区别</strong></h2><p>很明显，我们想向弄清楚原因就要知道B树和B+树的区别。为了不长篇大论。我们直接给出他们的形式总结他们的特点。</p><h3 id="1、B树"><a href="#1、B树" class="headerlink" title="1、B树"></a><strong>1、B树</strong></h3><p>B树是一种自平衡的搜索树，形式很简单：</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRAYQ.png"></p><p>这就是一颗B-树。针对我们这个问题的最核心的特点如下：</p><p><strong>（1）多路，非二叉树</strong></p><p><strong>（2）每个节点既保存索引，又保存数据</strong></p><p><strong>（3）搜索时相当于二分查找</strong></p><p>其他的基本上都是一些常见的数据结构，假定都已经了解了B树相关的结构。</p><h3 id="2、B-树"><a href="#2、B-树" class="headerlink" title="2、B+树"></a><strong>2、B+树</strong></h3><p>B+树是B树的变种</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRkFg.png"></p><p>最核心的特点如下：</p><p><strong>（1）多路非二叉</strong></p><p><strong>（2）只有叶子节点保存数据</strong></p><p><strong>（3）搜索时相当于二分查找</strong></p><p><strong>（4）增加了相邻接点的指向指针。</strong></p><p>从上面我们可以看出最核心的区别主要有俩，</p><p><strong>一个是数据的保存位置：B树保存在所有的节点中，B+树保存在叶子节点</strong></p><p><strong>一个是相邻节点的指向：B树叶子节点之间没有指针，B+树有</strong></p><p>这里区别分别给B树和B+树带来了什么好处呢？其实对于数据库来说，选用什么数据结构无非就是为了增删改查和存储更加高效，因为找特点时也要从这个点去回答。</p><h3 id="3、从区别找特点"><a href="#3、从区别找特点" class="headerlink" title="3、从区别找特点"></a><strong>3、从区别找特点</strong></h3><h4 id="第一：查找元素"><a href="#第一：查找元素" class="headerlink" title="第一：查找元素"></a>第一：查找元素</h4><p>（1）B树的数据保存在所有节点，查询复杂度最好是 O(1)。</p><p>（2）B+树的数据保存在叶子节点，查询时间复杂度固定是O(log(n))</p><h4 id="第二：区间查找"><a href="#第二：区间查找" class="headerlink" title="第二：区间查找"></a>第二：区间查找</h4><p>（1）B树每个节点 key 和 data 在一起，则无法区间查找。</p><p>（2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等</p><h4 id="第三：存储"><a href="#第三：存储" class="headerlink" title="第三：存储"></a>第三：存储</h4><p>（1）B树每个节点即保存数据又保存索引，所以每一节点特别大，这一层所有节点加起来数据量将非常大。磁盘每次IO一定量的数据，对于Mysql来说如何衡量查询效率呢？就是磁盘IO次数。既然B树每一层特别大，那每一层就需要对数据分开从而进行多次IO操作。所有Mysql不用。</p><p>（2）B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确，所以不需要用B+树。</p><p>有了他们的区别之后，现在我们再来解释这个原因就好多了。</p><h2 id="二、原因解释"><a href="#二、原因解释" class="headerlink" title="二、原因解释"></a><strong>二、原因解释</strong></h2><p>上面解释了不使用的原因，我们再来看为什么Mysql使用B+树，而MongoDB使用B树，想要解释原因，我们还必须要了解一下MongoDB和Mysql的基本概念。</p><h3 id="1、MongoDB"><a href="#1、MongoDB" class="headerlink" title="1、MongoDB"></a><strong>1、MongoDB</strong></h3><p>MongoDB 是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据。比如之前我们的表可能有用户表、订单表、购物篮表等等，还要建立他们之间的外键关联关系。但是类Json就不一样了。</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRiTS.png"></p><p>我们可以看到这种形式更简单，通俗易懂。那为什么 MongoDB 使用B-树呢？</p><p><strong>MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql</strong>。</p><h3 id="2、Mysql"><a href="#2、Mysql" class="headerlink" title="2、Mysql"></a><strong>2、Mysql</strong></h3><p><strong>Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。</strong></p><p>还有一点，B+树只有叶子节点保存数据，所以每一节点比较小，每一层所有节点加起来数据量也相对比较小。磁盘每次IO一定量的数据，对于Mysql来说。既然B+树每一层小，那每一层只需要少量IO操作。</p><p>这俩区别的核心如果你能看懂B-树和B+树的区别就很容易理解。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>MongoDB系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>Mysql</tag>
      
      <tag>常见面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【1】我们到底该如何学习《数据结构与算法》</title>
    <link href="/2020/12/24/%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/24/%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《手牵手一起学数据结构》专栏中</strong></p></blockquote><h2 id="前言：我们到底该不该学习算法与数据结构？"><a href="#前言：我们到底该不该学习算法与数据结构？" class="headerlink" title="前言：我们到底该不该学习算法与数据结构？"></a>前言：我们到底该不该学习算法与数据结构？</h2><h3 id="1、真的应该学习"><a href="#1、真的应该学习" class="headerlink" title="1、真的应该学习"></a>1、真的应该学习</h3><p>这个问题本身就不是个问题，所有人都在强调数据结构与算法比较重要，但是好像平时也没用到，无法直观的去感受它的重要性，于是把学习重心放在了常见的哪些框架身上，似乎只要熟悉了哪些框架的API，编程就会所向披靡。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZhJU.gif"></p><p>我举一个我自身的例子，我本科期间想做一个APP，主要是在线预约的功能，既然是在线预约，用户多了之后那就需要排队，当时也不管三七二十一，不管哪种结构，那就先试试ArrayList，当然这种数据结构也能解决，但是当真正操作其增删改查的时候才发现ArrayList确实是比较麻烦一点。</p><p>在网上开始问各种大佬，统一回复的一句话是，你现在学数据结构了吗？你数据结构咋学的？现在想想真的是留下啦悔恨的眼泪。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZfiT.gif"></p><p>既然数据结构与算法重要，到底哪个地方重要呢？下面就来说说：</p><h3 id="2、重要性体现"><a href="#2、重要性体现" class="headerlink" title="2、重要性体现"></a>2、重要性体现</h3><h4 id="第一：面试"><a href="#第一：面试" class="headerlink" title="第一：面试"></a>第一：面试</h4><p>面试确实是第一个体现的点，因为你会发现，面试外企的时候他们第一件事就是啥都不问，上来就是几道算法题。包括国内的字节跳动。现在的阿里、腾讯、华为、美团。凡是大家知道的那些大厂基本上上来就是先敲代码。可以看出国内外大厂对于算法与数据结构的看重。</p><h4 id="第二：工作"><a href="#第二：工作" class="headerlink" title="第二：工作"></a>第二：工作</h4><p>现在的大厂api框架基本上背后的逻辑就是基于算法实现的。其实算法的种类有很多，比如说机器学习、神经网络算法，还有java中的排序算法，互联网的商品推荐、股票预测其背后的逻辑都是算法。就算是熟悉的那些框架，背后的逻辑也是数据结构与算法。我们敲代码解决问题的过程当中也是算法的集中体现。</p><h4 id="第三：学习"><a href="#第三：学习" class="headerlink" title="第三：学习"></a>第三：学习</h4><p>学习数据结构与算法的目的，别人我不知道，对我目前来说，是想了解哪些常见框架，常见机制背后的运行逻辑。进而为以后创造一个更加强大的产品做铺垫。任何一个新东西，都是先了解，再模仿，最后再创造的过程。</p><h4 id="第四：应付学业"><a href="#第四：应付学业" class="headerlink" title="第四：应付学业"></a>第四：应付学业</h4><p>我之前大学学习这门课的时候，学分比重还是比较大的，好几年过去了，不知道现在变没变。不过最起码考研或者是期末考试，这门课都是必须要学习的一门课。可见学校也比较重视。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2Z5z4.gif"></p><h2 id="一、算法与数据结构到底是个什么东东？"><a href="#一、算法与数据结构到底是个什么东东？" class="headerlink" title="一、算法与数据结构到底是个什么东东？"></a>一、算法与数据结构到底是个什么东东？</h2><p>在这里我不想去解释哪些常见的名词了，像什么是数据项、数据对象、元素等等这些概念。稍微有点基础的人，对这些概念都应该很清楚，毕竟都是中国人。我主要想说一下，我们到底该如何理解数据结构与算法。</p><h3 id="1、什么是数据结构？"><a href="#1、什么是数据结构？" class="headerlink" title="1、什么是数据结构？"></a>1、什么是数据结构？</h3><p>高中的时候都学习过化学，什么水的结构，碳原子的结构，这些分子、原子之间不是杂乱无章的，我们总是可以归纳分析出一些规律。对于计算机中的数据元素而言，这些数据元素也不是孤立的，总是有一种或者是几种的内在联系。</p><blockquote><p>数据结构：数据元素相互之间一种或者多种关系的表示</p></blockquote><p>既然数据元素之间有某种关系，那这种关系到底是什么呢？这里直接总结了一下。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2Z2d0.png"></p><p>可以看出分两类，表示了这些数据元素之间的关系。我们在学习数据结构的时候，其实就是学习这些数据元素到底有哪些关系。</p><h3 id="2、什么是算法"><a href="#2、什么是算法" class="headerlink" title="2、什么是算法"></a>2、什么是算法</h3><p>宋丹丹和赵本山有过一个小品，说如何把大象关进冰箱里。第一步先把冰箱门打开，第二步把大象装进去，第三步，把冰箱门关上。整个简单的流程完美的体现了算法的思想。标准定义：</p><blockquote><p>算法：解决问题的步骤的描述</p></blockquote><p>就这么几个字，其实就是描述过程的。当然解决问题的方法有很多，因此算法也有很多种，就比说我们常见的排序算法，就简简单单为了从小到大排序，哪些科学家们活活的搞出了十几种。每一种排序方式都是一个算法。</p><h3 id="3、数据结构与算法的关系（重点）"><a href="#3、数据结构与算法的关系（重点）" class="headerlink" title="3、数据结构与算法的关系（重点）"></a>3、数据结构与算法的关系（重点）</h3><p>我们经常会听到有人说：程序=算法+数据结构，某位大佬科学家就提出了这几个字还得了图灵奖。大学的时候知道这件事还让我一度怀疑图灵奖也不过如此。嘿嘿，不过现在不敢说了，看的越多，越觉得这个简单地公式蕴含了无数的道理。</p><p>既然是讨论他们之间的关系。我们再来看个例子，毕竟例子各位才理解的更加清楚。假如我国要在多个城市之间新建一条高铁。要求是能够链接多个城市，而且成本最低。OK，好了，现在就这么个需求，我们来分析。</p><p>第一目的：修建铁路</p><p>第二要求：连通所有城市，成本最低。</p><p>我们一下子就能想到这是一个最小生成树问题，假如把每一个城市看成一个点，把城市之间的成本看成连线数字，就是找出来一个联通线。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2eAFf.png"></p><p>目的其实就是为了找上图中的那条黑线。这里不是专门讲这个知识体系的。现在我们使用流程图看看，如果遇到了一个问题，我们是如何去使用程序去解决的。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZRoV.png"></p><p>从上图可以看出，为了要解决一个问题，首先我们要分析问题，然后确定解决思路，接下来设计或者是选择已有的算法，再然后就是确定实现的数据结构，最后就是代码的实现与优化。</p><p>数据结构在其中的位置可以看出，是为了更好地实现某种或者是某类算法。在讨论这门课的时候也会结合在一起去学习。</p><h2 id="二、学习数据结构与算法我们最应该关注什么？"><a href="#二、学习数据结构与算法我们最应该关注什么？" class="headerlink" title="二、学习数据结构与算法我们最应该关注什么？"></a>二、学习数据结构与算法我们最应该关注什么？</h2><p>​    如果我们想要学好数据结构与算法，首先脑海中要时刻记住两个关键词汇，<strong>时间效率和空间效率</strong>。这个两个词汇贯穿了整个数据结构与算法的知识体系。</p><p>​    数据结构可以助算法实现问题提供基础，算法为了解决某一问题必须要时间够快，空间足够节省。就好比我们为了能够在茫茫人海当中找寻另一半一样。首先时间要足够快，不能一个一个找，然后我们不可能把茫茫人海所有人的全部信息全给保存了，所以空间上还要足够节省。</p><p>​    <strong>那什么是时间效率和空间效率呢？通俗的理解就是：我们使用两个不同的程序去解决同一个问题，时间短的说明时间效率高，消耗空间小的说明空间效率高。</strong></p><p>​    我们在研究数据结构与算法的时候，其实就是选择不同的数据结构和不同的算法解决某一问题的同时尽可能的提升计算机的时间效率和空间效率。</p><h3 id="1、首先看时间复杂度："><a href="#1、首先看时间复杂度：" class="headerlink" title="1、首先看时间复杂度："></a>1、首先看时间复杂度：</h3><p>​    想要了解时间复杂度，就需要先了解时间频度。一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或<strong>时间频度</strong>。记为T(n)。</p><p>说白了时间复杂度就是描述时间的规模，比如说时间频度是T(n),时间复杂度就是O(n)。时间频度是T(n+n)的时候,时间复杂度还是O(n)。也就是他的时间规模就是n这个层次了。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度**。</p><p><strong>常见的算法的时间 复杂度之间的关系为：</strong></p><p><strong>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</strong> </p><p>举个例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">a=<span class="hljs-number">0</span>；                    <span class="hljs-comment">//（1）</span><br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)       <span class="hljs-comment">//（2）</span><br>      <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)       <span class="hljs-comment">//（3）</span><br>       a++；             <span class="hljs-comment">//（4）</span><br></code></pre></td></tr></table></figure><p>语句（1）执行1次，</p><p>语句（2）执行n次</p><p>语句（3）执行n2次</p><p>语句（4）执行n2次</p><p>T(n) = 1+n+2n2= O(n2)</p><h3 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h3><p>空间复杂度就比较容易理解了，空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个空间规模，我们用 S(n) 来定义。</p><p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，</p><h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><p>在本文中，首先讨论了数据结构与算法的重要性，然后给出了数据结构与算法的理解，最后就是在学习数据结构与算法时，我们最应该关注的点。其中通过数据结构与算进的关系解决某一问题的流程是重点。在以后的文章中，也会惯用这一思路。这个思路是我在刷了力扣几百道题时总结出来的。</p><p>举个例子来说一下：</p><p>面试中经常会遇到一道题，那就是实现LRU（最近最久未使用）。我们按照上面的流程结构可以很清楚的把问题给解决掉，而不是死记硬背哪些现有的代码，比如第一步分析问题，问题是实现最近最久未使用的算法，我们可以画图来看一下到底是个什么问题，然后就是确定算法，比如说第一步我们该干嘛，第二步该干嘛等等。接下来确定数据结构的时候，比如说可以自定义Node实现，还有java中为我们提供的LinkedHashMap等等。最后就是根据数据结构的特点通过我们分析的算法流程去实现。</p><p>这样是不是有点清晰了。本专栏将持续推出。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>手牵手一起学数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
