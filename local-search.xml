<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mysql遇到了重复数据，该怎么处理？</title>
    <link href="/2021/01/26/%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81Mysql/Mysql%E9%81%87%E5%88%B0%E4%BA%86%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F/"/>
    <url>/2021/01/26/%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/1%E3%80%81Mysql/Mysql%E9%81%87%E5%88%B0%E4%BA%86%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实解决能否插入重复数据的问题，一般情况下是有两个思路，就像治水一样，第一个就是从源头，第二个就是在水流经的路上。我们带着这两种思路继续往下看：</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在我们的mysql数据库中，经常会出现一些重复的数据，有些情况我们允许重复数据的存在，但有时候我们也需要删除这些重复的数据。我们如何去处理呢？</p><h3 id="方法一：防止出现重复数据"><a href="#方法一：防止出现重复数据" class="headerlink" title="方法一：防止出现重复数据"></a>方法一：防止出现重复数据</h3><p>也就是说我们再设计表的时候，就应该对这些数据设置一个UNIQUE 索引，在插入的时候就可以保证其唯一性，也就不存在有重复的数据了。当然你也可以直接设置为PRIMARY KEY（主键）。效果也是一样的。<br>我们看一个案例：下表中无索引及主键，所以该表允许出现多条重复记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student<br>(<br>    first_name <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>),<br>    last_name <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>),<br>    sex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">10</span>)<br>);<br></code></pre></td></tr></table></figure><p>目前first_name，last_name是可以重复的，如果不想重复这里有两个解决办法：</p><h4 id="1、设置双主键模式"><a href="#1、设置双主键模式" class="headerlink" title="1、设置双主键模式"></a>1、设置双主键模式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student<br>(<br>   first_name <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>   last_name <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>   sex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">10</span>),<br>   PRIMARY <span class="hljs-keyword">KEY</span> (last_name, first_name)<br>);<br></code></pre></td></tr></table></figure><p>现在就无法插入重复数据了。</p><h4 id="2、添加unique索引"><a href="#2、添加unique索引" class="headerlink" title="2、添加unique索引"></a>2、添加unique索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student<br>(<br>   first_name <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>   last_name <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<br>   sex <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">10</span>)<br>   <span class="hljs-keyword">UNIQUE</span> (last_name, first_name)<br>);<br></code></pre></td></tr></table></figure><p>这两种看起来形式好像有一点区别，但是能起到相同的作用。此时我们可以插入两条重复的数据，会发现报错。<br>当然我们还可以在数据库中去验证一下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">as</span> repetitions, last_name, first_name<br>       <span class="hljs-keyword">FROM</span> student<br>       <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> last_name, first_name<br>       <span class="hljs-keyword">HAVING</span> repetitions &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>在这里我们统计的是 first_name 和 last_name的重复记录数，上面已经用两种方法设置了，这里肯定就是0了。</p><h3 id="方法二：在插入时指定能否插入重复数据"><a href="#方法二：在插入时指定能否插入重复数据" class="headerlink" title="方法二：在插入时指定能否插入重复数据"></a>方法二：在插入时指定能否插入重复数据</h3><p>在这里我们使用的是Insert ignore into 与Insert into指令。</p><p>（1）Insert ignore into会忽略数据库中已经存在的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。</p><p>（2）Insert into则直接相反，会直接插入数据，不管数据库里面是否含有重复数据。</p><p>我们还是举例说明：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">ignore</span> <span class="hljs-keyword">into</span> student (last_name, first_name) <span class="hljs-keyword">values</span> ( <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>);<br>//结果<br>Query OK, 1 rows affected (0.00 sec)<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">ignore</span> <span class="hljs-keyword">into</span> student (last_name, first_name) <span class="hljs-keyword">values</span> ( <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;李四&#x27;</span>);<br>//结果<br>Query OK, 0 rows affected (0.00 sec)<br></code></pre></td></tr></table></figure><p>现在我们看出来了吧，也就是说在执行第一条插入操作的时候，看到数据库没有，则直接插入一条新纪录，因此一行记录受到影响，但是在第二次插入的时候，数据库已经有一条一样的了，因此便不会插入了，0行受到影响。</p><p>当然了还有一个指令也可以完成类似于insert ignore into相似的功能，那就是replace  into。他表示的是如果存在primary 或 unique相同的记录，则先删除掉。再插入新记录。</p><h2 id="方法三：过滤重复数据"><a href="#方法三：过滤重复数据" class="headerlink" title="方法三：过滤重复数据"></a>方法三：过滤重复数据</h2><p>如果你需要读取不重复的数据可以在 SELECT 语句中使用 DISTINCT 关键字来过滤重复数据。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> last_name, first_name<br><span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> last_name;<br>你也可以使用 GROUP BY 来读取数据表中不重复的数据：<br><span class="hljs-keyword">SELECT</span> last_name, first_name<br><span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> (last_name, first_name);<br></code></pre></td></tr></table></figure><h2 id="方法四：删除重复数据"><a href="#方法四：删除重复数据" class="headerlink" title="方法四：删除重复数据"></a>方法四：删除重复数据</h2><p>这种情况其实就相当于，在水的终点处去解决。看下面sql语句：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//根据student创建一个临时表，并使用<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>过滤了重复数据<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tmp <span class="hljs-keyword">SELECT</span> last_name, first_name, sex<br>        <span class="hljs-keyword">FROM</span> student;<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> (last_name, first_name);<br>//删除原student表<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> student;<br>//给这个临时表重新命名<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tmp <span class="hljs-keyword">RENAME</span> <span class="hljs-keyword">TO</span> stu;<br></code></pre></td></tr></table></figure><p>当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">IGNORE</span> <span class="hljs-keyword">TABLE</span> student<br><span class="hljs-keyword">ADD</span> PRIMARY <span class="hljs-keyword">KEY</span> (last_name, first_name);<br></code></pre></td></tr></table></figure><p>OK，解决办法这么多，相信能解决你的问题。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Mysql系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>protobuf这么重要，为什么不用五分钟学习一下呢？</title>
    <link href="/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/7%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/protobuf%E8%BF%99%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%94%E5%88%86%E9%92%9F%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E5%91%A2%EF%BC%9F/"/>
    <url>/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/7%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/protobuf%E8%BF%99%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%94%E5%88%86%E9%92%9F%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%8B%E5%91%A2%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>java自带的序列化机制效率太低，有很多缺点。因此涌现出了很多优秀的系列化框架，比如说<code>protobuf、protostuff、thrift、hession、kryo、avro、fst、msgpack</code>等等。这篇文章我们就看一下<code>protobuf</code>，给出一个简单案例，看看其是如何实现的。</p><blockquote><p>注：若你对序列化概念和基本使用还有疑惑，可以翻看我之前的文章，或者百度一些基本概念和作用。</p></blockquote><h2 id="一、为什么要使用protobuf？"><a href="#一、为什么要使用protobuf？" class="headerlink" title="一、为什么要使用protobuf？"></a><strong>一、为什么要使用protobuf？</strong></h2><p>使用protobuf的原因肯定是为了解决开发中的一些问题，那使用其他的序列化机制会出现什么问题呢？</p><p>（1）java默认序列化机制：效率极低，而且还能不能跨语言之间共享数据。</p><p>（2）XML常用于与其他项目之间数据传输或者是共享数据，但是编码和解码会造成很大的性能损失。</p><p>（3）json格式也是常见的一种，但是在json在解析的时候非常耗时，而且json结构非常占内存。</p><p>但是我们protobuf是一种灵活的、高效的、自动化的序列化机制，可以有效的解决上面的问题。</p><h2 id="二、如何使用protobuf"><a href="#二、如何使用protobuf" class="headerlink" title="二、如何使用protobuf"></a><strong>二、如何使用protobuf</strong></h2><p>protobuf这么优秀使用起来也是非常的简单，我们可以给出其主要的三个步骤，然后使用一个基本的案例去实现一下。</p><p>（1）<code>定义.proto文件</code>：我们在这个文件中描述我们序列化的信息，类似于bean类。</p><p>（2）<code>根据.proto生成对应的类文件</code>，上面这个proto就像是一个模板，现在我们要根据这个模板创建出一个java类。</p><p>（3）<code>序列化</code>。</p><p>有了这个基本的步骤我们我们就具体去实现一下：</p><h3 id="1、下载安装protobuf"><a href="#1、下载安装protobuf" class="headerlink" title="1、下载安装protobuf"></a><strong>1、下载安装protobuf</strong></h3><h4 id="第一步：下载解压"><a href="#第一步：下载解压" class="headerlink" title="第一步：下载解压"></a><strong>第一步：下载解压</strong></h4><p>我的电脑是windows10，因此这里给出在windows下的使用，linux下面使用我也将在后续文章推出。我们首先下载protobuf（<code>github上搜索protobuf，有各种语言可供选择</code>）。选择<code>protoc-3.9.0-win64.zip</code>。下载完成之后解压到D：/protobuf目录下面就好了。</p><p><img src="G:\博客\八、分布式专题\2、序列化机制\protobuf\1-安装.png"></p><h4 id="第二步：配置环境变量"><a href="#第二步：配置环境变量" class="headerlink" title="第二步：配置环境变量"></a><strong>第二步：配置环境变量</strong></h4><p>也就是将<code>D:\protobuf\protoc-3.9.0-win64\bin配置到path环境变量里面。</code></p><h4 id="第三步：验证是否安装成功"><a href="#第三步：验证是否安装成功" class="headerlink" title="第三步：验证是否安装成功"></a><strong>第三步：验证是否安装成功</strong></h4><p>最后我们可以在<code>cmd中输入protoc --version验</code>证一下，是否成功。</p><p><img src="G:\博客\八、分布式专题\2、序列化机制\protobuf\2-安装验证.png"></p><p>OK，到这里我们就安装好了。</p><h3 id="2、编写proto文件"><a href="#2、编写proto文件" class="headerlink" title="2、编写proto文件"></a><strong>2、编写proto文件</strong></h3><p>之前我们说过proto 文件非常类似java的bean。在这里我们在bin目录下新建一个Person.proto文件（和proto.exe）。输入下列内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">syntax=<span class="hljs-string">&quot;proto3&quot;</span>; <br>option java_package = <span class="hljs-string">&quot;com.fdd.protobuf&quot;</span>;   <br>option java_outer_classname = <span class="hljs-string">&quot;PersonProto&quot;</span>;   <br>message Person  &#123; <br>  string name = <span class="hljs-number">1</span>;<br>  int32 age = <span class="hljs-number">2</span>;<br>&#125;  <br></code></pre></td></tr></table></figure><p>我们解释一些我们都写了什么</p><p>（1）第一行有一个<code>proto3</code>，他表示的是protobuf的语法版本，就类似于jdk1.7和jdk1.8的概念。<strong>需要在第一行指定</strong>。默认使用的是proto2。</p><p>（2）<code>java_package</code>：表示的是java包，不指定就使用 package.生成的类会放到该package下。这里表示把生成的类存放在com.fdd.protobuf包下面。</p><p>（3）<code>java_outer_classname</code>：我们说过.proto文件，要生成对应的类，这个参数就指定输出什么类名。这里表示生成的类名是PersonProto。</p><p>（4）<code>message</code> 是用于数据格式定义. </p><ul><li>一个 <em>.proto</em> 文件中可以定义多个 message</li><li>message 中定义的字段支持 string、byte、bool、map、enum、数字类型和用户自定义的 message</li><li>定义字段后面需要指定唯一的标识数字,这些数字用于识别二进制格式 message 中的字段,一旦开始使用这个 message,那么标识数字就不能改变</li><li>如果需要定义 List,则在字段前加repeated即可.</li><li>如果已经使用过该 message 生成的类后,想要增加字段直接新增即可.当新增字段的类解析老数据时,会将新字段置为默认值.当旧的类解析新数据时会忽视掉新增字段.</li></ul><p>比如说这里我们就定义一个复杂的proto文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>option java_package = <span class="hljs-string">&quot;com.fdd.protobuf&quot;</span>;<br>option java_outer_classname = <span class="hljs-string">&quot;Persons&quot;</span>;<br>message Staff &#123;<br>    int32 id = <span class="hljs-number">1</span>;<br>    string name = <span class="hljs-number">2</span>;<br>    int32 age = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// 枚举示例</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PhoneType</span> </span>&#123;<br>        MOBILE = <span class="hljs-number">0</span>;<br>        TELEPHONE = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 嵌套示例</span><br>    message PhoneNumber &#123;<br>        string number = <span class="hljs-number">1</span>;<br>        PhoneType type = <span class="hljs-number">2</span>;<br><br>    &#125; <br>    <span class="hljs-comment">// list示例</span><br>    repeated PhoneNumber phone = <span class="hljs-number">4</span>;      <br>    message Map &#123;<br>        string key = <span class="hljs-number">1</span>;<br>        int32 value = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-comment">// map示例</span><br>    Map map = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这里只是展示一个基本案例，对于其他的数据类型可以根据自己的需要定义即可。</p><h3 id="3、根据proto文件生成class类文件"><a href="#3、根据proto文件生成class类文件" class="headerlink" title="3、根据proto文件生成class类文件"></a><strong>3、根据proto文件生成class类文件</strong></h3><p>编译起来很简单，在我们下载好的protobuf下面有一个bin目录，里面有一个proto.exe。我们就使用这个去编译person.proto文件就好。</p><p><img src="G:\博客\八、分布式专题\2、序列化机制\protobuf\3-生成类文件.png"></p><p>也就是执行proto.exe  –java_out = /  Person.proto就会编译成功。</p><p><img src="G:\博客\八、分布式专题\2、序列化机制\protobuf\4-类文件结果.png"></p><h3 id="4、使用class类文件"><a href="#4、使用class类文件" class="headerlink" title="4、使用class类文件"></a><strong>4、使用class类文件</strong></h3><p>上面意味着我们已经做好了序列化的准备工作，接下来我们就可以直接使用这个类了。</p><p>（1）第一步：将生成的PersonProto类引入到我们的IDEA或者是eclipse中。</p><p>（2）第二步：在idea或者是eclipse添加protobuf的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）第三步：使用</p><p>首先看一些如何序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、 创建Builder</span><br>PersonProto.Person.Builder builder = PersonProto.Person.newBuilder();<br><span class="hljs-comment">//2、 设置Person的属性</span><br>builder.setAge(<span class="hljs-number">20</span>);<br>builder.setName(<span class="hljs-string">&quot;java的架构师技术栈&quot;</span>);<br><span class="hljs-comment">//3、 创建Person</span><br>PersonProto.Person person = builder.build();<br><span class="hljs-comment">//4、序列化</span><br><span class="hljs-keyword">byte</span>[] data = person.toByteArray();<br><span class="hljs-comment">//5、将data保存在本地或者是传到网络</span><br></code></pre></td></tr></table></figure><p>然后反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">//一行代码实现反序列化，data可以是本地数据或者是网络数据</span><br>       PersonProto.Person person = PersonProto.Person.parseFrom(data);<br>       System.out.println(person.getAge());<br>       System.out.println(person.getName());<br>&#125; <span class="hljs-keyword">catch</span> (InvalidProtocolBufferException e) &#123;<br>       e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，基本的使用流程就是这。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上就是我们定义好proto文件，然后使用proto.exe编译成类文件，最后导入这个类和依赖就可以直接使用了。当然这只是一个最简单不过的代码,可以把这篇教程当成一个简单的使用教程。一般情况是是结合SpringBoot来使用的。具体使用会陆续推出。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>序列化机制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试时到底该刷哪些算法题？没关系，这里整理了高频的三百道</title>
    <link href="/2021/01/25/%E5%85%AB%E3%80%81%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E6%97%B6%E5%88%B0%E5%BA%95%E8%AF%A5%E5%88%B7%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9F%E6%B2%A1%E5%85%B3%E7%B3%BB%EF%BC%8C%E8%BF%99%E9%87%8C%E6%95%B4%E7%90%86%E4%BA%86%E9%AB%98%E9%A2%91%E7%9A%84%E4%B8%89%E7%99%BE%E9%81%93/"/>
    <url>/2021/01/25/%E5%85%AB%E3%80%81%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E9%9D%A2%E8%AF%95%E6%97%B6%E5%88%B0%E5%BA%95%E8%AF%A5%E5%88%B7%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9F%E6%B2%A1%E5%85%B3%E7%B3%BB%EF%BC%8C%E8%BF%99%E9%87%8C%E6%95%B4%E7%90%86%E4%BA%86%E9%AB%98%E9%A2%91%E7%9A%84%E4%B8%89%E7%99%BE%E9%81%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="star-前言"><a href="#star-前言" class="headerlink" title=":star:前言"></a><font color="blue">:star:前言</font></h2><p><strong><font color="green">题目来源</font></strong></p><blockquote><p><strong><font color="red">本文最新的题目更新在</font></strong></p><p><strong><a href="https://github.com/fengdongdongwsn/high-frequency-algorithm">https://github.com/fengdongdongwsn/high-frequency-algorithm</a></strong></p></blockquote><p>本文收集了在面试中，公司高频出现的算法题目。避免你在准备开始刷题或者是正在刷题时，没有目标。力扣题目实在是太多了。但是我们没有必要去把每道题都刷一遍。本系列题目主要来源如下：</p><blockquote><ul><li><strong><font color="red">牛客面经整理的面经真题</font></strong></li><li><strong><font color="red">牛客网和力扣上高频面试题栏目收集而来</font></strong></li></ul></blockquote><h2 id="star-高频面试真题"><a href="#star-高频面试真题" class="headerlink" title=":star:高频面试真题"></a><font color="blue">:star:高频面试真题</font></h2><p>表格中的内容很多都是力扣上的，建议牛客上的剑指offer，先刷完</p><table><thead><tr><th>数组</th></tr></thead><tbody><tr><td>力扣1：两数之和</td></tr><tr><td>力扣1299：将每个元素替换为右侧最大元素</td></tr><tr><td>力扣1464：数组中两个元素的最大乘积</td></tr><tr><td>力扣15：三数之和</td></tr><tr><td>力扣179：最大数</td></tr><tr><td>力扣189：旋转数组</td></tr><tr><td>力扣215：数组中第K个最大元素</td></tr><tr><td>力扣239：滑动窗口的最大值</td></tr><tr><td>力扣33：搜索旋转排序数组</td></tr><tr><td>力扣349：两个数组的交集1</td></tr><tr><td>力扣350：两个数组的交集2</td></tr><tr><td>力扣384：打乱数组</td></tr><tr><td>力扣4：求两个正序数组的中位数</td></tr><tr><td>力扣40：数组总和</td></tr><tr><td>力扣41：缺失的第一个正数</td></tr><tr><td>力扣416：分割等和数组</td></tr><tr><td>力扣42：接雨水问题</td></tr><tr><td>力扣442：数组中重复的数据</td></tr><tr><td>力扣448：找到所有数组中消失的数字</td></tr><tr><td>力扣45：跳跃游戏（跳跃次数）</td></tr><tr><td>力扣48：旋转图像</td></tr><tr><td>力扣480：滑动窗口中位数</td></tr><tr><td>力扣525：连续子数组</td></tr><tr><td>力扣54：螺旋矩阵</td></tr><tr><td>力扣55：跳跃游戏（跳跃距离）</td></tr><tr><td>力扣556：下一个更大元素</td></tr><tr><td>力扣56：合并区间</td></tr><tr><td>力扣560：和为K的子数组</td></tr><tr><td>力扣658：找到K个最接近的元素</td></tr><tr><td>力扣659：分割数组为连续子序列</td></tr><tr><td>力扣74：搜索二维矩阵</td></tr><tr><td>力扣84：柱状图中的最大矩行</td></tr><tr><td>力扣88：合并两个有序数组</td></tr><tr><td>力扣915：分割数组</td></tr></tbody></table><table><thead><tr><th>字符串</th></tr></thead><tbody><tr><td>力扣1312：让字符串成为回文串的最少插入次数</td></tr><tr><td>力扣139：单词拆分1</td></tr><tr><td>力扣140：单词拆分2</td></tr><tr><td>力扣165：比较版本号</td></tr><tr><td>力扣22：生成括号</td></tr><tr><td>力扣316：去除重复字母保证字典序最小</td></tr><tr><td>力扣415：字符串相加</td></tr><tr><td>力扣43：字符串相乘</td></tr><tr><td>力扣44：通配符匹配</td></tr><tr><td>力扣443：字符串压缩</td></tr><tr><td>力扣557：反转字符串中的单词</td></tr><tr><td>力扣67：二进制求和</td></tr><tr><td>力扣72：编辑距离</td></tr><tr><td>力扣93：复原IP地址</td></tr><tr><td>剑指offer46：把数字翻译成字符串</td></tr><tr><td>KMP算法</td></tr><tr><td>力扣647：一个字符串中有多少个回文字串</td></tr><tr><td>力扣17：电话号码的字母组合</td></tr></tbody></table><table><thead><tr><th>排序算法</th></tr></thead><tbody><tr><td>快速排序</td></tr><tr><td>插入排序</td></tr><tr><td>归并排序</td></tr><tr><td>希尔排序</td></tr><tr><td>堆排序</td></tr></tbody></table><table><thead><tr><th>最长问题</th></tr></thead><tbody><tr><td>最长回文字串</td></tr><tr><td>最长回文子序列</td></tr><tr><td>最长连续公共字串</td></tr><tr><td>最长公共子序列</td></tr><tr><td>最长连续为1的字串</td></tr><tr><td>最长有效括号</td></tr><tr><td>最长无重复字符的连续字串</td></tr><tr><td>最长等差数列</td></tr><tr><td>最长上升连续序列</td></tr><tr><td>最长上升子序列</td></tr><tr><td>最长和谐子序列</td></tr></tbody></table><table><thead><tr><th>动态规划问题</th></tr></thead><tbody><tr><td>力扣121：买卖股票（一次交易）</td></tr><tr><td>力扣122：买卖股票（多次交易）</td></tr><tr><td>力扣134：加油站</td></tr><tr><td>力扣309：买卖股票（包含冷冻时间）</td></tr><tr><td>力扣322：零钱兑换</td></tr><tr><td>力扣518：零钱兑换</td></tr><tr><td>力扣53：最大子緒和</td></tr><tr><td>力扣674：未经排序数组最长连续递增序列</td></tr></tbody></table><table><thead><tr><th>链表</th></tr></thead><tbody><tr><td>力扣109：将有序链表转化为二叉搜素树</td></tr><tr><td>力扣141：环形链表判断是否有环</td></tr><tr><td>力扣142：环形链表检测入口位置</td></tr><tr><td>力扣143：重拍链表</td></tr><tr><td>力扣160：相交链表</td></tr><tr><td>力扣206：反转链表</td></tr><tr><td>力扣21：合并两个有序链表</td></tr><tr><td>力扣23：合并K和有序链表</td></tr><tr><td>力扣234：回文联表</td></tr><tr><td>力扣25：K个一组反转链表</td></tr><tr><td>力扣328：奇偶链表</td></tr><tr><td>力扣445：链表求和（头对齐：尾对齐）</td></tr><tr><td>力扣80：删除排序数组中的重复元素</td></tr><tr><td>力扣82：删除重复元素</td></tr><tr><td>力扣83：删除排序链表中的重复元素</td></tr><tr><td>力扣86：分割链表</td></tr><tr><td>剑指offer：二叉搜索树和双向链表</td></tr><tr><td>剑指offer22：链表中倒数第K个节点</td></tr><tr><td>剑指offer54：二叉搜索树中的第K大节点</td></tr><tr><td>LRU实现</td></tr></tbody></table><table><thead><tr><th>树</th></tr></thead><tbody><tr><td>力扣102：二叉搜索树的层次遍历</td></tr><tr><td>力扣105：从前序和中序重构二叉树</td></tr><tr><td>力扣108：将有序数组转化为二叉搜索树</td></tr><tr><td>力扣110：平衡二叉树</td></tr><tr><td>力扣113：路径总和</td></tr><tr><td>力扣124：二叉树的最大路径和</td></tr><tr><td>力扣1325：删除给定值的叶子节点</td></tr><tr><td>力扣144：二叉树的前序遍历（非递归）</td></tr><tr><td>力扣145：二叉树的后续遍历（非递归）</td></tr><tr><td>力扣199：二叉树的右视图</td></tr><tr><td>力扣208：实现Trie前缀树</td></tr><tr><td>力扣222：完全二叉树的节点数</td></tr><tr><td>力扣226：翻转二叉树</td></tr><tr><td>力扣236：二叉树的最近公共祖先</td></tr><tr><td>力扣257：二叉树的所有路径</td></tr><tr><td>力扣297：二叉树的序列化和反序列化</td></tr><tr><td>力扣450：删除二叉树中的节点</td></tr><tr><td>力扣543：二叉树的直径长度</td></tr><tr><td>力扣617：合并二叉树</td></tr><tr><td>力扣662：二叉树的最大宽度</td></tr><tr><td>力扣687：最长同值路径</td></tr><tr><td>力扣94：二叉树中序遍历（非递归）</td></tr><tr><td>力扣958：二叉树的完全性检验</td></tr><tr><td>力扣98：验证二叉搜索树</td></tr><tr><td>力扣99：恢复二叉搜索树</td></tr></tbody></table><table><thead><tr><th>深搜</th></tr></thead><tbody><tr><td>力扣1254：封闭岛屿的数目</td></tr><tr><td>力扣200：岛屿的数量</td></tr><tr><td>力扣209：课程表</td></tr><tr><td>力扣365：水壶问题</td></tr><tr><td>力扣46：全排序</td></tr><tr><td>力扣463：岛屿的周长</td></tr><tr><td>力扣547：朋友圈</td></tr><tr><td>力扣695：岛屿的面积</td></tr><tr><td>力扣733：颜色渲染</td></tr><tr><td>二维矩阵中寻找最大正方形</td></tr><tr><td>矩阵中的路径</td></tr><tr><td>括号生成</td></tr><tr><td>幂集</td></tr></tbody></table><table><thead><tr><th>数学问题</th></tr></thead><tbody><tr><td>力扣1240：铺瓷砖</td></tr><tr><td>力扣202：快乐数</td></tr><tr><td>力扣204：计算质数</td></tr><tr><td>力扣37：解数独</td></tr><tr><td>力扣43：字符串相乘</td></tr><tr><td>力扣50：计算pow</td></tr><tr><td>力扣509：斐波那契数列</td></tr><tr><td>力扣679:24点游戏</td></tr><tr><td>力扣7：回文素数</td></tr><tr><td>计算表达式的值</td></tr><tr><td>开平方根函数（会两种）</td></tr><tr><td>数字转16进制</td></tr></tbody></table><table><thead><tr><th>堆栈问题</th></tr></thead><tbody><tr><td>力扣155：最小栈</td></tr><tr><td>力扣225：用队列实现栈</td></tr><tr><td>力扣232：用两个栈实现队列</td></tr><tr><td>力扣312：戳气球</td></tr><tr><td>面试金典0305：栈排序</td></tr><tr><td>使用数组实现队列</td></tr><tr><td>栈的压入弹出序列是否合法</td></tr><tr><td>会议安排</td></tr><tr><td>力扣406：根据身高重建队列</td></tr></tbody></table><table><thead><tr><th>其他真题</th></tr></thead><tbody><tr><td>力扣135：分发糖果</td></tr><tr><td>力扣198：打家劫舍</td></tr><tr><td>力扣213：打家劫舍</td></tr><tr><td>力扣337：打家劫舍</td></tr><tr><td>力扣301：删除无效的括号</td></tr><tr><td>两个线程交替打印奇偶数</td></tr><tr><td>三个线程顺序打印ABC</td></tr><tr><td>实现读写锁</td></tr><tr><td>死锁的案例</td></tr></tbody></table><p><strong><font color="red">本文题目持续更新。。。。</font></strong></p><blockquote><p><strong><font color="red">本文最新的题目更新在</font></strong></p><p><strong><a href="https://github.com/fengdongdongwsn/high-frequency-algorithm">https://github.com/fengdongdongwsn/high-frequency-algorithm</a></strong></p></blockquote><p><strong><font color="blur">给个支持呗:heart:</font></strong></p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>高频算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Actuator（无坑版）</title>
    <link href="/2021/01/25/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/SpringBoot%E6%95%B4%E5%90%88Actuator%EF%BC%88%E6%97%A0%E5%9D%91%E7%89%88%EF%BC%89/"/>
    <url>/2021/01/25/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/SpringBoot%E6%95%B4%E5%90%88Actuator%EF%BC%88%E6%97%A0%E5%9D%91%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候我们想要实时监控我们的应用程序的运行状态，比如实时显示一些指标数据，观察每时每刻访问的流量，或者是我们数据库的访问状态等等。这时候就需要<code>Actuator</code>了。</p><p>使用Actuator的好处是，我们可以直接使用这个生产级别的工具，而不需要自己去实现这些东西。Actuator可以自动帮我们自动暴露出这些信息，使用HTTP或者是JMX beans的方式实现。最主要的是我们直接在properties文件中配置即可。</p><p>下面看看如何实现：</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>创建一个springboot项目，我使用的是Springboot2.4的版本。</p><h3 id="第一步：添加依赖"><a href="#第一步：添加依赖" class="headerlink" title="第一步：添加依赖"></a>第一步：添加依赖</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--监控依赖--&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>依赖就这么简单。</p><h3 id="第二步：配置"><a href="#第二步：配置" class="headerlink" title="第二步：配置"></a>第二步：配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#改变应用程序的端口</span><br><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><br><br><span class="hljs-comment">#1、actuator默认只开启了info和health两个端点</span><br><span class="hljs-comment">#以下配置可以开启所有的端点：</span><br><span class="hljs-meta">management.endpoints.web.exposure.include</span>= <span class="hljs-string">*</span><br><br><span class="hljs-comment">#2、开启健康监控数据</span><br><span class="hljs-meta">management.endpoint.health.show-details</span>=<span class="hljs-string">always</span><br><br><span class="hljs-comment">#3、启用httptrace端点</span><br><span class="hljs-meta">management.endpoint.httptrace.enabled</span>=<span class="hljs-string">true</span><br><br><span class="hljs-comment">#4、每次都要加个actuator前缀太麻烦，改变端点前缀路径</span><br><span class="hljs-meta">management.endpoints.web.base-path</span>= <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p>这么增加了几个配置。</p><p>现在我们直接访问就可以了。</p><h3 id="第三步：直接访问"><a href="#第三步：直接访问" class="headerlink" title="第三步：直接访问"></a>第三步：直接访问</h3><p>由于在前面我们配置了自己的base-path。所以不需要增加actuator的前缀。现在访问：</p><p><a href="http://localhost:8081/mappings">http://localhost:8081/mappings</a></p><p><img src="https://s3.ax1x.com/2021/01/21/shKjNq.png"></p><p>我们访问就会出现这样的画面，看着有点难看，不过有了这些信息，还可以格式化显示，目前也有很多开源的项目可以自动实现。</p><p>其他的端口如下：可以把上面的地址的mappings改变一下就可以了。</p><table><thead><tr><th>EndPoints</th><th>描述</th></tr></thead><tbody><tr><td>auditevents</td><td>公开当前应用程序的审核事件信息。</td></tr><tr><td>beans</td><td>显示应用程序中所有Spring bean的完整列表。</td></tr><tr><td>caches</td><td>暴露可用的缓存。</td></tr><tr><td>conditions</td><td>显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</td></tr><tr><td>configprops</td><td>显示所有的整理列表@ConfigurationProperties,查看配置属性，包括默认配置</td></tr><tr><td>env</td><td>露出Spring的属性的各种环境变量,后面可跟/{name}查看具体的值</td></tr><tr><td>flyway</td><td>显示已应用的任何Flyway数据库迁移。</td></tr><tr><td>health</td><td>显示应用健康信息,2.0以后需要在配置里show-details打开k开关</td></tr><tr><td>httptrace</td><td>显示HTTP跟踪信息,2.0以后需要手动打开</td></tr><tr><td>info</td><td>显示任意应用信息,是在配置文件里自己定义的</td></tr><tr><td>integrationgraph</td><td>显示Spring Integration图。</td></tr><tr><td>loggers</td><td>显示和修改应用程序中记录器的配置。</td></tr><tr><td>liquibase</td><td>显示已应用的任何Liquibase数据库迁移。</td></tr><tr><td>metrics</td><td>显示指标信息,比如内存用量和HTTP请求计数,后可跟/{name}查看具体值</td></tr><tr><td>mappings</td><td>显示所有@RequestMapping路径的整理列表。</td></tr><tr><td>scheduledtasks</td><td>显示应用程序中的计划任务。</td></tr><tr><td>sessions</td><td>允许从Spring Session支持的会话存储中检索和删除用户会话。</td></tr><tr><td>shutdown</td><td>允许应用程序正常关闭。</td></tr><tr><td>threaddump</td><td>执行线程转储。</td></tr></tbody></table><p>OK。基本上是这样。</p><h2 id="为Actuator添加安全验证"><a href="#为Actuator添加安全验证" class="headerlink" title="为Actuator添加安全验证"></a>为Actuator添加安全验证</h2><p>比如我们的Actuator的端口不想被无关人员看到，于是就可以配置Spring security添加登录。方式如下：</p><h3 id="第一步：添加依赖-1"><a href="#第一步：添加依赖-1" class="headerlink" title="第一步：添加依赖"></a>第一步：添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第二步：在properties文件中添加配置"><a href="#第二步：在properties文件中添加配置" class="headerlink" title="第二步：在properties文件中添加配置"></a>第二步：在properties文件中添加配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#5、端口信息被别人看到了咋办，可以添加个security</span><br><span class="hljs-meta">spring.security.user.name</span>= <span class="hljs-string">fdd</span><br><span class="hljs-meta">spring.security.user.password</span>= <span class="hljs-string">123456</span><br><span class="hljs-meta">spring.security.user.roles</span>= <span class="hljs-string">ADMIN</span><br></code></pre></td></tr></table></figure><p>这里设置的用户面是fdd，密码123456，角色是ADMIN。</p><h3 id="第三步：重新访问上面的端口地址"><a href="#第三步：重新访问上面的端口地址" class="headerlink" title="第三步：重新访问上面的端口地址"></a>第三步：重新访问上面的端口地址</h3><p><img src="https://s3.ax1x.com/2021/01/21/shKXEn.png"></p><p>重新访问相关端口地址，就会被重定向到登录页面。使用配置好的用户名密码登录即可。</p><p>OK，这个比较简单。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Spring系列</category>
      
      <category>Springboot专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何用钩子函数，优雅地关闭JVM</title>
    <link href="/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E5%A6%82%E4%BD%95%E7%94%A8%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%ADJVM/"/>
    <url>/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E5%A6%82%E4%BD%95%E7%94%A8%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%ADJVM/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="1、基本概述"><a href="#1、基本概述" class="headerlink" title="1、基本概述"></a>1、基本概述</h3><p>程序的启动很简单，启动的时候通常会做一些预加载资源的操作。但是有时候关闭的时候，启动的时候预加载的资源并没有完全清理干净，因此可以使用钩子函数来完成。</p><h3 id="2、JVM关闭的场景分类"><a href="#2、JVM关闭的场景分类" class="headerlink" title="2、JVM关闭的场景分类"></a>2、JVM关闭的场景分类</h3><p>直接看一张图吧，本图来自博客园的BarryWang，特在此说明。</p><p><img src="https://img2018.cnblogs.com/blog/693275/201811/693275-20181122132745586-1047326555.jpg" alt="img"></p><p>从上面可以看到，JVM关闭主要分为了三类，第一种是正常的关闭，第二种是异常关闭的情况，第三种是强制关闭的情况。<code>对于前两种方式我们可以使用钩子函数优雅的关闭，但是强制关闭的时候钩子函数并不起作用。</code></p><p>有了这些概念，我们直接使用一个案例进行演示，再进行分析。</p><h2 id="一、代码演示钩子函数"><a href="#一、代码演示钩子函数" class="headerlink" title="一、代码演示钩子函数"></a>一、代码演示钩子函数</h2><h3 id="1、JVM正常关闭"><a href="#1、JVM正常关闭" class="headerlink" title="1、JVM正常关闭"></a>1、JVM正常关闭</h3><p>直接看代码吧，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(()-&gt; <br>System.out.println(<span class="hljs-string">&quot;钩子函数被执行，可以在这里关闭资源&quot;</span>)<br>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br><span class="hljs-keyword">new</span> Test().start();<br>System.out.println(<span class="hljs-string">&quot;主应用程序在执行&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//控制台输出</span><br><span class="hljs-comment">//主应用程序在执行</span><br><span class="hljs-comment">//钩子函数被执行，可以在这里关闭资源</span><br></code></pre></td></tr></table></figure><p>看控制台打印，可以发现，主应用程序执行完之后就会调用钩子函数，接下来就会正式的关闭JVM。</p><h3 id="2、异常关闭"><a href="#2、异常关闭" class="headerlink" title="2、异常关闭"></a>2、异常关闭</h3><p>还是直接看代码演示，这里我们演示异常关闭的第二种OOM的情况，我们可以先设置堆的大小为20M，然后在代码中创建一个500M的对象，这样就会OOM。参数是<code>-Xmx20M</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(()-&gt; <br>System.out.println(<span class="hljs-string">&quot;钩子函数被执行，可以在这里关闭资源&quot;</span>)<br>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br><span class="hljs-keyword">new</span> Test().start();<br>System.out.println(<span class="hljs-string">&quot;主应用程序在执行&quot;</span>);<br>Runtime.getRuntime().halt(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">500</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>&#125;<br>&#125;<br><span class="hljs-comment">//控制台输出</span><br><span class="hljs-comment">//主应用程序在执行</span><br><span class="hljs-comment">//钩子函数被执行，可以在这里关闭资源</span><br></code></pre></td></tr></table></figure><p>从控制台可以看出，钩子函数在异常关闭的时候依然会被调用。</p><h3 id="3、强制关闭"><a href="#3、强制关闭" class="headerlink" title="3、强制关闭"></a>3、强制关闭</h3><p>这里我们使用<code>Runtime.getRuntime().halt()</code>来演示强势关闭。这个方法和<code>System.exit</code>的区别是，<code>System.exit</code>会执行钩子函数，但是<code>Runtime.getRuntime().halt()</code>不会。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(()-&gt; <br>System.out.println(<span class="hljs-string">&quot;钩子函数被执行，可以在这里关闭资源&quot;</span>)<br>));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br><span class="hljs-keyword">new</span> Test().start();<br>System.out.println(<span class="hljs-string">&quot;主应用程序在执行&quot;</span>);<br>Runtime.getRuntime().halt(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">//控制台输出</span><br><span class="hljs-comment">//主应用程序在执行</span><br></code></pre></td></tr></table></figure><p>从上面代码的输出可以看出，调用了<code>Runtime.getRuntime().halt(1)</code>就会强制关闭JVM，钩子函数来不及执行就关闭了。而使用<code>System.exit</code>依然会执行。所以一般使用<code>System.exit</code>来关闭JVM。</p><h3 id="4、移除钩子函数"><a href="#4、移除钩子函数" class="headerlink" title="4、移除钩子函数"></a>4、移除钩子函数</h3><p>上面演示了钩子函数的作用，有时候我们想移除也比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br><span class="hljs-comment">//new Test().start();</span><br>Thread willNotRun = <span class="hljs-keyword">new</span> Thread(() -&gt; <br>System.out.println(<span class="hljs-string">&quot;Won&#x27;t run!&quot;</span>));<br>Runtime.getRuntime().addShutdownHook(willNotRun);<br>System.out.println(<span class="hljs-string">&quot;主应用程序在执行&quot;</span>);<br>Runtime.getRuntime().removeShutdownHook(willNotRun);<br>&#125;<br>&#125;<br><span class="hljs-comment">//控制台输出</span><br><span class="hljs-comment">//主应用程序在执行</span><br></code></pre></td></tr></table></figure><p>OK，钩子函数的基本操作就写到这，使用起来比较简单，不过我之前看过Spring的启动流程，所以又去那个启动流程看了一波，发现也使用到了钩子函数。</p><h2 id="二、典型应用场景"><a href="#二、典型应用场景" class="headerlink" title="二、典型应用场景"></a>二、典型应用场景</h2><h3 id="1、Spring使用"><a href="#1、Spring使用" class="headerlink" title="1、Spring使用"></a>1、Spring使用</h3><p>Spring在关闭上下文的时候，可以使用钩子函数来关闭残留的资源。方法是使用<code>ApplicationContext</code>注册一个钩子函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">ApplicationContext.registerShutdownHook();<br><span class="hljs-comment">//上面的这句代码可以分析进去看看</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerShutdownHook</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.shutdownHook == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.shutdownHook = <span class="hljs-keyword">new</span> Thread() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-comment">//Spring正常关闭</span><br>          doClose();<br>        &#125;<br>      &#125;;<br>      <span class="hljs-comment">//调用钩子函数关闭残留资源</span><br>      Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">this</span>.shutdownHook);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码可以看出，Spring其实也是调用了Java的钩子函数进行关闭的。</p><h3 id="2、其他使用"><a href="#2、其他使用" class="headerlink" title="2、其他使用"></a>2、其他使用</h3><p>我在很多博客中也看到了spark和hadoop的关闭，由于我没看过源码，所以这里我说一下结论，对于其他的使用场景，基本上也是调用了Java的钩子函数来执行的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在关闭JVM的时候，我们可以封装钩子函数去优雅的关闭线程。不过在使用的时候还需要注意以下几个方面：</p><h3 id="1、钩子函数本质是个线程"><a href="#1、钩子函数本质是个线程" class="headerlink" title="1、钩子函数本质是个线程"></a>1、钩子函数本质是个线程</h3><p>多个钩子会并发执行，JVM并不保证它们的执行顺序；因此最好是在一个钩子中执行一系列操作。</p><h3 id="2、钩子中不能再新建钩子"><a href="#2、钩子中不能再新建钩子" class="headerlink" title="2、钩子中不能再新建钩子"></a>2、钩子中不能再新建钩子</h3><p>在关闭钩子中，不能执行注册、移除钩子的操作，否则JVM抛出 IllegalStateException。也不能使用System.exit()，前面提到System.exit()会触发钩子函数的执行，但是Runtime.halt()可以，因为Runtime.halt()可以强制关闭。</p><h3 id="3、钩子里最好不要有耗时操作"><a href="#3、钩子里最好不要有耗时操作" class="headerlink" title="3、钩子里最好不要有耗时操作"></a>3、钩子里最好不要有耗时操作</h3><p>钩子函数主要用于关闭残留资源，因此不要有一些耗时的操作。</p><p>OK，先写到这。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某个文件夹发生了增删改查操作，如何用java实时监控？</title>
    <link href="/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/6%E3%80%81java%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%91%E7%94%9F%E4%BA%86%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8java%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%EF%BC%9F/"/>
    <url>/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/6%E3%80%81java%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%91%E7%94%9F%E4%BA%86%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8java%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候你可能有个疑问，IDE总是可以检测到外部文件是否发生了变化，比如你在某个类里面加了一些代码，这时候的IDE就会弹出一个框说你做了更改。再或者是某个文件夹下的文件发生了改变，比如新建了一个或者是删除了一个等等。这时候我们的IDE依然可以检测到。这个功能到底是如何实现的呢？这篇文章主要是研究NIO的其中一个类，叫做<code>WatchService</code>。</p><blockquote><p>也有一些其他的方式可以轻松地实现监控文件夹的功能，比如说java轮询的方式，或者是common-io的方式，我会慢慢比较。</p></blockquote><p>OK，我们直接来看一下简单例子如何实现，再去分析如何实现的？</p><h2 id="一、代码实现"><a href="#一、代码实现" class="headerlink" title="一、代码实现"></a>一、代码实现</h2><h3 id="1、简单案例"><a href="#1、简单案例" class="headerlink" title="1、简单案例"></a>1、简单案例</h3><p>这个代码很简单，只需要四步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>   <span class="hljs-comment">//第一步：取得WatchService</span><br>   WatchService watchService = FileSystems.getDefault().newWatchService();<br>   <span class="hljs-comment">//第二步：确定要监控的路径</span><br>   Path path = Paths.get(<span class="hljs-string">&quot;G:\\&quot;</span>);<br>   <span class="hljs-comment">//第三步：为本路径绑定WatchService，并确定监控的事件</span><br>   path.register(<br>       watchService,<br>       StandardWatchEventKinds.ENTRY_CREATE,<br>       StandardWatchEventKinds.ENTRY_DELETE,<br>       StandardWatchEventKinds.ENTRY_MODIFY);<br>   WatchKey key;<br>   <span class="hljs-comment">//第四步：当有事件时，开始触发</span><br>   <span class="hljs-keyword">while</span> ((key = watchService.take()) != <span class="hljs-keyword">null</span>) &#123;<br>       <span class="hljs-keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;<br>          System.out.println(<span class="hljs-string">&quot;事件&quot;</span> + event.kind() + <span class="hljs-string">&quot;发生了，文件是：&quot;</span> + event.context());<br>       &#125;<br>       key.reset();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们监控G盘，然后我们在G盘新建文件，然后删除修改，就会在后台打印相关信息。</p><p><img src="https://s3.ax1x.com/2021/01/18/syveQ1.png"></p><p>现在就可以监控了，很简单。</p><h3 id="2、代码分析"><a href="#2、代码分析" class="headerlink" title="2、代码分析"></a>2、代码分析</h3><p>第一步和第二步，新建一个取得WatchService和取得要监控的路径，这个很容易理解。</p><p>第三步绑定，这里只需要注意两件重要的事情：首先，<code>path</code>将<code>watchService</code>作为第一个参数，然后是StandardWatchEventKinds的变量参数。一共有四种。</p><ul><li><strong><em>StandardWatchEventKinds.ENTRY_CREATE</em></strong>—当有新文件时触发。可能是创建了一个新文件。</li><li><strong><em>StandardWatchEventKinds.ENTRY_MODIFY</em></strong>—当文件被修改时触发。所有的文件编辑都会触发这个事件。在一些平台上，甚至改变文件属性也会触发它。</li><li><strong><em>StandardWatchEventKinds.ENTRY_DELETE</em></strong>—当文件被删除、移动或重命名时触发。</li><li><strong><em>StandardWatchEventKinds.OVERFLOW</em></strong>—触发表示丢失或丢弃的事件。</li></ul><p>第四步不断监控，当watchService里面不为空时，开始获取相应的事件，并poll弹出。最后还有一个reset 表示回退到相应的句柄，继续处理下一次事件。</p><h3 id="3、源码分析"><a href="#3、源码分析" class="headerlink" title="3、源码分析"></a>3、源码分析</h3><p>由于watchService是一个接口，所以分析起来也比较简单。里面一共包含了三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法1：关闭watchService</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><span class="hljs-comment">//方法2：弹出事件</span><br><span class="hljs-function">WatchKey <span class="hljs-title">poll</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//方法3：带有参数的弹出</span><br><span class="hljs-function">WatchKey <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><span class="hljs-comment">//方法4：获取事件。</span><br><span class="hljs-function">WatchKey <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br></code></pre></td></tr></table></figure><p>由于方法比较简单，所以我们可以直接看方法上的注释就可以了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>WatchService接口是在<code>java7</code>的版本中引入的。主要是处理NIO的文件相关问题。但是WatchService其实是有很多缺点的。</p><ul><li>WatchService是采用扫描式的，效率低。</li><li>WatchService代码写起来费劲。虽然上面看起来很简洁了，但是实际开发时麻烦。</li><li>WatchService不能监听到多级目录，事先父文件夹需要存在。</li></ul><p>鉴于以上原因，在简单的实现时，可以使用，但是还有一个更强大的工具<code>commons-io</code>，使用更简单也更加的高效。下篇文章给出。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>碎知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
      <tag>java基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot整合Swagger2（无坑版）</title>
    <link href="/2021/01/25/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/Springboot%E6%95%B4%E5%90%88Swagger2%EF%BC%88%E6%97%A0%E5%9D%91%E7%89%88%EF%BC%89/"/>
    <url>/2021/01/25/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/Springboot%E6%95%B4%E5%90%88Swagger2%EF%BC%88%E6%97%A0%E5%9D%91%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文出自《愚公要移山》</p><p>收录于《Springboot专题》中</p></blockquote><p>这种整合的文章确实已经烂大街了，写他一方面是补充我的springboot系列，另一方面确实还有一部分小伙伴没用过。最重要的是，如果你忘记了这种整合的代码。可以随时查阅。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在的开发基本上都是前后端分离，前后端交互都是通过API文档。有了API文档大家各自开发，互不干扰。</p><h3 id="1、传统方式"><a href="#1、传统方式" class="headerlink" title="1、传统方式"></a>1、传统方式</h3><p>传统方式是文档设计好之后，分别发给前端和后端人员。这样有个缺点，接口信息一旦变化，文档就需要重新发送给前后端人员。无法做到实时。所以浪费时间和精力。</p><h3 id="2、swagger方式"><a href="#2、swagger方式" class="headerlink" title="2、swagger方式"></a>2、swagger方式</h3><p>我们的后台应用集成了swagger之后，会自动暴露出我们的接口，而且这个接口形式还是通过restful风格发布的。一旦后端的接口有变化，会立刻显示出来，因此极大地提高了效率。</p><p>OK，基本上一句话就可以总结他的好处，那就是后端写的api文档可以通过swagger的形式实时的发布出来，供前端人员查看。</p><h3 id="3、其他方式"><a href="#3、其他方式" class="headerlink" title="3、其他方式"></a>3、其他方式</h3><p>swagger的页面说实话长得不好看，也有一些其他的方案，不是有很多bug，就是收费。目前swagger是使用的最多的。我目前也正在做这个样的开源项目，基于swagger做出类似于其他方案的页面，而且功能更加的强大。</p><h2 id="一、代码整合"><a href="#一、代码整合" class="headerlink" title="一、代码整合"></a>一、代码整合</h2><p>前提条件是要新建一个springboot项目。这点就不演示了。</p><h3 id="第一步：添加依赖"><a href="#第一步：添加依赖" class="headerlink" title="第一步：添加依赖"></a>第一步：添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.9.2的版本是用的最多的，具体的可以直接去maven的官网去搜索，找一个使用量最多的版本即可。</p><h3 id="第二步：配置"><a href="#第二步：配置" class="headerlink" title="第二步：配置"></a>第二步：配置</h3><p>新建config包，创建SwaggerConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>             .apiInfo(apiInfo())<br>             .select()<br>             <span class="hljs-comment">//为当前包路径,控制器类包</span><br>             .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.fdd.controller&quot;</span>))<br>            .paths(PathSelectors.any())<br>             .build();<br>    &#125;<br>    <span class="hljs-comment">//构建 api文档的详细信息函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>            <span class="hljs-comment">//页面标题</span><br>           .title(<span class="hljs-string">&quot;XX平台API接口文档&quot;</span>)<br>            <span class="hljs-comment">//创建人</span><br>           .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;冯冬冬&quot;</span>, <span class="hljs-string">&quot;http://www.javachat.cc&quot;</span>,  <br>           <span class="hljs-string">&quot;3049352171@qq.com&quot;</span>))<br>           <span class="hljs-comment">//版本号</span><br>          .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>           <span class="hljs-comment">//描述</span><br>          .description(<span class="hljs-string">&quot;系统API描述&quot;</span>)<br>          .build();<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里的配置也比较简单。这里有很多选项供我们去配置。如果我们的项目有多个组，只需要创建多个Docket即可。这时候扫描的包换成每个组的包路径。</p><h3 id="第三步：controller类中配置"><a href="#第三步：controller类中配置" class="headerlink" title="第三步：controller类中配置"></a>第三步：controller类中配置</h3><p>新建一个controller包，然后创建HelloController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Api(&quot;Hello控制类&quot;)</span><br><span class="hljs-meta">@RestController</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(value = &quot;/user&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;愚公要移山&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@ApiOperation(&quot;可以指定参数的API&quot;)</span><br>    <span class="hljs-meta">@PostMapping(&quot;/param&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;用户名&quot;)</span> String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以看出，使用注解就可以对这个类、方法、字段等等进行解释说明。其他的字段还有很多，在使用的时候会有相应的提示，可以自己试一遍：</p><p><img src="https://s3.ax1x.com/2021/01/16/sDJiOx.png"></p><h3 id="第四步：查看效果"><a href="#第四步：查看效果" class="headerlink" title="第四步：查看效果"></a>第四步：查看效果</h3><p>访问:<a href="http://127.0.0.1:8080/swagger-ui.html%E5%8D%B3%E5%8F%AF%E3%80%82">http://127.0.0.1:8080/swagger-ui.html即可。</a></p><p><img src="https://s3.ax1x.com/2021/01/16/sDJA0K.png"></p><p>这里就是最终的展示效果。OK，到这一步基本上就集成进来了。下面说一下可能会遇到的配置。</p><h2 id="三、常见其他问题"><a href="#三、常见其他问题" class="headerlink" title="三、常见其他问题"></a>三、常见其他问题</h2><h3 id="1、Spring-Security-配置免认证访问"><a href="#1、Spring-Security-配置免认证访问" class="headerlink" title="1、Spring Security - 配置免认证访问"></a>1、Spring Security - 配置免认证访问</h3><p>有时候我们的Springboot集成了SpringSecurity，这时候如果访问swagger的地址会自动跳转到登录页面。这是因为SpringSecurity对其进行了拦截。为此我们只需要在我们的SpringSecurity配置一下进行放行即可。</p><p><img src="https://s3.ax1x.com/2021/01/16/sDJP61.png"></p><p>现在配置一下，进行放行。在config包下新建一个SpringSecurityConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        http<br>                .authorizeRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/swagger-ui.html&quot;</span>).permitAll()<br>                .antMatchers(<span class="hljs-string">&quot;/webjars/**&quot;</span>).permitAll()<br>                .antMatchers(<span class="hljs-string">&quot;/swagger-resources/**&quot;</span>).permitAll()<br>                .antMatchers(<span class="hljs-string">&quot;/v2/*&quot;</span>).permitAll()<br>                .antMatchers(<span class="hljs-string">&quot;/csrf&quot;</span>).permitAll()<br>                .antMatchers(<span class="hljs-string">&quot;/&quot;</span>).permitAll()<br>                .anyRequest().authenticated()<br>                .and()<br>                .formLogin()<br>        ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就可以正常的访问了。</p><h3 id="2、为swagger设置jwt"><a href="#2、为swagger设置jwt" class="headerlink" title="2、为swagger设置jwt"></a>2、为swagger设置jwt</h3><p>这种方式比较简单，只需要一步即可。修改我们的swaggerConfig类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">api</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .securityContexts(Arrays.asList(securityContext()))<br>                .securitySchemes(Arrays.asList(apiKey()))<br>                .select()<br>                .apis(RequestHandlerSelectors.any())<br>                .paths(PathSelectors.any())<br>                .build();<br>    &#125;<br>    <span class="hljs-comment">//构建 api文档的详细信息函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>                <span class="hljs-comment">//页面标题</span><br>                .title(<span class="hljs-string">&quot;XX平台API接口文档&quot;</span>)<br>                <span class="hljs-comment">//创建人</span><br>                .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;冯冬冬&quot;</span>, <span class="hljs-string">&quot;http://www.javachat.cc&quot;</span>,<br>                        <span class="hljs-string">&quot;3049352171@qq.com&quot;</span>))<br>                <span class="hljs-comment">//版本号</span><br>                .version(<span class="hljs-string">&quot;1.0&quot;</span>)<br>                <span class="hljs-comment">//描述</span><br>                .description(<span class="hljs-string">&quot;系统API描述&quot;</span>)<br>                .build();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiKey <span class="hljs-title">apiKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiKey(<span class="hljs-string">&quot;JWT&quot;</span>, <span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;header&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> SecurityContext <span class="hljs-title">securityContext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SecurityContext.builder().securityReferences(defaultAuth()).build();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;SecurityReference&gt; <span class="hljs-title">defaultAuth</span><span class="hljs-params">()</span> </span>&#123;<br>        AuthorizationScope authorizationScope <br>        = <span class="hljs-keyword">new</span> AuthorizationScope(<span class="hljs-string">&quot;global&quot;</span>, <span class="hljs-string">&quot;accessEverything&quot;</span>);<br>        AuthorizationScope[] authorizationScopes = <span class="hljs-keyword">new</span> AuthorizationScope[<span class="hljs-number">1</span>];<br>        authorizationScopes[<span class="hljs-number">0</span>] = authorizationScope;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> SecurityReference(<span class="hljs-string">&quot;JWT&quot;</span>, authorizationScopes));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>加了一些token验证的代码，比较简单，关于JWT的东西，可以私下了解。这里不赘述了。</p><h3 id="3、隐藏Endpoint"><a href="#3、隐藏Endpoint" class="headerlink" title="3、隐藏Endpoint"></a>3、隐藏Endpoint</h3><p>有时候自己写的controller，或者是controller里面的接口方法不想让前端人员看到，我们可以隐藏即可。</p><h4 id="第一：隐藏整个controller"><a href="#第一：隐藏整个controller" class="headerlink" title="第一：隐藏整个controller"></a>第一：隐藏整个controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiIgnore</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-comment">//方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二：隐藏某个接口方法1"><a href="#第二：隐藏某个接口方法1" class="headerlink" title="第二：隐藏某个接口方法1"></a>第二：隐藏某个接口方法1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiIgnore</span><br><span class="hljs-meta">@ApiOperation(value = &quot;描述信息&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/getAuthor&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;愚公要移山&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三：隐藏某个接口方法2"><a href="#第三：隐藏某个接口方法2" class="headerlink" title="第三：隐藏某个接口方法2"></a>第三：隐藏某个接口方法2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(value = &quot;描述信息&quot;, hidden = true)</span><br><span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> LocalDate <span class="hljs-title">getDate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> LocalDate.now();<br>&#125;<br></code></pre></td></tr></table></figure><p>代码已上传到github中：<br><a href="https://github.com/fengdongdongwsn/springboot-example">https://github.com/fengdongdongwsn/springboot-example</a></p><p>OK，很多配置基本上就到这了。后续会继续补充。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Spring系列</category>
      
      <category>Springboot专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java如何高效的读取一个超大文件？</title>
    <link href="/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/6%E3%80%81java%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/java%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6%EF%BC%9F/"/>
    <url>/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/6%E3%80%81java%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/java%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E8%B6%85%E5%A4%A7%E6%96%87%E4%BB%B6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我最近在优化我的PDF转word的开源小工具，有时候会遇到一个问题，就是如果我的PDF文件比较大，几百兆，如何更快更节省内存的读取它。于是我分析对比了四种常见的读取文件的方式，并使用javaVisualVM工具进行了分析。最后的出的结论是commons-io时间和空间都更加的高效。研究分析依然来自哪位baeldung国外大佬。</p><p>下面我会给出几种常见的读取大文件的方式。</p><h2 id="读取大文件的四种方式"><a href="#读取大文件的四种方式" class="headerlink" title="读取大文件的四种方式"></a>读取大文件的四种方式</h2><p>首先我自己在本地压缩了一个文件夹，大概500M左右。虽然不是很大但是，相对还可以。</p><h3 id="方法1：Guava读取"><a href="#方法1：Guava读取" class="headerlink" title="方法1：Guava读取"></a>方法1：Guava读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String path = <span class="hljs-string">&quot;G:\\java书籍及工具.zip&quot;</span>;<br>Files.readLines(<span class="hljs-keyword">new</span> File(path), Charsets.UTF_8);<br></code></pre></td></tr></table></figure><p>使用guava读取比较简单，一行代码就搞定了。</p><p>下面去jdk的bin目录找到javaVisualVM工具，然后双击运行即可。</p><p><img src="https://s3.ax1x.com/2021/01/15/swGinS.png"></p><p>从上图可以看到：</p><blockquote><ul><li>时间消耗：20秒</li><li>堆内存：最高2.5G</li><li>CPU消耗：最高50%</li></ul></blockquote><p>我们一个500M的文件，堆内存最高竟然2.5G，如果我们读取一个2G的文件，可能我们的电脑直接死机了就。</p><h3 id="方式2：Apache-Commons-IO普通方式"><a href="#方式2：Apache-Commons-IO普通方式" class="headerlink" title="方式2：Apache Commons IO普通方式"></a>方式2：Apache Commons IO普通方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String path = <span class="hljs-string">&quot;G:\\java书籍及工具.zip&quot;</span>;<br>FileUtils.readLines(<span class="hljs-keyword">new</span> File(path), Charsets.UTF_8);<br></code></pre></td></tr></table></figure><p>这种方式也比较简单，同样是一行代码。下面运行，也分析一波：</p><p><img src="https://s3.ax1x.com/2021/01/15/swGCX8.png"></p><p>从上图可以看到：</p><blockquote><ul><li>时间消耗：17秒</li><li>堆内存：最高2.5G</li><li>CPU消耗：最高50%，平稳运行25%左右</li></ul></blockquote><p>这种方式和上面那种基本上消耗差不多，肯定不是我想要的。</p><h3 id="方式3：java文件流"><a href="#方式3：java文件流" class="headerlink" title="方式3：java文件流"></a>方式3：java文件流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream inputStream = <span class="hljs-keyword">null</span>;<br>Scanner sc = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>     inputStream = <span class="hljs-keyword">new</span> FileInputStream(path);<br>     sc = <span class="hljs-keyword">new</span> Scanner(inputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>     <span class="hljs-keyword">while</span> (sc.hasNextLine()) &#123;<br>          String line = sc.nextLine();<br>          <span class="hljs-comment">//System.out.println(line);</span><br>     &#125;<br>     <span class="hljs-keyword">if</span> (sc.ioException() != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> sc.ioException();<br>     &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>     <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;<br>          inputStream.close();<br>     &#125;<br>     <span class="hljs-keyword">if</span> (sc != <span class="hljs-keyword">null</span>) &#123;<br>           sc.close();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式其实就是java中最常见的方式，然后我们运行分析一波：</p><p><img src="https://s3.ax1x.com/2021/01/15/swG96f.png"></p><p>从上图可以看到：</p><blockquote><ul><li>时间消耗：32秒，增加了一倍</li><li>堆内存：最高1G，少了一半</li><li>CPU消耗：平稳运行25%左右</li></ul></blockquote><p>这种方式确实很优秀，但是时间上开销更大。</p><h3 id="方式4：Apache-Commons-IO流"><a href="#方式4：Apache-Commons-IO流" class="headerlink" title="方式4：Apache Commons IO流"></a>方式4：Apache Commons IO流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">LineIterator it = FileUtils.lineIterator(<span class="hljs-keyword">new</span> File(path), <span class="hljs-string">&quot;UTF-8&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>         String line = it.nextLine();<br>      &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>     LineIterator.closeQuietly(it);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式代码看起来比较简单，所以直接运行一波吧：</p><p><img src="https://s3.ax1x.com/2021/01/15/swGp1P.png"></p><p>从上图可以看到：</p><blockquote><ul><li>时间消耗：16秒，最低</li><li>堆内存：最高650M，少了一半</li><li>CPU消耗：平稳运行25%左右</li></ul></blockquote><p>OK，就它了，牛。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过以上的分析，我们可以得出一个结论，如果我们想要读取一个大文件，选择了错误的方式，就有可能极大地占用我的内存和CPU，当文件特别大时，会造成意向不到的问题。</p><p>因此为了去解决这样的问题，有四种常见的读取大文件的方式。通过分析对比，发现，Apache Commons IO流是最高效的一种方式。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>碎知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
      <tag>java基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何通俗的理解CAS？（深入到操作系统分析）</title>
    <link href="/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/3%E3%80%81java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3CAS%EF%BC%9F%EF%BC%88%E6%B7%B1%E5%85%A5%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%89/"/>
    <url>/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/3%E3%80%81java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%97%E7%9A%84%E7%90%86%E8%A7%A3CAS%EF%BC%9F%EF%BC%88%E6%B7%B1%E5%85%A5%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>学习Java并发编程，CAS机制都是一个不得不掌握的知识点。这篇文章主要是从出现的原因再到原理进行一个解析。希望对你有所帮助。</p><h2 id="一、为什么需要CAS机制？"><a href="#一、为什么需要CAS机制？" class="headerlink" title="一、为什么需要CAS机制？"></a>一、为什么需要CAS机制？</h2><p>为什么需要CAS机制呢？我们先从一个错误现象谈起。我们经常使用volatile关键字修饰某一个变量，表明这个变量是全局共享的一个变量，同时具有了可见性和有序性。但是却没有原子性。比如说一个常见的操作a++。这个操作其实可以细分成三个步骤：</p><p><code>（1）从内存中读取a</code></p><p><code>（2）对a进行加1操作</code></p><p><code>（3）将a的值重新写入内存中</code></p><p>在单线程状态下这个操作没有一点问题，但是在多线程中就会出现各种各样的问题了。因为可能一个线程对<code>a进行了加1操作，还没来得及写入内存，其他的线程就读取了旧值。造成了线程的不安全现象</code>。如何去解决这个问题呢？最常见的方式就是使用<code>AtomicInteger</code>来修饰<code>a</code>。我们可以看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br><span class="hljs-comment">//使用AtomicInteger定义a</span><br><span class="hljs-keyword">static</span> AtomicInteger a = <span class="hljs-keyword">new</span> AtomicInteger();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Test3 test = <span class="hljs-keyword">new</span> Test3();<br>Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>threads[i] = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br><span class="hljs-comment">//使用getAndIncrement函数进行自增操作</span><br>System.out.println(a.incrementAndGet());<br>Thread.sleep(<span class="hljs-number">500</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;);<br>threads[i].start();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们使用AtomicInteger类并且调用了incrementAndGet方法来对a进行自增操作。这个incrementAndGet是如何实现的呢？我们可以看一下AtomicInteger的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Atomically increments by one the current value.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the updated value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们到这一步可以看到其实就是usafe调用了getAndAddInt的方法实现的，但是现在我们还看不出什么，我们再深入到源码中看看getAndAddInt方法又是如何实现的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;   <br><span class="hljs-keyword">int</span> var5;     <br><span class="hljs-keyword">do</span> &#123;          <br>var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);   <br>&#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));    <br><span class="hljs-keyword">return</span> var5;   <br>&#125;<br></code></pre></td></tr></table></figure><p>到了这一步就稍微有点眉目了，原来底层调用的是<code>compareAndSwapInt</code>方法，这个<code>compareAndSwapInt</code>方法其实就是CAS机制。因此如果我们想搞清楚<code>AtomicInteger</code>的原子操作是如何实现的，我们就必须要把CAS机制搞清楚，这也是为什么我们需要掌握CAS机制的原因。</p><h2 id="二、分析CAS"><a href="#二、分析CAS" class="headerlink" title="二、分析CAS"></a>二、分析CAS</h2><h3 id="1、基本含义"><a href="#1、基本含义" class="headerlink" title="1、基本含义"></a>1、基本含义</h3><p>CAS全拼又叫做<code>compareAndSwap</code>，从名字上的意思就知道是比较交换的意思。比较交换什么呢？</p><blockquote><p>过程是这样：它包含 3 个参数 CAS（V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后，CAS 返回当前V的真实值。</p></blockquote><p>我们举一个我之前举过的例子来说明这个过程：</p><blockquote><p><strong><code>比如说给你儿子订婚。你儿子就是内存位置，你原本以为你儿子是和杨贵妃在一起了，结果在订婚的时候发现儿子身边是西施。这时候该怎么办呢？你一气之下不做任何操作。如果儿子身边是你预想的杨贵妃，你一看很开心就给他们订婚了，也叫作执行操作。现在你应该明白了吧。</code></strong></p></blockquote><p>CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。所以CAS也叫作乐观锁，那什么是悲观锁呢？悲观锁就是我们之前赫赫有名的<code>synchronized</code>。悲观锁的思想你可以这样理解，一个线程想要去获得这个锁但是却获取不到，必须要别人释放了才可以。</p><h3 id="2、底层原理"><a href="#2、底层原理" class="headerlink" title="2、底层原理"></a>2、底层原理</h3><p>想要弄清楚其底层原理，深入到源码是最好的方式，在上面我们已经通过源码看到了其实就是<code>Usafe</code>的方法来完成的，在这个方法中使用了<code>compareAndSwapInt</code>这个CAS机制。因此，现在我们有必要进一步深入进去看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unsafe</span> </span>&#123;<br>    <span class="hljs-comment">// compareAndSwapInt 是 native 类型的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    Object o, </span></span><br><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">long</span> offset,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> expected,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> x</span></span><br><span class="hljs-function"><span class="hljs-params">    )</span></span>;<br>    <span class="hljs-comment">//剩余还有很多方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到这里面主要有四个参数，第一个参数就是我们操作的对象a，第二个参数是对象a的地址偏移量，第三个参数表示我们期待这个a是什么值，第四个参数表示的是a的实际值。</p><p>不过这里我们会发现这个<code>compareAndSwapInt</code>是一个<code>native</code>方法，也就是说再往下走就是C语言代码，如果我们保持好奇心，可以继续深入进去看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, <br>jobject obj, jlong offset, jint e, jint x))<br>  UnsafeWrapper(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);<br>  oop p = JNIHandles::resolve(obj);<br>  <span class="hljs-comment">// 根据偏移量valueOffset，计算 value 的地址</span><br>  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);<br>  <span class="hljs-comment">// 调用 Atomic 中的函数 cmpxchg来进行比较交换</span><br>  <span class="hljs-keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;<br>UNSAFE_END<br></code></pre></td></tr></table></figure><p>上面的代码我们解读一下：首先使用<code>jint</code>计算了<code>value</code>的地址，然后根据这个地址，使用了<code>Atomic</code>的<code>cmpxchg</code>方法进行比较交换。现在问题又抛给了这个<code>cmpxchg</code>，真实实现的是这个函数。我们再进一步深入看看，真相已经离我们不远了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">unsigned Atomic::cmpxchg(unsigned <span class="hljs-keyword">int</span> exchange_value,<br>                         <span class="hljs-keyword">volatile</span> unsigned <span class="hljs-keyword">int</span>* dest, <br>                         unsigned <span class="hljs-keyword">int</span> compare_value) &#123;<br>    <span class="hljs-keyword">assert</span>(sizeof(unsigned <span class="hljs-keyword">int</span>) == sizeof(jint), <span class="hljs-string">&quot;more work to do&quot;</span>);<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 根据操作系统类型调用不同平台下的重载函数，</span><br><span class="hljs-comment">     这个在预编译期间编译器会决定调用哪个平台下的重载函数</span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-keyword">return</span> (unsigned <span class="hljs-keyword">int</span>)Atomic::cmpxchg((jint)exchange_value, <br>                     (<span class="hljs-keyword">volatile</span> jint*)dest, (jint)compare_value);<br>&#125;<br></code></pre></td></tr></table></figure><p>皮球又一次被完美的踢走了，现在在不同的操作系统下会调用不同的<code>cmpxchg</code>重载函数，我现在用的是win10系统，所以我们看看这个平台下的实现，别着急再往下走走：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> jint <span class="hljs-title">Atomic::cmpxchg</span> <span class="hljs-params">(jint exchange_value, <span class="hljs-keyword">volatile</span> jint* dest, </span></span><br><span class="hljs-function"><span class="hljs-params">jint compare_value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> mp = os::is_MP();<br>  __asm &#123;<br>    mov edx, dest<br>    mov ecx, exchange_value<br>    mov eax, compare_value<br>    LOCK_IF_MP(mp)<br>    cmpxchg dword ptr [edx], ecx<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这块的代码就有点涉及到汇编指令相关的代码了，到这一步就彻底接近真相了，首先<code>三个move指令</code>表示的是将后面的值移动到前面的寄存器上。然后调用了<code>LOCK_IF_MP</code>和下面<code>cmpxchg</code>汇编指令进行了比较交换。现在我们不知道这个<code>LOCK_IF_MP</code>和<code>cmpxchg</code>是如何交换的，没关系我们最后再深入一下。</p><p><strong>真相来了，他来了，他真的来了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> jint <span class="hljs-title">Atomic::cmpxchg</span> <span class="hljs-params">(jint exchange_value, </span></span><br><span class="hljs-function"><span class="hljs-params">                             <span class="hljs-keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;<br>  <span class="hljs-comment">//1、 判断是否是多核 CPU</span><br>  <span class="hljs-keyword">int</span> mp = os::is_MP();<br>  __asm &#123;<br>    <span class="hljs-comment">//2、 将参数值放入寄存器中</span><br>    mov edx, dest   <br>    mov ecx, exchange_value<br>    mov eax, compare_value <br>    <span class="hljs-comment">//3、LOCK_IF_MP指令</span><br>    cmp mp, <span class="hljs-number">0</span><br>    <span class="hljs-comment">//4、 如果 mp = 0，表明线程运行在单核CPU环境下。此时 je 会跳转到 L0 标记处，直接执行 cmpxchg 指令</span><br>    je L0<br>    _emit <span class="hljs-number">0xF0</span><br><span class="hljs-comment">//5、这里真正实现了比较交换</span><br>L0:<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 比较并交换。简单解释一下下面这条指令，熟悉汇编的朋友可以略过下面的解释:</span><br><span class="hljs-comment">     *   cmpxchg: 即“比较并交换”指令</span><br><span class="hljs-comment">     *   dword: 全称是 double word 表示两个字，一共四个字节</span><br><span class="hljs-comment">     *   ptr: 全称是 pointer，与前面的 dword 连起来使用，表明访问的内存单元是一个双字单元 </span><br><span class="hljs-comment">     * 这一条指令的意思就是：</span><br><span class="hljs-comment">     将 eax 寄存器中的值（compare_value）与 [edx] 双字内存单元中的值进行对比，</span><br><span class="hljs-comment">     如果相同，则将 ecx 寄存器中的值（exchange_value）存入 [edx] 内存单元中。</span><br><span class="hljs-comment">     */</span><br>    cmpxchg dword ptr [edx], ecx<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这一步了，相信你应该理解了这个CAS真正实现的机制了吧，最终是由操作系统的汇编指令完成的。</p><h3 id="3、CAS机制的优缺点"><a href="#3、CAS机制的优缺点" class="headerlink" title="3、CAS机制的优缺点"></a><strong>3、CAS机制的优缺点</strong></h3><p><strong>（1）优点</strong></p><p>一开始在文中我们曾经提到过，<code>cas是一种乐观锁，而且是一种非阻塞的轻量级的乐观锁</code>，什么是非阻塞式的呢？其实就是一个线程想要获得锁，对方会给一个回应表示这个锁能不能获得。在资源竞争不激烈的情况下性能高，相比<code>synchronized</code>重量锁，<code>synchronized</code>会进行比较复杂的加锁，解锁和唤醒操作。</p><p><strong>（2）缺点</strong></p><p>缺点也是一个非常重要的知识点，因为涉及到了一个非常著名的问题，叫做<code>ABA</code>问题。假设一个变量 A ，修改为 B之后又修改为 A，CAS 的机制是无法察觉的，但实际上已经被修改过了。这就是<code>ABA</code>问题，</p><p>ABA问题会带来大量的问题，比如说数据不一致的问题等等。我们可以举一个例子来解释说明。</p><blockquote><p><strong>你有一瓶水放在桌子上，别人把这瓶水喝完了，然后重新倒上去。你再去喝的时候发现水还是跟之前一样，就误以为是刚刚那杯水。如果你知道了真相，那是别人用过了你还会再用嘛？举一个比较黄一点的例子，<code>女朋友被别人睡过之后又回来，还是之前的那个女朋友嘛</code>？</strong></p></blockquote><p>ABA可以有很多种方式来解决，在其他的文章已经给出。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux学不会？把这些命令敲一遍就通了（Linux命令大全）</title>
    <link href="/2021/01/25/%E4%B8%83%E3%80%81%E5%B7%A5%E5%85%B7/linux/Linux%E5%AD%A6%E4%B8%8D%E4%BC%9A%EF%BC%9F%E6%8A%8A%E8%BF%99%E4%BA%9B%E5%91%BD%E4%BB%A4%E6%95%B2%E4%B8%80%E9%81%8D%E5%B0%B1%E9%80%9A%E4%BA%86%EF%BC%88Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%EF%BC%89/"/>
    <url>/2021/01/25/%E4%B8%83%E3%80%81%E5%B7%A5%E5%85%B7/linux/Linux%E5%AD%A6%E4%B8%8D%E4%BC%9A%EF%BC%9F%E6%8A%8A%E8%BF%99%E4%BA%9B%E5%91%BD%E4%BB%A4%E6%95%B2%E4%B8%80%E9%81%8D%E5%B0%B1%E9%80%9A%E4%BA%86%EF%BC%88Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《手牵手一起学数据结构》专栏中</strong></p></blockquote><h2 id="最全Linux命令行大全"><a href="#最全Linux命令行大全" class="headerlink" title=" 最全Linux命令行大全"></a><font color="blue"> 最全Linux命令行大全</font></h2><blockquote><p>转载自：<a href="https://www.cnblogs.com/yjd_hycf_space/p/7730690.html">https://www.cnblogs.com/yjd_hycf_space/p/7730690.html</a></p></blockquote><p><font color="red"> 推荐一个网址，可以查询各种Linux命令：<a href="https://man.linuxde.net/">https://man.linuxde.net/</a></font></p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><strong>系统信息</strong></h3><p>arch 显示机器的处理器架构</p><p>uname -m 显示机器的处理器架构</p><p>uname -r 显示正在使用的内核版本 </p><p>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) </p><p>hdparm -i /dev/hda 罗列一个磁盘的架构特性 </p><p>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 </p><p>cat /proc/cpuinfo 显示CPU info的信息 </p><p>cat /proc/interrupts 显示中断 </p><p>cat /proc/meminfo 校验内存使用 </p><p>cat /proc/swaps 显示哪些swap被使用 </p><p>cat /proc/version 显示内核的版本 </p><p>cat /proc/net/dev 显示网络适配器及统计 </p><p>cat /proc/mounts 显示已加载的文件系统 </p><p>lspci -tv 罗列 PCI 设备 </p><p>lsusb -tv 显示 USB 设备 </p><p>date 显示系统日期 </p><p>cal 2007 显示2007年的日历表 </p><p>date 041217002007.00 设置日期和时间 - 月日时分年.秒 </p><p>clock -w 将时间修改保存到 BIOS </p><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a><strong>关机 (系统的关机、重启以及登出 )</strong></h3><p>shutdown -h now 关闭系统</p><p>init 0 关闭系统</p><p>telinit 0 关闭系统</p><p>shutdown -h hours:minutes &amp; 按预定时间关闭系统 </p><p>shutdown -c 取消按预定时间关闭系统 </p><p>shutdown -r now 重启</p><p>reboot 重启</p><p>logout 注销 </p><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a><strong>文件和目录</strong></h3><p>cd /home 进入 ‘/ home’ 目录’ </p><p>cd .. 返回上一级目录 </p><p>cd ../.. 返回上两级目录 </p><p>cd 进入个人的主目录 </p><p>cd ~user1 进入个人的主目录 </p><p>cd - 返回上次所在的目录 </p><p>pwd 显示工作路径 </p><p>ls 查看目录中的文件 </p><p>ls -F 查看目录中的文件 </p><p>ls -l 显示文件和目录的详细资料 </p><p>ls -a 显示隐藏文件 </p><p>ls <em>[0-9]</em> 显示包含数字的文件名和目录名 </p><p>tree 显示文件和目录由根目录开始的树形结构</p><p>lstree 显示文件和目录由根目录开始的树形结构</p><p>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’ </p><p>mkdir dir1 dir2 同时创建两个目录 </p><p>mkdir -p /tmp/dir1/dir2 创建一个目录树 </p><p>rm -f file1 删除一个叫做 ‘file1’ 的文件’ </p><p>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ </p><p>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 </p><p>rm -rf dir1 dir2 同时删除两个目录及它们的内容 </p><p>mv dir1 new_dir 重命名/移动 一个目录 </p><p>cp file1 file2 复制一个文件 </p><p>cp dir/* . 复制一个目录下的所有文件到当前工作目录 </p><p>cp -a /tmp/dir1 . 复制一个目录到当前工作目录 </p><p>cp -a dir1 dir2 复制一个目录 </p><p>ln -s file1 lnk1 创建一个指向文件或目录的软链接 </p><p>ln file1 lnk1 创建一个指向文件或目录的物理链接 </p><p>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) </p><p>file file1 outputs the mime type of the file as text </p><p>iconv -l 列出已知的编码 </p><p>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. </p><p>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a><strong>文件搜索</strong></h3><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录 </p><p>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录  </p><p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 </p><p>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 </p><p>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 </p><p>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 </p><p>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 </p><p>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令 </p><p>whereis halt 显示一个二进制文件、源码或man的位置 </p><p>which halt 显示一个二进制文件或可执行文件的完整路径 </p><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a><strong>挂载一个文件系统</strong></h3><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在  </p><p>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出 </p><p>fuser -km /mnt/hda2 当设备繁忙时强制卸载 </p><p>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 </p><p>mount /dev/fd0 /mnt/floppy 挂载一个软盘 </p><p>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom </p><p>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom </p><p>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom </p><p>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 </p><p>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统   </p><p>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 </p><p>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a><strong>磁盘空间</strong></h3><p>df -h 显示已经挂载的分区列表 </p><p>ls -lSr |more 以尺寸大小排列文件和目录 </p><p>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’ </p><p>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 </p><p>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) </p><p>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a><strong>用户和群组</strong></h3><p>groupadd group_name 创建一个新用户组 </p><p>groupdel group_name 删除一个用户组 </p><p>groupmod -n new_group_name old_group_name 重命名一个用户组 </p><p>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户 </p><p>useradd user1 创建一个新用户 </p><p>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录) </p><p>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 </p><p>passwd 修改口令 </p><p>passwd user1 修改一个用户的口令 (只允许root执行) </p><p>chage -E 2005-12-31 user1 设置用户口令的失效期限 </p><p>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户 </p><p>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组 </p><p>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p><h3 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong></h3><p>ls -lh 显示权限 </p><p>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 </p><p>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 </p><p>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 </p><p>chown user1 file1 改变一个文件的所有人属性 </p><p>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 </p><p>chgrp group1 file1 改变文件的群组 </p><p>chown user1:group1 file1 改变一个文件的所有人和群组属性 </p><p>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 </p><p>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 </p><p>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 </p><p>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 </p><p>chmod g-s /home/public 禁用一个目录的 SGID 位 </p><p>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 </p><p>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p><h3 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong></h3><p>chattr +a file1 只允许以追加方式读写文件 </p><p>chattr +c file1 允许这个文件能被内核自动压缩/解压 </p><p>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 </p><p>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 </p><p>chattr +s file1 允许一个文件被安全地删除 </p><p>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 </p><p>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 </p><p>lsattr 显示特殊的属性 </p><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a><strong>打包和压缩文件</strong></h3><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件 </p><p>bzip2 file1 压缩一个叫做 ‘file1’ 的文件 </p><p>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件 </p><p>gzip file1 压缩一个叫做 ‘file1’的文件 </p><p>gzip -9 file1 最大程度压缩 </p><p>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包 </p><p>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’ </p><p>unrar x file1.rar 解压rar包 </p><p>tar -cvf archive.tar file1 创建一个非压缩的 tarball </p><p>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件 </p><p>tar -tf archive.tar 显示一个包中的内容 </p><p>tar -xvf archive.tar 释放一个包 </p><p>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 </p><p>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 </p><p>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 </p><p>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 </p><p>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 </p><p>zip file1.zip file1 创建一个zip格式的压缩包 </p><p>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 </p><p>unzip file1.zip 解压一个zip格式压缩包 </p><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong></h3><p>rpm -ivh package.rpm 安装一个rpm包 </p><p>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 </p><p>rpm -U package.rpm 更新一个rpm包但不改变其配置文件 </p><p>rpm -F package.rpm 更新一个确定已经安装的rpm包 </p><p>rpm -e package_name.rpm 删除一个rpm包 </p><p>rpm -qa 显示系统中所有已经安装的rpm包 </p><p>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包 </p><p>rpm -qi package_name 获取一个已安装包的特殊信息 </p><p>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包 </p><p>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 </p><p>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 </p><p>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表 </p><p>rpm -q package_name –whatprovides 显示一个rpm包所占的体积 </p><p>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l </p><p>rpm -q package_name –changelog 显示一个rpm包的修改历史 </p><p>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 </p><p>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 </p><p>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 </p><p>rpm –checksig package.rpm 确认一个rpm包的完整性 </p><p>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 </p><p>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 </p><p>rpm -Va 检查系统中所有已安装的rpm包- 小心使用 </p><p>rpm -Vp package.rpm 确认一个rpm包还未安装 </p><p>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件  </p><p>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包 </p><p>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a><strong>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</strong></h3><p>yum install package_name 下载并安装一个rpm包 </p><p>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 </p><p>yum update package_name.rpm 更新当前系统中所有安装的rpm包 </p><p>yum update package_name 更新一个rpm包 </p><p>yum remove package_name 删除一个rpm包 </p><p>yum list 列出当前系统中安装的所有包 </p><p>yum search package_name 在rpm仓库中搜寻软件包 </p><p>yum clean packages 清理rpm缓存删除下载的包 </p><p>yum clean headers 删除所有头文件 </p><p>yum clean all 删除所有缓存的包和头文件 </p><h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a><strong>DEB 包 (Debian, Ubuntu 以及类似系统)</strong></h3><p>dpkg -i package.deb 安装/更新一个 deb 包 </p><p>dpkg -r package_name 从系统删除一个 deb 包 </p><p>dpkg -l 显示系统中所有已经安装的 deb 包 </p><p>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包 </p><p>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 </p><p>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 </p><p>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表 </p><p>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 </p><h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a><strong>APT 软件工具 (Debian, Ubuntu 以及类似系统)</strong></h3><p>apt-get install package_name 安装/更新一个 deb 包 </p><p>apt-cdrom install package_name 从光盘安装/更新一个 deb 包 </p><p>apt-get update 升级列表中的软件包 </p><p>apt-get upgrade 升级所有已安装的软件 </p><p>apt-get remove package_name 从系统删除一个deb包 </p><p>apt-get check 确认依赖的软件仓库正确 </p><p>apt-get clean 从下载的软件包中清理缓存 </p><p>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 </p><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a><strong>查看文件内容</strong></h3><p>cat file1 从第一个字节开始正向查看文件的内容 </p><p>tac file1 从最后一行开始反向查看一个文件的内容 </p><p>more file1 查看一个长文件的内容 </p><p>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作 </p><p>head -2 file1 查看一个文件的前两行 </p><p>tail -2 file1 查看一个文件的最后两行 </p><p>tail -f /var/log/messages 实时查看被添加到一个文件中的内容 </p><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a><strong>文本处理</strong></h3><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text </p><p>manipulation using PIPE, STDIN and STDOUT </p><p>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 </p><p>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 </p><p>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug” </p><p>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇 </p><p>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行 </p><p>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug” </p><p>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2” </p><p>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行 </p><p>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行 </p><p>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容 </p><p>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行 </p><p>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行 </p><p>sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符  </p><p>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部</p><p>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容 </p><p>sed -n ‘5p;5q’ example.txt 查看第5行 </p><p>sed -e ‘s/00*/0/g’ example.txt 用单个零替换多个零 </p><p>cat -n file1 标示文件的行数 </p><p>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行 </p><p>echo a b c | awk ‘{print $1}’ 查看一行第一栏 </p><p>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏 </p><p>paste file1 file2 合并两个文件或两栏的内容 </p><p>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分 </p><p>sort file1 file2 排序两个文件的内容 </p><p>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) </p><p>sort file1 file2 | uniq -u 删除交集，留下其他的行 </p><p>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) </p><p>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容 </p><p>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容 </p><p>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </p><h3 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a><strong>字符设置和文件格式转换</strong></h3><p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX </p><p>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS </p><p>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html </p><p>recode -l | more 显示所有允许的转换格式 </p><h3 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a><strong>文件系统分析</strong></h3><p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 </p><p>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 </p><p>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 </p><p>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 </p><p>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 </p><p>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 </p><p>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 </p><p>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </p><p>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 </p><h3 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a><strong>初始化一个文件系统</strong></h3><p>mkfs /dev/hda1 在hda1分区创建一个文件系统 </p><p>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 </p><p>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 </p><p>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 </p><p>fdformat -n /dev/fd0 格式化一个软盘 </p><p>mkswap /dev/hda3 创建一个swap文件系统 </p><h3 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a><strong>SWAP文件系统</strong></h3><p>mkswap /dev/hda3 创建一个swap文件系统 </p><p>swapon /dev/hda3 启用一个新的swap文件系统 </p><p>swapon /dev/hda2 /dev/hdb3 启用两个swap分区 </p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a><strong>备份</strong></h3><p>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份 </p><p>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份 </p><p>restore -if /tmp/home0.bak 还原一个交互式备份 </p><p>rsync -rogpav –delete /home /tmp 同步两边的目录 </p><p>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync </p><p>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 </p><p>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 </p><p>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作 </p><p>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 </p><p>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作 </p><p>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容 </p><p>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录 </p><p>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 </p><p>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录   </p><p>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包 </p><p>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 </p><p>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 </p><h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a><strong>光盘</strong></h3><p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 </p><p>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 </p><p>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 </p><p>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 </p><p>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 </p><p>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 </p><p>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 </p><p>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 </p><p>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3） </p><p>cdrecord –scanbus 扫描总线以识别scsi通道 </p><p>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD </p><h3 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a><strong>网络 - （以太网和WIFI无线</strong>）</h3><ul><li>ifconfig eth0 显示一个以太网卡的配置 </li><li>ifup eth0 启用一个 ‘eth0’ 网络设备 </li><li>ifdown eth0 禁用一个 ‘eth0’ 网络设备 </li></ul><p>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 </p><p>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing) </p><p>dhclient eth0 以dhcp模式启用 ‘eth0’ </p><p>route -n show routing table </p><p>route add -net 0/0 gw IP_Gateway configura default gateway </p><p>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’ </p><p>route del 0/0 gw IP_gateway remove static route </p><p>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing </p><p>hostname show hostname of system </p><p>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa</p><p>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa</p><p>ip link show show link status of all interfaces </p><p>mii-tool eth0 show link status of ‘eth0’ </p><p>ethtool eth0 show statistics of network card ‘eth0’ </p><p>netstat -tup show all active network connections and their PID </p><p>netstat -tupl show all network services listening on the system and their PID </p><p>tcpdump tcp port 80 show all HTTP traffic </p><p>iwlist scan show wireless networks </p><p>iwconfig eth1 show configuration of a wireless network card </p><p>hostname show hostname </p><p>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa </p><p>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa </p><p>whois <a href="http://www.example.com/">www.example.com</a> lookup on Whois database </p><h3 id="JPS工具"><a href="#JPS工具" class="headerlink" title="JPS工具"></a><strong>JPS工具</strong></h3><p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p><p>​    我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。</p><p>​     <strong>使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。</strong></p><p><strong>jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.</strong></p><blockquote><p>$&gt; <strong>jps</strong><br>23991 Jps<br>23789 BossMain<br>23651 Resin</p></blockquote><p>比较常用的参数：</p><blockquote><p><strong>-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</strong><br>$&gt;  <strong>jps -q</strong><br>28680<br>23789<br>23651</p></blockquote><p><strong>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</strong></p><blockquote><p>$&gt; <strong>jps -m</strong><br>28715 Jps -m<br>23789 BossMain<br>23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log</p></blockquote><p><strong>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</strong></p><blockquote><p>$&gt; <strong>jps -l</strong><br>28729 sun.tools.jps.Jps<br>23789 com.asiainfo.aimc.bossbi.BossMain<br>23651 com.caucho.server.resin.Resin</p></blockquote><p><strong>-v 输出传递给JVM的参数</strong></p><blockquote><p>$&gt; <strong>jps -v</strong><br>23789 BossMain<br>28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd</p><p>k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m<br>23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -</p><p>Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl</p></blockquote><p><strong>sudo jps看到的进程数量最全</strong></p><p><strong>jps 192.168.0.77</strong></p><p><strong>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099</strong></p><p><strong>（前提是远程服务器提供jstatd服务）</strong></p><p><strong>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。</strong></p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乐观锁这么重要，如何用java两步实现一个？</title>
    <link href="/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/3%E3%80%81java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B9%90%E8%A7%82%E9%94%81%E8%BF%99%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8java%E4%B8%A4%E6%AD%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%EF%BC%9F/"/>
    <url>/2021/01/25/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/3%E3%80%81java%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E4%B9%90%E8%A7%82%E9%94%81%E8%BF%99%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%8C%E5%A6%82%E4%BD%95%E7%94%A8java%E4%B8%A4%E6%AD%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>java多线程中的锁分类多种多样，其中有一种主要的分类方式就是乐观和悲观进行划分的。这篇文章主要介绍如何自己手写一个乐观锁代码。不过文章为了保证完整性，会从基础开始介绍。</p><h2 id="一、乐观锁概念"><a href="#一、乐观锁概念" class="headerlink" title="一、乐观锁概念"></a>一、乐观锁概念</h2><p>说是写乐观锁的概念，但是通常乐观锁和悲观锁的概念都要一块写。对比着来才更有意义。</p><h3 id="1、悲观锁概念"><a href="#1、悲观锁概念" class="headerlink" title="1、悲观锁概念"></a><strong>1、悲观锁概念</strong></h3><p><strong>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞，直到它拿到锁。</strong></p><p>比如<code>synchronized</code>就是一个<code>悲观锁</code>，当一个方法使用了synchronized修饰时，其他的线程想要拿到这个方法就需要<code>等到别的线程释放</code>。</p><p>数据库里面也用到了这种悲观锁的机制。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。这样其他的线程就不能同步操作，必须要等到他释放才可以。</p><h3 id="2、乐观锁概念"><a href="#2、乐观锁概念" class="headerlink" title="2、乐观锁概念"></a><strong>2、乐观锁概念</strong></h3><p><strong>乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，只在更新的时候会判断一下<code>在此期间</code>别人有没有去更新这个数据。</strong></p><blockquote><p>注意<code>“在此期间”</code>的含义是<code>拿到数据到更新数据</code>的这段时间。因为没有加锁，所以别的线程可能会更改。还有一点那就是乐观锁其实是不加锁的。</p></blockquote><p>了解了概念之后，再看个例子：java中的<code>Atomic</code>包下的类就是使用了乐观锁机制。我们挑出来一个看看官方是如何实现的，然后按照这样的实现机制我们自己就可以实现。</p><h3 id="3、乐观锁实现案例"><a href="#3、乐观锁实现案例" class="headerlink" title="3、乐观锁实现案例"></a><strong>3、乐观锁实现案例</strong></h3><p>java并发机制中主要有三个特性需要我们去考虑，<code>原子性、可见性和有序性</code>。AtomicInteger的作用就是为了保证原子性。就是用这个演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-comment">//一个变量a</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">5</span>];<br>        <span class="hljs-comment">//定义5个线程，每个线程加10</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                        System.out.println(a++);<br>                        Thread.sleep(<span class="hljs-number">500</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            threads[i].start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子很简单：我们定义了一个<code>变量a，初始值是0</code>，然后使用<code>5个线程去增加</code>，<code>每个线程增加10</code>，按道理来说5个线程一共增加了50，<code>运行一下不到50</code>，原因就在于里面那个加一操作：<code>a++</code>;</p><p>对于a++的操作，其实可以分解为3个步骤。</p><p><code>**（1）从主存中读取a的值**</code></p><p><code>**（2）对a进行加1操作**</code></p><p><code>**（3）把a重新刷新到主存**</code></p><p><code>线程1把a进行了加1操作</code>，但是还<code>没来得及重刷入到主存</code>，<code>线程2就读取了</code>，此时线程2读取的肯定是<code>没来及刷入内存的旧值</code>。这才造成了错误。解决办法就可以使用<code>AtomicInteger</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<br>    <span class="hljs-comment">//使用AtomicInteger定义a</span><br>    <span class="hljs-keyword">static</span> AtomicInteger a = <span class="hljs-keyword">new</span> AtomicInteger();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test3 test = <span class="hljs-keyword">new</span> Test3();<br>        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">5</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                        <span class="hljs-comment">//使用getAndIncrement函数进行自增操作</span><br>                        System.out.println(a.incrementAndGet());        <br>                        Thread.sleep(<span class="hljs-number">500</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>            threads[i].start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们使用<code>AtomicInteger</code>定义a，然后使用<code>incrementAndGet</code>进行自增操作，最后的结果就总是<code>50</code>了。我们来分析一下：</p><h3 id="4、乐观锁案例分析"><a href="#4、乐观锁案例分析" class="headerlink" title="4、乐观锁案例分析"></a><strong>4、乐观锁案例分析</strong></h3><p>想要找出来答案我们还要从<code>AtomicInteger</code>的incrementAndGet方法说起。因为这个方法实现了锁一样的功能。这里使用的是jdk1.8的版本，不同的版本会有出入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Atomically increments by one the current value.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> the updated value</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以看到自增操作主要是使用了<code>unsafe</code>的<code>getAndAddInt</code>方法。因为不是专门介绍AtomicInteger，所以不会对源码进行详细的分析。</p><ul><li><p>Unsafe：Unsafe是位于sun.misc包下的一个类，Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力。也就是说我们直接操作了内存空间进行了加1操作。</p></li><li><p>unsafe.getAndAddInt：其内部又调用了Unsafe.compareAndSwapInt方法。这个机制叫做CAS机制，</p></li></ul><p><code>**CAS 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。**</code></p><p>我们使用一个例子来解释相信你会更加的清楚。</p><blockquote><p>意思是，你老爸想让你娶张三，等到真正结婚的那天，如果你老爸预想的新娘子(张三)和你真实取得新娘子一样，就给你办婚礼，否则不办婚礼。</p></blockquote><p>但是这样的CAS机制会带来一个比较常见的问题。那就是ABA问题，<code>你在桌子上放了100元，回来还是100，但是在你走的那段时间，别人已经拿走了100块，后来又还回来了</code>。这就是ABA问题。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/N8scgexEBuIT9PkeY64z7u5ODa0SVakiaSV2jCACpib7bpp2pI0ykBj82W5O1uDe3DKQNIRKjDPO9NHhh1PF0Pkw/640?wx_fmt=png" alt="img"></p><blockquote><p>ABA问题看似没问题，其实在金融行业会造成隐患，你会容忍别人拿走你的100万再还回来，而你却毫不知情嘛？</p></blockquote><p>解决ABA问题的思路就是给数据加上版本号。</p><p><strong>5、乐观锁思想</strong></p><p>OK，上面说了这么多，其实就是想说一句话那就是乐观锁可以由CAS机制+版本机制来实现。</p><ul><li><p>CAS机制：当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败。CAS 有效地说明了“ 我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可“。</p></li><li><p>版本机制：CAS机制保证了在更新数据的时候没有被修改为其他数据的同步机制，版本机制就保证了没有被修改过的同步机制（意思是上面的ABA问题）。</p></li></ul><p>基于这个思想我们就可以实现一个乐观锁。下面我们写一下代码。这个代码在我自己电脑上亲测通过。</p><h2 id="二、实现一个乐观锁"><a href="#二、实现一个乐观锁" class="headerlink" title="二、实现一个乐观锁"></a>二、实现一个乐观锁</h2><h3 id="第一步：定义我们要操作的数据"><a href="#第一步：定义我们要操作的数据" class="headerlink" title="第一步：定义我们要操作的数据"></a><strong>第一步：定义我们要操作的数据</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span> </span>&#123;<br>    <span class="hljs-comment">//数据版本号</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> version = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//真实数据</span><br>    <span class="hljs-keyword">static</span> String data = <span class="hljs-string">&quot;java的架构师技术栈&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVersion</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> version;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateVersion</span><span class="hljs-params">()</span></span>&#123;<br>        version = version + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第二步：定义一个乐观锁"><a href="#第二步：定义一个乐观锁" class="headerlink" title="第二步：定义一个乐观锁"></a><strong>第二步：定义一个乐观锁</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> version;<br>    <span class="hljs-keyword">public</span> String data;<br>    <span class="hljs-comment">//构造方法和getter、setter方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 1.读数据</span><br>        String text = Data.data;<br>        println(<span class="hljs-string">&quot;线程&quot;</span>+ getName() + <span class="hljs-string">&quot;，获得的数据版本号为：&quot;</span> + Data.getVersion());<br>        println(<span class="hljs-string">&quot;线程&quot;</span>+ getName() + <span class="hljs-string">&quot;，预期的数据版本号为：&quot;</span> + getVersion());<br>        System.out.println(<span class="hljs-string">&quot;线程&quot;</span>+ getName()+<span class="hljs-string">&quot;读数据完成=========data = &quot;</span> + text);<br>        <span class="hljs-comment">// 2.写数据：预期的版本号和数据版本号一致，那就更新</span><br>        <span class="hljs-keyword">if</span>(Data.getVersion() == getVersion())&#123;<br>            println(<span class="hljs-string">&quot;线程&quot;</span> + getName() + <span class="hljs-string">&quot;，版本号为：&quot;</span> + version + <span class="hljs-string">&quot;，正在操作数据&quot;</span>);<br>            <span class="hljs-keyword">synchronized</span>(OptimThread.class)&#123;<br>                <span class="hljs-keyword">if</span>(Data.getVersion() == <span class="hljs-keyword">this</span>.version)&#123;<br>                    Data.data = <span class="hljs-keyword">this</span>.data;<br>                    Data.updateVersion();<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + getName() + <span class="hljs-string">&quot;写数据完成=========data = &quot;</span> + <span class="hljs-keyword">this</span>.data);<br>                    <span class="hljs-keyword">return</span> ;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-comment">// 3. 版本号不正确的线程，需要重新读取，重新执行</span><br>            println(<span class="hljs-string">&quot;线程&quot;</span>+ getName() + <span class="hljs-string">&quot;，获得的数据版本号为：&quot;</span> + Data.getVersion());<br>            println(<span class="hljs-string">&quot;线程&quot;</span>+ getName() + <span class="hljs-string">&quot;，预期的版本号为：&quot;</span> + getVersion());<br>            System.err.println(<span class="hljs-string">&quot;线程&quot;</span>+ getName() + <span class="hljs-string">&quot;，需要重新执行。==============&quot;</span>);<br>        &#125;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三步：测试"><a href="#第三步：测试" class="headerlink" title="第三步：测试"></a><strong>第三步：测试</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> OptimThread(String.valueOf(i), <span class="hljs-number">1</span>, <span class="hljs-string">&quot;fdd&quot;</span>).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了两个线程，然后进行读写操作</p><h3 id="第四步：输出结果"><a href="#第四步：输出结果" class="headerlink" title="第四步：输出结果"></a><strong>第四步：输出结果</strong></h3><p>这个结果可以看到在读数据的时候只要发现没有变化即可，但是更新数据的时候要判断当前的版本号和预期的版本号是否一致，如果一致那就更新，如果不一致，那就说明更新失败。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/N8scgexEBuIT9PkeY64z7u5ODa0SVakiaULE1a4noYD37YAnBWyA7uNLoMcX2jRf8jCTQwLTvscswWE3iaZEdFdg/640?wx_fmt=png" alt="img"></p><p>OK，今天的文章先写到这。如果问题还请批评指正。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>java多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么说不推荐使用finalize方法</title>
    <link href="/2021/01/14/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8finalize%E6%96%B9%E6%B3%95/"/>
    <url>/2021/01/14/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8finalize%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>这个问题是我在刷牛客面经的时候遇到的，还特地整理在了我的常规面试题文档中，所以这道题主要考察的就是finalize方法的影响。</p><p>java提供了一个finalize方法，可以帮助我们进行资源释放，类似于C++中的析构函数。但是目前普遍的认识是不要使用，为什么呢？就是因为对java虚拟机的垃圾回收有影响。这篇文章对其进行一个说明。</p><h2 id="一、为什么有影响"><a href="#一、为什么有影响" class="headerlink" title="一、为什么有影响"></a>一、为什么有影响</h2><p>我们都知道一个对象GCRoot不可达，java虚拟机就认为是垃圾对象，就会进行垃圾回收，但是如果这个对象包含了finalize函数，性质就不一样了。怎么不一样了呢？</p><p>java虚拟机在进行垃圾回收的时候，一看到这个对象类含有finalize函数，就把这个函数交给FinalizerThread处理，而包含了这个finalize的对象就会被添加到FinalizerThread的执行队列，并使用一个链表，把这些包含了finalize的对象串起来。</p><p><img src="https://s3.ax1x.com/2021/01/12/sGzl1s.png"></p><p>他的影响在于只要finalize没有执行，那么这些对象就会一直存在堆区，不过这里只是4个包含了finalize的对象，影响不是那么大，如果有一万个或者是十万个呢？这就影响大了。</p><p>finalize的原理其实很简单，在这里简要的梳理一下：</p><p>（1）对象在初始化的过程中会判断是否重写了finalize，方法是判断两个字段标志has_finalizer_flag和RegisterFinalizersAtInit。</p><p>（2）如果重写了finalize，那就把当前对象注册到FinalizerThread的ReferenceQueue队列中。注册之后的对象就叫做Finalizer。方法是调用register_finalizer函数。此时java虚拟机一看当前有这个对象的引用，于是就不进行垃圾回收了。</p><p>（3）对象开始被调用，FinalizerThread线程负责从ReferenceQueue队列中获取Finalizer对象。开始执行finalize方法，在执行之前，这个对象一直在堆中。</p><p>（4）对象执行完毕之后，将这个Finalizer对象从队列中移除，java虚拟机一看对象没有引用了，就进行垃圾回收了。</p><p>这就是整个过程。不过在这里我们主要看的是finalize方法对垃圾回收的影响，其实就是在第三步，也就是这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。</p><blockquote><p><strong>注意：这里其实就是一道面试题，我在看牛客网上的面经时，看到有人被问到过。也就是GCRoot不可达的对象，会立刻被垃圾回收吗？</strong></p></blockquote><p>我们使用一个案例来分析一波：</p><h2 id="二、案例演示"><a href="#二、案例演示" class="headerlink" title="二、案例演示"></a>二、案例演示</h2><p>我们创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinalizer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fdd</span> </span>&#123;<br>    <span class="hljs-comment">//分配1M</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;finalize被执行&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        Fdd fdd = <span class="hljs-keyword">new</span> Fdd(); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在创建了类，我们设置一下参数。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 最大堆内存</span><br><span class="hljs-meta">-Xmx5m</span> <span class="hljs-string"></span><br><span class="hljs-comment"># 最小堆内存</span><br><span class="hljs-meta">-Xms5m</span>  <span class="hljs-string"></span><br><span class="hljs-comment"># 堆内存溢出错误打印</span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">+HeapDumpOnOutOfMemoryError </span><br><span class="hljs-comment"># 把堆相关信息保存在下列路径</span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">HeapDumpPath=F:/a.dump</span><br></code></pre></td></tr></table></figure><p>在main方法中，创建了1000个Fdd对象，如果不执行finalize方法，那么因为没有调用所以会进行垃圾回收，此时不断我们创建多少个，都不会出现任何问题。但是如果存在finalize方法，就不一样了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">java.lang.OutOfMemoryError</span>: <span class="hljs-string">Java heap space</span><br><span class="hljs-attr">Dumping</span> <span class="hljs-string">heap to F:/a.dump ...</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">Unable</span> <span class="hljs-string">to create F:/a.dump: File exists</span><br><span class="hljs-attr">Exception</span> <span class="hljs-string">in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="hljs-attr">at</span> <span class="hljs-string">com.fdd.chapter2.TestFinalizer$Fdd.&lt;init&gt;(TestFinalizer.java:6)</span><br><span class="hljs-attr">at</span> <span class="hljs-string">com.fdd.chapter2.TestFinalizer.main(TestFinalizer.java:14)</span><br></code></pre></td></tr></table></figure><p>我们看到每个对象都会执行finalize，在执行之前的这段时间一直会在堆区，执行完了就会被清理，所以你看到这里执行了不少于5次的finalize方法。但是对象一旦超出了我们设置的5M，就会出现内存溢出。一句话总结就是出现了对象堆积。现在使用MAT工具来分析一下。</p><blockquote><p>Mat工具是一个插件，也可以自己下载一个。下载完成之后打开我们刚刚生成的a.dump即可。</p></blockquote><p>下面这张图就是分析的结果：</p><p><img src="https://s3.ax1x.com/2021/01/12/sGzQpj.png"></p><p>a这块的内容就是Finalizer，也就是我们的Fdd对象，b包含的比较多，乱七八糟的剩余信息。当然你也可以查看一些其他的信息。都在MAT工具上。还有一些正在执行的finalizer和准备执行的。</p><p><img src="https://s3.ax1x.com/2021/01/12/sGz1cn.png"></p><p>OK，一些其他的信息就不再展示了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一个GCRoot不可达的对象，不会立刻被垃圾回收，首先还会判断是否包含了finalize方法，如果有那就先执行finalize方法，如果这样的对象比较多，那么这部分对象及时GCRoot不可达，变得没用了，也会留在内存中，影响程序的效率。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中如何压缩集合</title>
    <link href="/2021/01/14/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/1%E3%80%81java%E9%9B%86%E5%90%88/java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9%E9%9B%86%E5%90%88/"/>
    <url>/2021/01/14/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/1%E3%80%81java%E9%9B%86%E5%90%88/java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个问题算是开发当中偶尔会遇到的一个小问题，比如如何将两个集合压缩成为一个逻辑集合。</p><p>如果你不理解，我们可以看一个简单的例子，去说明什么是压缩集合。本文文章不长，但是还算是比较实用的小技巧。主要内容来源于国外小哥Baeldung的博客：下面给出个地址</p><p><a href="https://www.baeldung.com/java-collections-zip">https://www.baeldung.com/java-collections-zip</a></p><blockquote><p><strong>这位大佬虽然写的很详细，但是有一些细节小问题，我在此基础之上，实地验证了一遍，发现有几个坑，不过已经填完了。</strong></p></blockquote><h3 id="案例解释什么是压缩集合"><a href="#案例解释什么是压缩集合" class="headerlink" title="案例解释什么是压缩集合"></a>案例解释什么是压缩集合</h3><p>现在有两个集合：<code>names和ages</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>List&lt;Integer&gt; ages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">27</span>));<br></code></pre></td></tr></table></figure><p>压缩完之后我们遍历压缩对象变成了下面这种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">张三:<span class="hljs-number">24</span><br>李四:<span class="hljs-number">25</span><br>王五:<span class="hljs-number">27</span><br></code></pre></td></tr></table></figure><p>也就是name:age的键值对的形式，当然，如果我们的集合比较多，我们还可以压缩更多的集合。比如一个人的各种信息，<code>id:name:age</code>等等。</p><p>OK，知道了什么是压缩，下面不回长篇大论，直接给出压缩的几种形式，</p><h2 id="压缩集合的几种方式"><a href="#压缩集合的几种方式" class="headerlink" title="压缩集合的几种方式"></a>压缩集合的几种方式</h2><h3 id="方式一：Java-8的IntStream"><a href="#方式一：Java-8的IntStream" class="headerlink" title="方式一：Java 8的IntStream"></a>方式一：Java 8的IntStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>List&lt;Integer&gt; ages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">27</span>));<br><span class="hljs-comment">//方式一：java8的IntSream</span><br>Stream&lt;String&gt; stream = IntStream<br>      .range(<span class="hljs-number">0</span>, Math.min(names.size(), ages.size()))<br>      .mapToObj(i -&gt; names.get(i) + <span class="hljs-string">&quot;:&quot;</span> + ages.get(i));<br><span class="hljs-comment">//遍历输出</span><br>stream.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>这种方式比较简单，获取两个集合的流，然后转化为对象。java8可以直接使用。</p><h3 id="方式二：Guava-Streams"><a href="#方式二：Guava-Streams" class="headerlink" title="方式二：Guava Streams"></a>方式二：Guava Streams</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>List&lt;Integer&gt; ages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">27</span>));<br><br><span class="hljs-comment">//方式二：guava</span><br><span class="hljs-comment">//第一种</span><br>Streams.forEachPair(<br>       Stream.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>),<br>       Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<br>       (name, age) -&gt; System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + age));<br><span class="hljs-comment">//第二种：</span><br>Stream&lt;String&gt; stream2 = Streams.zip(names.stream(), ages.stream(), <br>        (name, age) -&gt; name + <span class="hljs-string">&quot;:&quot;</span> + age);<br>stream2.forEach(System.out::println);<br><span class="hljs-comment">//第三种：</span><br>Stream&lt;String&gt; stream3 = Streams.mapWithIndex(<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>),<br>        (str, index) -&gt; str + <span class="hljs-string">&quot;:&quot;</span> + index);<br>stream3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>以上是几种实现的方式，这位大佬给出了一种，我又去官网找了其他几种。另外使用guava的时候，版本要求21以上。我们在pom文件添加以下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里注意使用最新版的就可以。其他的也许会报错。我试了版本21的，也出错。</p><h3 id="方式二：Using-jOOλ-jOOL"><a href="#方式二：Using-jOOλ-jOOL" class="headerlink" title="方式二：Using jOOλ (jOOL)"></a>方式二：Using <em>jOOλ</em> <em>(jOOL)</em></h3><p>jOOL还在Java 8 Lambda上提供了一些有趣的新功能，并且通过对Tuple1到Tuple16的支持，zip操作变得更加有趣:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式三：jool</span><br><span class="hljs-comment">//第一种</span><br>Seq&lt;Tuple2&lt;String,Integer&gt;&gt; s1 = Seq.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>)<br>    .zip(Seq.of(<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">27</span>));<br><span class="hljs-comment">//第二种</span><br>Seq&lt;String&gt; s2 = Seq.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    .zip(Seq.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>), (x, y) -&gt; x + <span class="hljs-string">&quot;:&quot;</span> + y);<br><span class="hljs-comment">//第三种</span><br>Seq&lt;Tuple2&lt;String,Long&gt;&gt; s3 = Seq.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>).zipWithIndex();<br>s1.forEach(System.out::println);<br>s2.forEach(System.out::println);<br>s3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>Seq结果是一个压缩元组，我们可以看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(tuple(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>), tuple(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>), tuple(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>))<br></code></pre></td></tr></table></figure><p>这种方式也是需要添加依赖的。在pom文件添加如下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jooq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jool-java-8<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ok，还有很多，基本思想都是切成流，再合并。这个直接用java实现也可以。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>“zip”操作与标准的“concat”或“merge”稍有不同。“concat”或“merge”操作将简单地在现有集合的末尾添加新集合，而“zip”操作将从每个集合中获取一个元素并将它们组合起来。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCRoot不可达的对象，会立刻被垃圾回收吗？</title>
    <link href="/2021/01/12/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/GCRoot%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BC%9A%E7%AB%8B%E5%88%BB%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F/"/>
    <url>/2021/01/12/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/GCRoot%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BC%9A%E7%AB%8B%E5%88%BB%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《JVM专题》中</strong></p></blockquote><p>这个问题是我在刷牛客面经的时候遇到的，还特地整理在了我的常规面试题文档中，所以这道题主要考察的就是finalize方法的影响。</p><p>java提供了一个finalize方法，可以帮助我们进行资源释放，类似于C++中的析构函数。但是目前普遍的认识是不要使用，为什么呢？就是因为对java虚拟机的垃圾回收有影响。这篇文章对其进行一个说明。</p><h2 id="一、为什么有影响"><a href="#一、为什么有影响" class="headerlink" title="一、为什么有影响"></a>一、为什么有影响</h2><p>我们都知道一个对象GCRoot不可达，java虚拟机就认为是垃圾对象，就会进行垃圾回收，但是如果这个对象包含了finalize函数，性质就不一样了。怎么不一样了呢？</p><p>java虚拟机在进行垃圾回收的时候，一看到这个对象类含有finalize函数，就把这个函数交给FinalizerThread处理，而包含了这个finalize的对象就会被添加到FinalizerThread的执行队列，并使用一个链表，把这些包含了finalize的对象串起来。</p><p><img src="https://s3.ax1x.com/2021/01/12/sGzl1s.png"></p><p>他的影响在于只要finalize没有执行，那么这些对象就会一直存在堆区，不过这里只是4个包含了finalize的对象，影响不是那么大，如果有一万个或者是十万个呢？这就影响大了。</p><p>finalize的原理其实很简单，在这里简要的梳理一下：</p><p>（1）对象在初始化的过程中会判断是否重写了finalize，方法是判断两个字段标志has_finalizer_flag和RegisterFinalizersAtInit。</p><p>（2）如果重写了finalize，那就把当前对象注册到FinalizerThread的ReferenceQueue队列中。注册之后的对象就叫做Finalizer。方法是调用register_finalizer函数。此时java虚拟机一看当前有这个对象的引用，于是就不进行垃圾回收了。</p><p>（3）对象开始被调用，FinalizerThread线程负责从ReferenceQueue队列中获取Finalizer对象。开始执行finalize方法，在执行之前，这个对象一直在堆中。</p><p>（4）对象执行完毕之后，将这个Finalizer对象从队列中移除，java虚拟机一看对象没有引用了，就进行垃圾回收了。</p><p>这就是整个过程。不过在这里我们主要看的是finalize方法对垃圾回收的影响，其实就是在第三步，也就是这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。</p><blockquote><p><strong>注意：这里其实就是一道面试题，我在看牛客网上的面经时，看到有人被问到过。也就是GCRoot不可达的对象，会立刻被垃圾回收吗？</strong></p></blockquote><p>我们使用一个案例来分析一波：</p><h2 id="二、案例演示"><a href="#二、案例演示" class="headerlink" title="二、案例演示"></a>二、案例演示</h2><p>我们创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinalizer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fdd</span> </span>&#123;<br>    <span class="hljs-comment">//分配1M</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;finalize被执行&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        Fdd fdd = <span class="hljs-keyword">new</span> Fdd(); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在创建了类，我们设置一下参数。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 最大堆内存</span><br><span class="hljs-meta">-Xmx5m</span> <span class="hljs-string"></span><br><span class="hljs-comment"># 最小堆内存</span><br><span class="hljs-meta">-Xms5m</span>  <span class="hljs-string"></span><br><span class="hljs-comment"># 堆内存溢出错误打印</span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">+HeapDumpOnOutOfMemoryError </span><br><span class="hljs-comment"># 把堆相关信息保存在下列路径</span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">HeapDumpPath=F:/a.dump</span><br></code></pre></td></tr></table></figure><p>在main方法中，创建了1000个Fdd对象，如果不执行finalize方法，那么因为没有调用所以会进行垃圾回收，此时不断我们创建多少个，都不会出现任何问题。但是如果存在finalize方法，就不一样了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">java.lang.OutOfMemoryError</span>: <span class="hljs-string">Java heap space</span><br><span class="hljs-attr">Dumping</span> <span class="hljs-string">heap to F:/a.dump ...</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">Unable</span> <span class="hljs-string">to create F:/a.dump: File exists</span><br><span class="hljs-attr">Exception</span> <span class="hljs-string">in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="hljs-attr">at</span> <span class="hljs-string">com.fdd.chapter2.TestFinalizer$Fdd.&lt;init&gt;(TestFinalizer.java:6)</span><br><span class="hljs-attr">at</span> <span class="hljs-string">com.fdd.chapter2.TestFinalizer.main(TestFinalizer.java:14)</span><br></code></pre></td></tr></table></figure><p>我们看到每个对象都会执行finalize，在执行之前的这段时间一直会在堆区，执行完了就会被清理，所以你看到这里执行了不少于5次的finalize方法。但是对象一旦超出了我们设置的5M，就会出现内存溢出。一句话总结就是出现了对象堆积。现在使用MAT工具来分析一下。</p><blockquote><p>Mat工具是一个插件，也可以自己下载一个。下载完成之后打开我们刚刚生成的a.dump即可。</p></blockquote><p>下面这张图就是分析的结果：</p><p><img src="https://s3.ax1x.com/2021/01/12/sGzQpj.png"></p><p>a这块的内容就是Finalizer，也就是我们的Fdd对象，b包含的比较多，乱七八糟的剩余信息。当然你也可以查看一些其他的信息。都在MAT工具上。还有一些正在执行的finalizer和准备执行的。</p><p><img src="https://s3.ax1x.com/2021/01/12/sGz1cn.png"></p><p>OK，一些其他的信息就不再展示了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一个GCRoot不可达的对象，不会立刻被垃圾回收，首先还会判断是否包含了finalize方法，如果有那就先执行finalize方法，如果这样的对象比较多，那么这部分对象及时GCRoot不可达，变得没用了，也会留在内存中，影响程序的效率。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot启动了哪些bean？这两种方式可以获取</title>
    <link href="/2021/01/07/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/Springboot%E5%90%AF%E5%8A%A8%E4%BA%86%E5%93%AA%E4%BA%9Bbean%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96/"/>
    <url>/2021/01/07/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/Springboot%E5%90%AF%E5%8A%A8%E4%BA%86%E5%93%AA%E4%BA%9Bbean%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文出自公众号《愚公要移山》Springboot系列</strong></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在本文中，我们将探索在容器中获取所有spring管理的bean的相关技术。这有神马用？主要是用于排查问题。一般都是我们创建的某一个bean没有启动的问题。毕竟工作中总是会遇到各种各样的bug。提前了解一些没有坏处。</p><h2 id="2-IoC容器"><a href="#2-IoC容器" class="headerlink" title="2. IoC容器"></a>2. IoC容器</h2><p>bean是spring管理的应用程序的基础，所有bean都驻留在IOC容器中，该容器负责管理它们的生命周期。</p><p>我们可以通过两种方式获取该容器内所有bean的列表:</p><ol><li>使用<em>ListableBeanFactory</em>接口</li><li>使用Spring Boot Actuator</li></ol><h2 id="3-使用ListableBeanFactory接口"><a href="#3-使用ListableBeanFactory接口" class="headerlink" title="3.使用ListableBeanFactory接口"></a>3.使用ListableBeanFactory接口</h2><p>ListableBeanFactory接口提供了getBeanDefinitionNames()方法，该方法返回在这个工厂中定义的所有bean的名称。您可以在官方文档中找到所有已知子接口及其实现类的列表。我们来看这种方式如何获取所有的bean。</p><h3 id="第一步：创建一个Controller"><a href="#第一步：创建一个Controller" class="headerlink" title="第一步：创建一个Controller"></a>第一步：创建一个Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> FooService fooService;<br>    <span class="hljs-meta">@RequestMapping(value=&quot;/displayallbeans&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHeaderAndBody</span><span class="hljs-params">(Map model)</span></span>&#123;<br>        model.put(<span class="hljs-string">&quot;header&quot;</span>, fooService.getHeader());<br>        model.put(<span class="hljs-string">&quot;message&quot;</span>, fooService.getBody());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;displayallbeans&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个Controller依赖于另一个FooService。</p><h3 id="第二步：创建Service"><a href="#第二步：创建Service" class="headerlink" title="第二步：创建Service"></a>第二步：创建Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHeader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Display All Beans&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBody</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;展示所有beans的案例&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我们在这里创建了两个不同的bean:</p><ul><li><p>fooController</p></li><li><p>fooService</p></li></ul><p>这里使用applicationContext对象并调用它的getBeanDefinitionNames()方法，该方法将返回applicationContext容器中的所有bean:</p><h3 id="第三步：设置SpringBootApplication启动类"><a href="#第三步：设置SpringBootApplication启动类" class="headerlink" title="第三步：设置SpringBootApplication启动类"></a>第三步：设置SpringBootApplication启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        applicationContext = SpringApplication.run(DemoApplication.class, args);<br>        displayAllBeans();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayAllBeans</span><span class="hljs-params">()</span> </span>&#123;<br>        String[] allBeanNames = applicationContext.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span>(String beanName : allBeanNames) &#123;<br>            System.out.println(beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四步：测试打印"><a href="#第四步：测试打印" class="headerlink" title="第四步：测试打印"></a>第四步：测试打印</h3><p>这将打印applicationContext容器中的所有bean:</p><p><img src="https://s3.ax1x.com/2021/01/07/sZWQM9.png"></p><p>注意，除了我们定义的bean之外，它还将记录该容器中的所有其他bean。为了清楚起见，我们在这里省略了它们，因为它们有很多。</p><h2 id="4-使用Spring-Boot-Actuator"><a href="#4-使用Spring-Boot-Actuator" class="headerlink" title="4. 使用Spring Boot Actuator"></a>4. 使用Spring Boot Actuator</h2><p>Spring Boot Actuator提供了用于监控应用程序统计信息的端点。下面看看这种方式：</p><h3 id="第一步：添加依赖"><a href="#第一步：添加依赖" class="headerlink" title="第一步：添加依赖"></a>第一步：添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第二步：修改application-properties"><a href="#第二步：修改application-properties" class="headerlink" title="第二步：修改application.properties"></a>第二步：修改application.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><br></code></pre></td></tr></table></figure><p>把上面代码添加到properties文件中。</p><h3 id="第三步：使用发布端点查看"><a href="#第三步：使用发布端点查看" class="headerlink" title="第三步：使用发布端点查看"></a>第三步：使用发布端点查看</h3><p><img src="https://s3.ax1x.com/2021/01/07/sZWKxJ.png"></p><p>由于这里的Actuator没有配置，所以显示的比较乱。关于Actuator的配置，会在下一篇文章中呈现。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在本文中，我们了解了如何使用ListableBeanFactory接口和Spring Boot Actuator在Spring IoC容器中显示所有bean。希望对你有点帮助。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Spring系列</category>
      
      <category>Springboot专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一步为你的Springboot应用自定义banner</title>
    <link href="/2021/01/07/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/%E4%B8%80%E6%AD%A5%E4%B8%BA%E4%BD%A0%E7%9A%84Springboot%E5%BA%94%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89banner/"/>
    <url>/2021/01/07/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/%E4%B8%80%E6%AD%A5%E4%B8%BA%E4%BD%A0%E7%9A%84Springboot%E5%BA%94%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89banner/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文出自公众号《愚公要移山》Springboot系列</strong></p></blockquote><p>这个小功能据说是Springboot2.x的小彩蛋，出来很久很久了。之前知道没试过，这次试了一下，还可以，挺好玩的。最近因为开始重新看Springboot，看到了这个部分，于是整理到了文章中。烂大街的东西，拿来丢人显眼了。</p><h2 id="什么是banner？"><a href="#什么是banner？" class="headerlink" title="什么是banner？"></a>什么是banner？</h2><p><img src="https://s3.ax1x.com/2021/01/06/sVt9k6.png"></p><p>就是这个默认的Spring标识，有时候看着太难看，所以想换换，没什么卵用，有时候还会使你的Springboot应用启动变慢。所以看着玩玩就好。</p><h2 id="一步实现"><a href="#一步实现" class="headerlink" title="一步实现"></a>一步实现</h2><p>看好了，在你的springboot项目的resource目录下，新建一个banner.txt文件，你在里面写的内容就是要显示的内容。</p><p>比如说我们写上：愚公要移山。</p><p><img src="https://s3.ax1x.com/2021/01/06/sVtSTx.png"></p><p>这样写起来比较难看。还不如以前的格式好看，不过没关系，也有一些好看的网站已经帮我们实现了。转化之后把内容替换掉就可以。</p><ul><li>可以根据输入的字符生成字符画：<a href="http://patorjk.com/software/taag/#p=display&amp;f=Doh&amp;t=fengdongdong">http://patorjk.com/software/taag/#p=display&amp;f=Doh&amp;t=fengdongdong</a></li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sVYz01.png"></p><ul><li>可以根据画显示字符：<a href="https://www.degraeve.com/img2txt.php">https://www.degraeve.com/img2txt.php</a></li></ul><p>使用一张地图试试</p><p><img src="https://file01.16sucai.com/d/file/2011/0801/20110801111724537.jpg"></p><p>效果如下：</p><p><img src="https://s3.ax1x.com/2021/01/06/sVYxmR.png"></p><p>具体的你自己琢磨吧。</p><h2 id="还是难看？没事接着看"><a href="#还是难看？没事接着看" class="headerlink" title="还是难看？没事接着看"></a>还是难看？没事接着看</h2><p>这颜色太难看了。没事，还有配置。</p><p>Spring提供了三个枚举类来设定字符的颜色，分别是：</p><ul><li><p>AnsiColor： 用来设定字符的前景色</p></li><li><p>AnsiBackground： 用来设定字符的背景色</p></li><li><p>AnsiStyle： 用来控制加粗、斜体、下划线等等。</p></li></ul><p>我们设置个颜色试试。</p><p><img src="https://s3.ax1x.com/2021/01/06/sVtPfO.png"></p><p>最后启动，看看效果</p><p><img src="https://s3.ax1x.com/2021/01/06/sVtCtK.png"></p><p>小玩意，东西虽好，不要贪用！！感谢</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Spring系列</category>
      
      <category>Springboot专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为你的Springboot应用配置通用的异常处理吧（实用干货）</title>
    <link href="/2021/01/05/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/%E4%B8%BA%E4%BD%A0%E7%9A%84Springboot%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%90%A7%EF%BC%88%E5%AE%9E%E7%94%A8%E5%B9%B2%E8%B4%A7%EF%BC%89/"/>
    <url>/2021/01/05/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/%E4%B8%BA%E4%BD%A0%E7%9A%84Springboot%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%90%A7%EF%BC%88%E5%AE%9E%E7%94%A8%E5%B9%B2%E8%B4%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文出自公众号《愚公要移山》Springboot系列</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们的项目通常来讲都是一个比较大的项目，包含了各种各样的服务。如果每个服务都以不同的方式返回异常信息，这样排查的时候就会比较凌乱。如果我们定义一个标准的异常处理体系。并在所有的服务中使用。那样开发起来就可以快速定位。页面也会更加的简单和直观。</p><p>本文开发环境基于springboot2.4，IDE环境是IDEA。这里从一个最简单的异常案例。逐步过渡到完全自定义自己的异常。</p><blockquote><p>案例：Springboot查询数据库数据，发现返回的是null，就抛出异常。</p></blockquote><p>OK，基于这个思想，看一下实现的思路。</p><h2 id="一、简单案例代码实现"><a href="#一、简单案例代码实现" class="headerlink" title="一、简单案例代码实现"></a>一、简单案例代码实现</h2><h3 id="1、新建一个Springboot应用"><a href="#1、新建一个Springboot应用" class="headerlink" title="1、新建一个Springboot应用"></a>1、新建一个Springboot应用</h3><p><img src="https://s3.ax1x.com/2021/01/05/skPgte.png"></p><h3 id="2、新建dao包，创建User类"><a href="#2、新建dao包，创建User类" class="headerlink" title="2、新建dao包，创建User类"></a>2、新建dao包，创建User类</h3><p>这个比较简单，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//getter和setter方法</span><br>    <span class="hljs-comment">//toString方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、新建service包，创建UserService"><a href="#3、新建service包，创建UserService" class="headerlink" title="3、新建service包，创建UserService"></a>3、新建service包，创建UserService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        <span class="hljs-comment">//本来应该向数据库查询User，但是数据库没有</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于演示的是异常的案例，因此这里没有真正实现数据库的增删改查操作。当调用findOne方法时，直接返回为null即可。</p><h3 id="4、新建controller包，创建UserController类"><a href="#4、新建controller包，创建UserController类" class="headerlink" title="4、新建controller包，创建UserController类"></a>4、新建controller包，创建UserController类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService service;<br>    <span class="hljs-meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">retriveUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-keyword">int</span> id)</span> </span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> UserNotFoundException </span>&#123;<br>        User user= service.findOne(id);<br>        <span class="hljs-keyword">if</span>(user==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UserNotFoundException(<span class="hljs-string">&quot;id: &quot;</span>+ id);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里自定义了一个异常UserNotFoundException，当数据库查询的时候一旦发现返回值为null，就直接抛出这个异常。</p><h3 id="5、在controller包下，创建UserNotFoundException类"><a href="#5、在controller包下，创建UserNotFoundException类" class="headerlink" title="5、在controller包下，创建UserNotFoundException类"></a>5、在controller包下，创建UserNotFoundException类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserNotFoundException</span><span class="hljs-params">(String message)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>        System.out.println(<span class="hljs-string">&quot;异常信息是：&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、postman测试"><a href="#6、postman测试" class="headerlink" title="6、postman测试"></a>6、postman测试</h3><p><img src="https://s3.ax1x.com/2021/01/05/skPyTO.png" alt="1609827005387"></p><p>这时候进行测试会发现服务器代码会报错。我们的资源没有找到总不能提示服务器内部错误吧。现在对抛出的异常进行一个处理。</p><h3 id="7、异常处理"><a href="#7、异常处理" class="headerlink" title="7、异常处理"></a>7、异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserNotFoundException</span><span class="hljs-params">(String message)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>        System.out.println(<span class="hljs-string">&quot;异常信息是：&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将添加一个注释@ResponseStatus来生成状态:404 Not Found。当然还有其他的状态。这个可以根据自己的需要去返回。我们使用了HttpStatus.NOT_FOUND用户访问的时候，一旦抛出了异常就会显示404错误。这个你换成其他的状态，还会显示其他的信息。</p><h4 id="8、重新测试"><a href="#8、重新测试" class="headerlink" title="8、重新测试"></a>8、重新测试</h4><p><img src="https://s3.ax1x.com/2021/01/05/skPrm6.png" alt="1609827261976"></p><p>Spring Boot和Spring MVC框架的结合提供了错误处理。其内部已经自动配置一些默认异常处理。所以在开发中为所有服务配置一致的异常消息是很重要的。</p><h2 id="二、通用的异常处理"><a href="#二、通用的异常处理" class="headerlink" title="二、通用的异常处理"></a>二、通用的异常处理</h2><h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、创建异常返回实体类ExceptionResponse"><a href="#2、创建异常返回实体类ExceptionResponse" class="headerlink" title="2、创建异常返回实体类ExceptionResponse"></a>2、创建异常返回实体类ExceptionResponse</h3><p>这个类的作用是，当有异常时，我们想要展示的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionResponse</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Date timestamp;<br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-keyword">private</span> String detail;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExceptionResponse</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExceptionResponse</span><span class="hljs-params">(Date timestamp, String message, String detail)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.timestamp = timestamp;<br>        <span class="hljs-keyword">this</span>.message = message;<br>        <span class="hljs-keyword">this</span>.detail = detail;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getTimestamp</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> timestamp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetail</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> detail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只需要实现getter方法，setter方法就不需要。</p><h3 id="3、创建通用异常处理类"><a href="#3、创建通用异常处理类" class="headerlink" title="3、创建通用异常处理类"></a>3、创建通用异常处理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomizedResponseEntityExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseEntityExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">//此方法主要处理所有的异常信息</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ResponseEntity&lt;Object&gt; <span class="hljs-title">handleAllExceptions</span><span class="hljs-params">(Exception ex, WebRequest request)</span> </span>&#123;<br>        <span class="hljs-comment">//当出现异常时，我们输出的信息，这里被封装在了ExceptionResponse</span><br>        ExceptionResponse exceptionResponse = <span class="hljs-keyword">new</span> ExceptionResponse(<span class="hljs-keyword">new</span> Date(), ex.getMessage(), request.getDescription(<span class="hljs-keyword">false</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR);<br>    &#125;<br>    <span class="hljs-comment">//当页面资源没有找到时，抛出的异常</span><br>    <span class="hljs-meta">@ExceptionHandler(UserNotFoundException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ResponseEntity&lt;Object&gt; <span class="hljs-title">handleUserNotFoundExceptions</span><span class="hljs-params">(UserNotFoundException ex, WebRequest request)</span> </span>&#123;<br>        ExceptionResponse exceptionResponse = <span class="hljs-keyword">new</span> ExceptionResponse(<span class="hljs-keyword">new</span> Date(), ex.getMessage(), request.getDescription(<span class="hljs-keyword">false</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很简单。里面有很多API，可以自己根据需要去查即可。</p><h3 id="4、postman测试"><a href="#4、postman测试" class="headerlink" title="4、postman测试"></a>4、postman测试</h3><p><img src="https://s3.ax1x.com/2021/01/05/skPs0K.png" alt="1609828897996"></p><p>万事大吉。赶快为你的程序自定义一个通用的异常处理程序吧。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Spring系列</category>
      
      <category>Springboot专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序出现了bug如何排查？看看这几款JVM工具</title>
    <link href="/2021/01/04/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E4%BA%86bug%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%EF%BC%9F%E7%9C%8B%E7%9C%8B%E8%BF%99%E5%87%A0%E6%AC%BEJVM%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/01/04/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E4%BA%86bug%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%EF%BC%9F%E7%9C%8B%E7%9C%8B%E8%BF%99%E5%87%A0%E6%AC%BEJVM%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>在平时的开发当中我们总是会遇到各种各样的问题，比如说内存泄漏、死锁、CPU等。遇到问题不可怕，关键是我们如何去排查这些错误，对症下药才是根本。不过对于很多人来说，往往找不到这些问题的根本所在，因此这篇文章主要是让我们掌握一些工具来分析到底是哪里出现了问题。</p><p>在之前的文章中，主要是分析了JVM的内存结构、类加载机制和垃圾回收机制。文章的顺序也是循序渐进的，从这篇文章当中我们主要是分析JDK自带的工具，把理论应用于实践。</p><p>首先我们先对几种要讲的工具进行一个概述，然后再分别分析：</p><h2 id="一、性能监控工具概述"><a href="#一、性能监控工具概述" class="headerlink" title="一、性能监控工具概述"></a>一、性能监控工具概述</h2><p>工具主要是为了解决问题而生的，就是由于我们的程序存在着一些性能问题，才有了这些工具。其实当我们在下载完成JDK之后，那些工具就被SUN公司随之送给我们了。</p><p>我们可以在我们的JDK安装目录，下看看会有很多这样的工具。</p><p><img src="https://s3.ax1x.com/2021/01/04/siBAeI.png"></p><p>我们会发现很多这样的exe文件，这里面有很多都是性能监控工具。我们就抽出来几个进行讲解。</p><table><thead><tr><th>工具名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps（JVM Process Status Tool）</td><td>显示指定系统中所有的HotSpot虚拟机进程</td></tr><tr><td>jstat（JVM Statistics Monitoring Tool）</td><td>收集HotSpot虚拟机各方面的运行数据</td></tr><tr><td>jinfo（Configuration Info for Java）</td><td>显示虚拟机配置信息</td></tr><tr><td>jmap（Memory Map for Java）</td><td>生成虚拟机的内存转储快照（heapdump文件）</td></tr><tr><td>jhat（JVM Heap Dump Browser）</td><td>分析内存转储快照，不推荐使用，消耗资源而且慢</td></tr><tr><td>jstack（Stack Trace for Java）</td><td>显示虚拟机的线程快照</td></tr><tr><td>JConsole</td><td>JMX的可视化管理工具</td></tr><tr><td>VisualVM</td><td>多合一故障管理工具</td></tr></tbody></table><p>常见的几个工具都已经列出来了，还有一些其他的工具，其实用起来比JDK自带的还要好，我会在今后的文章中列出来。OK，我们就一个一个去分析一下这些工具是干嘛的，以及如何去使用的。</p><h2 id="二、工具"><a href="#二、工具" class="headerlink" title="二、工具"></a><strong>二、工具</strong></h2><h3 id="1、jps-虚拟机进程状况工具"><a href="#1、jps-虚拟机进程状况工具" class="headerlink" title="1、jps:虚拟机进程状况工具"></a><strong>1、jps:虚拟机进程状况工具</strong></h3><p>jps主要用来输出JVM中运行的进程状态信息。语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">jps</span> <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[hostid]</span><br></code></pre></td></tr></table></figure><p>   <strong>第一个参数：options</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-q 不输出类名、Jar名和传入main方法的参数<br>-m 输出传入main方法的参数<br>-l 输出main类或Jar的全限名<br>-v 输出传入JVM的参数<br></code></pre></td></tr></table></figure><p>​    <strong>第二个参数：hostid</strong></p><p>主机或者是服务器的id，如果不指定，就默认为当前的主机或者是服务器。</p><p>我是在Windows10系统下测试的，当然你可以在linux下试验，方式是一样的，结果可能有不同。你可以选择不同的参数选项来进行测试。打开CMD输入相应命令</p><p><img src="https://s3.ax1x.com/2021/01/04/siBFOA.png"></p><h3 id="2、jstack：堆栈跟踪工具"><a href="#2、jstack：堆栈跟踪工具" class="headerlink" title="2、jstack：堆栈跟踪工具"></a><strong>2、jstack：堆栈跟踪工具</strong></h3><p>jstack用于生成虚拟机当前时刻的线程快照。语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jstack [option] vmid<br></code></pre></td></tr></table></figure><p><strong>第一个参数：option</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被相应时候，强制输出线程堆栈</td></tr><tr><td>-l</td><td>出堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><p><strong>第二个参数：vmid</strong></p><p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。</p><p>我们直接在CMD中操作一下：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBPQH.png"></p><h3 id="3、jstat-虚拟机统计信息监控工具"><a href="#3、jstat-虚拟机统计信息监控工具" class="headerlink" title="3、jstat:虚拟机统计信息监控工具"></a><strong>3、jstat:虚拟机统计信息监控工具</strong></h3><p>jstat监视虚拟机各种运行状态信息，可以显示本地或者是远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jstat [ generalOption | outputOptions vmid [interval] [count]] ]<br></code></pre></td></tr></table></figure><p><strong>第一个参数：generalOption | outputOptions</strong></p><p>这个参数表示的option，代表着用户希望查询的虚拟机信息，分为类加载、垃圾收集、运行期编译状况3类。</p><p><img src="https://s3.ax1x.com/2021/01/04/siBVTP.png"></p><p><strong>第二个参数：vmid</strong></p><p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。</p><p><strong>第三个参数：interval</strong></p><p>interval是采样时间间隔，</p><p><strong>第四个参数：count</strong></p><p>count表示的是采样数。</p><p>下面我们就是用一下这个工具，打开我们的CMD，输入相应的命令：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBiyd.png"></p><h3 id="4、jinfo：实时地查看和调整虚拟机各项参数"><a href="#4、jinfo：实时地查看和调整虚拟机各项参数" class="headerlink" title="4、jinfo：实时地查看和调整虚拟机各项参数"></a><strong>4、jinfo：实时地查看和调整虚拟机各项参数</strong></h3><p>命令格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jinfo [option] pid<br></code></pre></td></tr></table></figure><p><strong>第一个参数：option</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-v</td><td>查看虚拟机启动时显示指定的参数列表</td></tr><tr><td>-flag</td><td>查看虚拟机启动时未被指定的参数的默认值</td></tr><tr><td>-sysprops</td><td>打印虚拟机进程的System.getProperties()的内容</td></tr></tbody></table><p><strong>第二个参数：pid</strong></p><p>指定显示的进程id。</p><p>在CMD中进行测试：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBEwt.png"></p><h3 id="5、jmap：生成虚拟机的内存转储快照（heapdump文件）"><a href="#5、jmap：生成虚拟机的内存转储快照（heapdump文件）" class="headerlink" title="5、jmap：生成虚拟机的内存转储快照（heapdump文件）"></a><strong>5、jmap：生成虚拟机的内存转储快照（heapdump文件）</strong></h3><p>jmap（Memory Map for Java，内存映像工具），用于生成堆转存的快照，一般是heapdump或者dump文件。如果不适用jmap命令，可以使用-XX:+HeapDumpOnOutOfMemoryError参数，当虚拟机发生内存溢出的时候可以产生快照。或者使用kill -3 pid也可以产生。jmap的作用并不仅仅是为了获取dump文件，它可以查询finalize执行队列，java堆和永久代的详细信息，如空间使用率，当前用的哪种收集器。命令格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jmap [option] vmid<br></code></pre></td></tr></table></figure><p><strong>第一个参数：</strong></p><p><img src="https://s3.ax1x.com/2021/01/04/siBmY8.png"></p><p><strong>第二个参数：vmid</strong></p><p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID.</p><p>在cmd中测试：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBKSg.png"></p><h3 id="6、jhat：分析内存转储快照，不推荐使用，而且慢"><a href="#6、jhat：分析内存转储快照，不推荐使用，而且慢" class="headerlink" title="6、jhat：分析内存转储快照，不推荐使用，而且慢"></a><strong>6、jhat：分析内存转储快照，不推荐使用，而且慢</strong></h3><p>由于这个工具功能比较简陋，运行起来也比较耗时，所以这个工具不推荐使用，推荐使用MAT。</p><h3 id="7、JConsole：JMX的可视化管理工具"><a href="#7、JConsole：JMX的可视化管理工具" class="headerlink" title="7、JConsole：JMX的可视化管理工具"></a><strong>7、JConsole：JMX的可视化管理工具</strong></h3><p>这个工具相比较前面几个工具，使用率比较高，很重要。它是一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。</p><p>在cmd里面输入 jconsole，选则进程就可以了。（前提是在IDE工具先建立一个线程运行着）</p><p><img src="https://s3.ax1x.com/2021/01/04/siBeFf.png"></p><p>然后我们选择了相应的选项之后，进入这个工具就会出现下面这个界面</p><p><img src="https://s3.ax1x.com/2021/01/04/siBnfS.png"></p><p>在上面有菜单，我们可以选择其中一个进行查看，就可以了，这个用具用起来很方便，也是我之前用的比较多的工具。</p><h3 id="8、VisualVM：多合一故障管理工具"><a href="#8、VisualVM：多合一故障管理工具" class="headerlink" title="8、VisualVM：多合一故障管理工具"></a><strong>8、VisualVM：多合一故障管理工具</strong></h3><p>这个工具也很牛bility。它同jconsole都是一个基于图形化界面的、可以查看本地及远程的JAVA GUI监控工具，Jvisualvm同jconsole的使用方式一样，直接在命令行打入jvisualvm即可启动，jvisualvm界面更美观一些，数据更实时：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBMlQ.png"></p><p>最上面也有菜单，你可以选择不同的选项来展示。自己动手试一遍是最好的。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a><strong>三、总结</strong></h2><p>这些工具就先写这么多，在文章一开始我们其实已经发现了，jdk自带的工具那是超级的多，而且随着jdk版本的不断更新，工具还有不断加强增多的趋势，想要每一个都掌握那太费时间了，我们遇到哪些问题去搜索一下，看看能用到哪些工具就可以了。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java小白到架构师技术图谱</title>
    <link href="/2021/01/03/java%E5%B0%8F%E7%99%BD%E5%88%B0%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    <url>/2021/01/03/java%E5%B0%8F%E7%99%BD%E5%88%B0%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</url>
    
    <content type="html"><![CDATA[<p><strong>本文整理于github上各大star大神仓库。并根据自己的理解重新进行了整理</strong></p><blockquote><p><strong>本文已经收录于<a href="https://github.com/fengdongdongwsn/architect-java">https://github.com/fengdongdongwsn/architect-java</a></strong></p><p><strong>后序会继续更新</strong></p></blockquote><h2 id="👨🏻‍💻-About-Me"><a href="#👨🏻‍💻-About-Me" class="headerlink" title="👨🏻‍💻 About Me"></a>👨🏻‍💻 About Me</h2><table><thead><tr><th>个人网站</th><th>公众号</th><th>掘金</th><th>知乎</th><th><strong>CSDN</strong></th><th><strong>头条</strong></th></tr></thead><tbody><tr><td><a href="https://www.javachat.cc/">点我直达</a></td><td><a href="https://imgchr.com/i/rJnbO1">点我直达</a></td><td><a href="https://juejin.cn/user/1978776660213837/posts">点我直达</a></td><td><a href="https://www.zhihu.com/people/feng-dong-dong-10">点我直达</a></td><td><a href="https://blog.csdn.net/SDDDLLL">点我直达</a></td><td><a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAfhLQnyWhG1iqEVx_lsnoX7cUOlluuJf07J368xBJ7jU/">点我直达</a></td></tr><tr><td><strong>百家号</strong></td><td><strong>Segmentfault</strong></td><td><strong>教程资源（5T）</strong></td><td><strong>学习路线</strong></td><td><strong>博客文章</strong></td><td></td></tr><tr><td><a href="https://author.baidu.com/home?from=bjh_article&app_id=1634941951856739">点我直达</a></td><td><a href="https://segmentfault.com/u/a_yugong">点我直达</a></td><td><a href="https://mp.weixin.qq.com/s/nIODGnCKFgs3BTZ9Qy5rHQ?scene=25#wechat_redirect">点我直达</a></td><td><a href="https://mp.weixin.qq.com/s/UTV2GXtBdX-oLh7M9LTEvQ">点击直达</a></td><td><a href="https://mp.weixin.qq.com/s/wZ_4fy_F-NecMv3HO4Hfjw">点击直达</a></td><td></td></tr></tbody></table><h2 id="一、计算机基础"><a href="#一、计算机基础" class="headerlink" title="一、计算机基础"></a>一、计算机基础</h2><h3 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h3><h4 id="（1）基本数据结构"><a href="#（1）基本数据结构" class="headerlink" title="（1）基本数据结构"></a>（1）基本数据结构</h4><ul><li>数据结构基本概念（时间复杂度和空间复杂度的计算方法）</li><li>数组</li><li>链表</li><li>集合</li><li>队列</li><li>栈</li><li>关联数组</li><li>跳表</li><li>倒排索引</li><li>BitSet</li></ul><h4 id="（2）树"><a href="#（2）树" class="headerlink" title="（2）树"></a>（2）树</h4><ul><li>二叉树</li><li>平衡二叉树</li><li>完全二叉树</li><li>哈弗曼树</li><li>二叉查找树</li><li>B、B+、B*树</li><li>LSM树</li><li>字典树</li><li>红黑树</li><li>线段树</li></ul><h4 id="（3）图"><a href="#（3）图" class="headerlink" title="（3）图"></a>（3）图</h4><ul><li>最小生成树</li><li>最短路径算法</li><li>拓扑排序</li><li>深搜和广搜</li></ul><h4 id="（4）排序算法"><a href="#（4）排序算法" class="headerlink" title="（4）排序算法"></a>（4）排序算法</h4><ul><li>选择排序</li><li>冒泡排序</li><li>插入排序</li><li>快速排序</li><li>归并排序</li><li>希尔排序</li><li>基数排序</li><li>计数排序</li><li>桶排序</li><li>堆排序</li><li>排序算法使用场景特点总结</li></ul><h4 id="（5）查找算法"><a href="#（5）查找算法" class="headerlink" title="（5）查找算法"></a>（5）查找算法</h4><ul><li>顺序查找</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li><li>树表查找</li></ul><h4 id="（6）常见算法"><a href="#（6）常见算法" class="headerlink" title="（6）常见算法"></a>（6）常见算法</h4><ul><li>KMP算法</li><li>贪心算法</li><li>回溯算法</li><li>剪枝算法</li><li>动态规划</li><li>并查集</li><li>朴素贝叶斯</li><li>递归算法</li><li>符号表</li><li>布隆过滤器</li></ul><h3 id="2、计算机网络"><a href="#2、计算机网络" class="headerlink" title="2、计算机网络"></a>2、计算机网络</h3><h4 id="（1）协议"><a href="#（1）协议" class="headerlink" title="（1）协议"></a>（1）协议</h4><ul><li>OSI七层协议</li><li>TCP/IP协议</li><li>HTTP协议</li></ul><h4 id="（2）网络模型"><a href="#（2）网络模型" class="headerlink" title="（2）网络模型"></a>（2）网络模型</h4><ul><li>阻塞式IO</li><li>非阻塞式IO</li><li>复用IO</li><li>信号驱动IO</li><li>异步IO</li><li>Epoll模型</li><li>javaNIO</li><li>javaAIO</li><li>kqueue</li></ul><h4 id="（3）序列化"><a href="#（3）序列化" class="headerlink" title="（3）序列化"></a>（3）序列化</h4><ul><li>java序列化</li><li>protoBuf</li><li>protoStuff</li><li>avro</li><li>Hessian</li></ul><h3 id="3、操作系统"><a href="#3、操作系统" class="headerlink" title="3、操作系统"></a>3、操作系统</h3><h4 id="（1）基本知识"><a href="#（1）基本知识" class="headerlink" title="（1）基本知识"></a>（1）基本知识</h4><ul><li>操作系统的四个特征</li><li>操作系统的功能</li></ul><h4 id="（2）进程与线程"><a href="#（2）进程与线程" class="headerlink" title="（2）进程与线程"></a>（2）进程与线程</h4><ul><li>进程的概念与分类</li><li>线程的概念与分类</li><li>进程与线程的区别</li><li>进行的状态转换</li><li>CPU调度算法</li><li>管程</li><li>协程</li><li>进程间的通信方式</li><li>进程间同步问题<ul><li>生产者消费者问题</li><li>哲学家就餐问题</li><li>读者-写者问题</li><li>锁死的四个必要条件</li><li>死锁处理</li></ul></li></ul><h4 id="（3）内存管理"><a href="#（3）内存管理" class="headerlink" title="（3）内存管理"></a>（3）内存管理</h4><ul><li>段式管理</li><li>页式管理</li><li>段页式管理</li><li>页面调度算法</li></ul><h4 id="（4）其他"><a href="#（4）其他" class="headerlink" title="（4）其他"></a>（4）其他</h4><ul><li>虚拟内存和逻辑内存</li><li>静态链接和动态链接</li><li>缓存</li><li>僵尸进程与孤儿进程</li></ul><h2 id="二、java基础"><a href="#二、java基础" class="headerlink" title="二、java基础"></a>二、java基础</h2><h3 id="1、面向对象基础"><a href="#1、面向对象基础" class="headerlink" title="1、面向对象基础"></a>1、面向对象基础</h3><ul><li>继承</li><li>封装</li><li>多态</li><li>接口</li><li>抽象类</li></ul><h3 id="2、java集合"><a href="#2、java集合" class="headerlink" title="2、java集合"></a>2、java集合</h3><ul><li>总体框架</li><li>Collection</li><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li><li>快速失败和快速安全</li><li>HashMap</li><li>TreeMap</li><li>LinkedHashMap</li><li>HashSet</li><li>TreeSet</li><li>Hashtable</li><li>WeakHashMap</li></ul><h3 id="3、关键字和类"><a href="#3、关键字和类" class="headerlink" title="3、关键字和类"></a>3、关键字和类</h3><ul><li>transient</li><li>instanceof</li><li>static</li><li>this</li><li>super</li><li>void</li><li>final</li><li>String<ul><li>String为什么不可变</li><li>String、StringBuilder、StringBuffer区别</li><li>String到底新建了几个对象</li></ul></li></ul><h3 id="4、java高级特点"><a href="#4、java高级特点" class="headerlink" title="4、java高级特点"></a>4、java高级特点</h3><ul><li>注解</li><li>反射</li><li>泛型</li><li>异常</li><li>枚举</li><li>IO机制</li><li>编码转换</li><li>java8新特性</li><li>java11新特性</li></ul><h3 id="5、并发库"><a href="#5、并发库" class="headerlink" title="5、并发库"></a>5、并发库</h3><h4 id="（1）并发基础"><a href="#（1）并发基础" class="headerlink" title="（1）并发基础"></a>（1）并发基础</h4><ul><li>Thread生命周期</li><li>线程安全问题</li><li>线程通信模式</li><li>sleep和wait的区别</li><li>ThreadLocal</li></ul><h4 id="（2）原子特性"><a href="#（2）原子特性" class="headerlink" title="（2）原子特性"></a>（2）原子特性</h4><ul><li>AtomicInteger</li><li>AtomicBoolean</li><li>AtomicStampedReference</li><li>Unsafe</li><li>CAS</li></ul><h4 id="（3）并发工具"><a href="#（3）并发工具" class="headerlink" title="（3）并发工具"></a>（3）并发工具</h4><ul><li>CountDownLatch</li><li>CylicBarrier</li><li>Semaphore</li><li>Exchanger</li><li>Phaser</li><li>ForkJoin</li></ul><h4 id="（4）锁机制"><a href="#（4）锁机制" class="headerlink" title="（4）锁机制"></a>（4）锁机制</h4><ul><li>synchronized</li><li>volatile</li><li>Reentrantlock</li><li>ReenReadWriteLock</li><li>StampedLock</li><li>公平锁和非公平锁</li><li>悲观锁和乐观锁</li><li>ABA问题</li><li>互斥锁和共享锁</li><li>可重入锁和不可重入锁</li><li>AQS机制</li><li>RingBuffer</li><li>锁升级</li><li>锁消除</li><li>锁粗化</li></ul><h4 id="（5）并发容器"><a href="#（5）并发容器" class="headerlink" title="（5）并发容器"></a>（5）并发容器</h4><ul><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li><li>ConcurrentSkipSet</li><li>ConcurrentLinkedQueue</li><li>CopyOnWriteArrayList</li><li>阻塞队列</li><li>优先级队列</li></ul><h4 id="（6）线程池"><a href="#（6）线程池" class="headerlink" title="（6）线程池"></a>（6）线程池</h4><ul><li>线程池的几种状态切换</li><li>线程池的参数</li><li>线程池的启动流程</li><li>线程池的分类</li><li>线程池的大小设置</li></ul><h3 id="6、JVM"><a href="#6、JVM" class="headerlink" title="6、JVM"></a>6、JVM</h3><ul><li>java内存结构（jdk1.7和1.8）</li><li>垃圾回收机制</li><li>类加载机制</li><li>内存分类和回收</li><li>四种引用（强、软、弱、虚）</li><li>内存溢出</li><li>JVM调优工具</li><li>垃圾回收器</li><li>ZGC的认识</li><li>JNI</li><li>内存逃逸</li></ul><h2 id="三、必备基础"><a href="#三、必备基础" class="headerlink" title="三、必备基础"></a>三、必备基础</h2><h3 id="1、设计模式"><a href="#1、设计模式" class="headerlink" title="1、设计模式"></a>1、设计模式</h3><ul><li>创建型模式</li><li>结构性模式</li><li>行为性模式</li><li>设计模式的六种原则</li><li>MVC模型</li><li>MVVC模型</li><li>UML</li><li>康威定理</li></ul><h3 id="2、Linux"><a href="#2、Linux" class="headerlink" title="2、Linux"></a>2、Linux</h3><ul><li>Linux目录结构</li><li>常见命令</li><li>文件系统管理</li><li>用户系统管理</li><li>进程管理</li><li>网络管理</li><li>备份与恢复</li><li>文本文件处理命令</li><li>shell编程</li></ul><h3 id="3、代码工具"><a href="#3、代码工具" class="headerlink" title="3、代码工具"></a>3、代码工具</h3><ul><li>Git</li><li>Maven</li><li>gradle</li><li>日志框架</li><li>Junit</li></ul><h2 id="四、数据库"><a href="#四、数据库" class="headerlink" title="四、数据库"></a>四、数据库</h2><h3 id="1、mysql"><a href="#1、mysql" class="headerlink" title="1、mysql"></a>1、mysql</h3><h4 id="（1）基本知识-1"><a href="#（1）基本知识-1" class="headerlink" title="（1）基本知识"></a>（1）基本知识</h4><ul><li>三大范式</li><li>数据库、数据表、字段的增删改查基本操作</li><li>分区表</li><li>视图</li><li>外键约束</li><li>游标</li><li>变量</li><li>存储过程</li><li>函数</li><li>字符集</li></ul><h4 id="（2）存储引擎"><a href="#（2）存储引擎" class="headerlink" title="（2）存储引擎"></a>（2）存储引擎</h4><ul><li>InnoDB</li><li>MyISAM</li><li>转换表的引擎</li></ul><h4 id="（3）事务"><a href="#（3）事务" class="headerlink" title="（3）事务"></a>（3）事务</h4><ul><li>隔离级别</li><li>多版本并发工具</li><li>分布式事务</li><li>ACID特性</li></ul><h4 id="（4）索引"><a href="#（4）索引" class="headerlink" title="（4）索引"></a>（4）索引</h4><ul><li>聚集索引</li><li>非聚集索引</li><li>复合索引</li><li>底层实现原理</li></ul><h4 id="（5）锁"><a href="#（5）锁" class="headerlink" title="（5）锁"></a>（5）锁</h4><h4 id="（6）测试"><a href="#（6）测试" class="headerlink" title="（6）测试"></a>（6）测试</h4><h4 id="（7）优化方案"><a href="#（7）优化方案" class="headerlink" title="（7）优化方案"></a>（7）优化方案</h4><ul><li>数据类型优化</li><li>索引优化</li><li>查询性能优化</li><li>mysql配置优化</li><li>硬件优化</li></ul><h4 id="（8）高可用方案"><a href="#（8）高可用方案" class="headerlink" title="（8）高可用方案"></a>（8）高可用方案</h4><h4 id="（9）复制迁移"><a href="#（9）复制迁移" class="headerlink" title="（9）复制迁移"></a>（9）复制迁移</h4><h3 id="2、Redis"><a href="#2、Redis" class="headerlink" title="2、Redis"></a>2、Redis</h3><ul><li>持久化机制</li><li>缓存三种问题（穿透、击穿、雪崩）</li><li>内存淘汰策略</li><li>哨兵机制</li><li>集群方案</li><li>复制原理</li></ul><h3 id="3、MongoDB"><a href="#3、MongoDB" class="headerlink" title="3、MongoDB"></a>3、MongoDB</h3><h3 id="4、Hbase"><a href="#4、Hbase" class="headerlink" title="4、Hbase"></a>4、Hbase</h3><h2 id="五、常用基本框架"><a href="#五、常用基本框架" class="headerlink" title="五、常用基本框架"></a>五、常用基本框架</h2><h3 id="1、servlet"><a href="#1、servlet" class="headerlink" title="1、servlet"></a>1、servlet</h3><h3 id="2、Spring系列家族"><a href="#2、Spring系列家族" class="headerlink" title="2、Spring系列家族"></a>2、Spring系列家族</h3><h3 id="3、Mybatis"><a href="#3、Mybatis" class="headerlink" title="3、Mybatis"></a>3、Mybatis</h3><h3 id="4、JPA"><a href="#4、JPA" class="headerlink" title="4、JPA"></a>4、JPA</h3><h3 id="5、Netty"><a href="#5、Netty" class="headerlink" title="5、Netty"></a>5、Netty</h3><h3 id="6、websocket"><a href="#6、websocket" class="headerlink" title="6、websocket"></a>6、websocket</h3><h2 id="六、运维统计相关"><a href="#六、运维统计相关" class="headerlink" title="六、运维统计相关"></a>六、运维统计相关</h2><h3 id="1、平台监控"><a href="#1、平台监控" class="headerlink" title="1、平台监控"></a>1、平台监控</h3><ul><li>zabbix、Nagios、Ganglia等</li><li>Linux命令监控：top、sar、tsar、nload等</li><li>JVM监控工具</li></ul><h3 id="2、APM"><a href="#2、APM" class="headerlink" title="2、APM"></a>2、APM</h3><h3 id="3、持续集成"><a href="#3、持续集成" class="headerlink" title="3、持续集成"></a>3、持续集成</h3><ul><li>持续集成工具Jenkins</li><li>TeamCity</li><li>Travis CI</li><li>GitLab CI</li><li>环境分离</li></ul><h3 id="4、容器相关"><a href="#4、容器相关" class="headerlink" title="4、容器相关"></a>4、容器相关</h3><ul><li>Docker</li><li>K8S</li></ul><h3 id="5、虚拟化"><a href="#5、虚拟化" class="headerlink" title="5、虚拟化"></a>5、虚拟化</h3><ul><li>KVM</li><li>Xen</li><li>OpenVZ</li></ul><h3 id="6、自动化运维"><a href="#6、自动化运维" class="headerlink" title="6、自动化运维"></a>6、自动化运维</h3><ul><li>Ansible</li><li>puppet</li><li>chef</li></ul><h3 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h3><ul><li>单元测试</li><li>压力测试</li><li>灰度测试</li><li>A/B测试</li><li>蓝绿测试</li><li>TDD测试理论</li><li>全链路测试</li></ul><h2 id="七、中间件"><a href="#七、中间件" class="headerlink" title="七、中间件"></a>七、中间件</h2><h3 id="1、web"><a href="#1、web" class="headerlink" title="1、web"></a>1、web</h3><ul><li>Nginx</li><li>OpenRestry</li><li>Tengine</li><li>ApacheHttpd</li></ul><h3 id="2、服务器"><a href="#2、服务器" class="headerlink" title="2、服务器"></a>2、服务器</h3><ul><li>Tomcat</li><li>Jetty</li><li>WebLogic</li><li>JBoss</li></ul><h3 id="3、缓存"><a href="#3、缓存" class="headerlink" title="3、缓存"></a>3、缓存</h3><ul><li>本地缓存</li><li>客户端缓存</li><li>web缓存</li><li>Memcached</li><li>Redis</li><li>Tair</li><li>cellar</li></ul><h3 id="4、消息队列"><a href="#4、消息队列" class="headerlink" title="4、消息队列"></a>4、消息队列</h3><ul><li>Kafka</li><li>ActiveMQ</li><li>RocketMQ</li><li>RabbitMQ</li><li>Redis消息队列</li><li>ZeroMQ</li></ul><h3 id="5、RPC"><a href="#5、RPC" class="headerlink" title="5、RPC"></a>5、RPC</h3><ul><li>Dubbo</li><li>Thrift</li><li>gRPC</li><li>java的RMI</li></ul><h3 id="6、定时任务"><a href="#6、定时任务" class="headerlink" title="6、定时任务"></a>6、定时任务</h3><ul><li>Quartz</li><li>cron定时调度</li><li>java定时任务</li><li>Elastic-job</li><li>opencron</li><li>LTS</li></ul><h3 id="7、数据库中间件"><a href="#7、数据库中间件" class="headerlink" title="7、数据库中间件"></a>7、数据库中间件</h3><ul><li>Mycat</li><li>Sharding Jdbc</li></ul><h3 id="8、搜索引擎"><a href="#8、搜索引擎" class="headerlink" title="8、搜索引擎"></a>8、搜索引擎</h3><ul><li>Lucene</li><li>Elasticsearch</li><li>Solr</li><li>sphinx</li></ul><h2 id="八、微服务"><a href="#八、微服务" class="headerlink" title="八、微服务"></a>八、微服务</h2><h3 id="1、微服务框架"><a href="#1、微服务框架" class="headerlink" title="1、微服务框架"></a>1、微服务框架</h3><ul><li>Springcloud</li><li>SpringCloud Alibaba</li><li>Dropwizard</li><li>Akka</li></ul><h3 id="2、注册中心"><a href="#2、注册中心" class="headerlink" title="2、注册中心"></a>2、注册中心</h3><ul><li>Eureka</li><li>Zookeeper</li><li>Consul</li></ul><h3 id="3、服务调用"><a href="#3、服务调用" class="headerlink" title="3、服务调用"></a>3、服务调用</h3><ul><li>Feigh</li><li>restTemplete</li></ul><h3 id="4、负载均衡"><a href="#4、负载均衡" class="headerlink" title="4、负载均衡"></a>4、负载均衡</h3><ul><li>Ribbon</li></ul><h3 id="5、网关"><a href="#5、网关" class="headerlink" title="5、网关"></a>5、网关</h3><ul><li>Gateway</li><li>kong</li><li>zuul</li></ul><h3 id="6、配置中心"><a href="#6、配置中心" class="headerlink" title="6、配置中心"></a>6、配置中心</h3><ul><li>Zookeeper</li><li>Apollo</li><li>Springcloud Config</li></ul><h3 id="7、链路跟踪"><a href="#7、链路跟踪" class="headerlink" title="7、链路跟踪"></a>7、链路跟踪</h3><ul><li>SpringCloud Bus</li><li>SpringCloud Sleuth</li><li>Zipkin</li><li>Dapper</li><li>log-based</li><li>HTrace</li></ul><h2 id="九、分布式"><a href="#九、分布式" class="headerlink" title="九、分布式"></a>九、分布式</h2><h3 id="1、分布式理论"><a href="#1、分布式理论" class="headerlink" title="1、分布式理论"></a>1、分布式理论</h3><ul><li>CAP理论</li><li>BASE理论</li><li>幂等性</li><li>分布式锁<ul><li>redis实现</li><li>数据库实现</li><li>Zookeeper实现</li></ul></li></ul><h3 id="2、一致性算法"><a href="#2、一致性算法" class="headerlink" title="2、一致性算法"></a>2、一致性算法</h3><ul><li>Paxos</li><li>ZAB</li><li>Raft</li><li>Gossip</li><li>两阶段提交协议</li><li>节点选举策略</li><li>一致性hash算法</li></ul><h3 id="3、分布式文件系统"><a href="#3、分布式文件系统" class="headerlink" title="3、分布式文件系统"></a>3、分布式文件系统</h3><ul><li>HDFS</li><li>fastDFS</li></ul><h3 id="4、分布式ID"><a href="#4、分布式ID" class="headerlink" title="4、分布式ID"></a>4、分布式ID</h3><ul><li>Snowflake算法</li><li>Flicker算法</li><li>UUID</li><li>MongoDB实现</li></ul><h3 id="5、分布式事务"><a href="#5、分布式事务" class="headerlink" title="5、分布式事务"></a>5、分布式事务</h3><ul><li>多阶段提交</li><li>TCC补偿事务</li><li>本地消息表</li><li>MQ事务消息</li><li>最大努力通知</li></ul><h3 id="6、稳定性高可用方案"><a href="#6、稳定性高可用方案" class="headerlink" title="6、稳定性高可用方案"></a>6、稳定性高可用方案</h3><ul><li>软硬件负载均衡</li><li>限流</li><li>容灾</li><li>平滑启动</li></ul><h2 id="十、安全"><a href="#十、安全" class="headerlink" title="十、安全"></a>十、安全</h2><h3 id="1、web安全"><a href="#1、web安全" class="headerlink" title="1、web安全"></a>1、web安全</h3><ul><li>XSS</li><li>CRSF</li><li>SQL注入</li><li>DDOS</li><li>DNS攻击</li><li>脚本注入</li><li>序列化攻击</li><li>中间人攻击</li></ul><h3 id="2、加密解密算法"><a href="#2、加密解密算法" class="headerlink" title="2、加密解密算法"></a>2、加密解密算法</h3><ul><li>对称加密</li><li>非对称加密</li><li>hash算法</li><li>数字签名</li><li>Base64</li></ul><h3 id="3、框架"><a href="#3、框架" class="headerlink" title="3、框架"></a>3、框架</h3><ul><li>Shiro</li><li>SpringSecurity</li></ul><h3 id="4、授权认证"><a href="#4、授权认证" class="headerlink" title="4、授权认证"></a>4、授权认证</h3><ul><li>RBAC</li><li>OAuth2.0</li><li>OIDC</li><li>SAML</li><li>TLS全链路加密</li><li>JWT用户认证</li><li>Check前置检查</li><li>Quota配额管理</li><li>Telemetry遥测报告</li><li>双因素认证（2FA）</li><li>单点登录SSO</li></ul><h2 id="十一、项目管理"><a href="#十一、项目管理" class="headerlink" title="十一、项目管理"></a>十一、项目管理</h2><h3 id="1、开发设计"><a href="#1、开发设计" class="headerlink" title="1、开发设计"></a>1、开发设计</h3><ul><li>DDD领域驱动模型</li><li>Actor模式</li><li>响应式编程</li><li>DODAF2.0</li><li>Serverless</li><li>Service Mesh</li></ul><h3 id="2、项目管理"><a href="#2、项目管理" class="headerlink" title="2、项目管理"></a>2、项目管理</h3><ul><li>代码规范</li><li>敏捷开发</li><li>极限编程</li><li>结对编程</li><li>RUP</li><li>SCRUM</li><li>PDCA循环质量管理</li><li>FMEA管理模式</li></ul><h3 id="3、架构管理"><a href="#3、架构管理" class="headerlink" title="3、架构管理"></a>3、架构管理</h3><ul><li>DevOps</li><li>OpenGroup</li><li>ABSD架构方法论</li><li>架构设计原则</li><li>异地多活</li><li>Knative弹性伸缩</li></ul><h2 id="十二、大数据云计算"><a href="#十二、大数据云计算" class="headerlink" title="十二、大数据云计算"></a>十二、大数据云计算</h2><h3 id="1、流式计算"><a href="#1、流式计算" class="headerlink" title="1、流式计算"></a>1、流式计算</h3><ul><li>storm</li><li>Flink</li><li>KafkaStream</li></ul><h3 id="2、Hadoop"><a href="#2、Hadoop" class="headerlink" title="2、Hadoop"></a>2、Hadoop</h3><ul><li>HDFS</li><li>MapReduce</li><li>Yarn</li><li>Spark</li></ul><h2 id="十三、开发工具"><a href="#十三、开发工具" class="headerlink" title="十三、开发工具"></a>十三、开发工具</h2><ul><li>IDEA</li><li>VSCode</li><li>VIM</li><li>Gitlab</li><li>Navicat</li><li>XShell</li><li>postman</li><li>Filezilla</li><li>Fiddler</li></ul><h2 id="十四、学习资源"><a href="#十四、学习资源" class="headerlink" title="十四、学习资源"></a>十四、学习资源</h2><h3 id="1、视频网站"><a href="#1、视频网站" class="headerlink" title="1、视频网站"></a>1、视频网站</h3><ul><li>B站</li><li>慕课网</li><li>中国大学MOOC网</li></ul><h3 id="2、博客社区"><a href="#2、博客社区" class="headerlink" title="2、博客社区"></a>2、博客社区</h3><ul><li>CSDN</li><li>开源中国</li><li>简书</li><li>思否</li><li>掘金</li><li>博客园</li><li>阿里云社区</li><li>开发者头条</li><li>Medium</li></ul><h3 id="3、技术手册"><a href="#3、技术手册" class="headerlink" title="3、技术手册"></a>3、技术手册</h3><ul><li>W3Cschool</li><li>Runoob.com</li><li>慕课网教程手册</li></ul><h3 id="4、行业资讯"><a href="#4、行业资讯" class="headerlink" title="4、行业资讯"></a>4、行业资讯</h3><ul><li>知乎</li><li>stackoverflow</li></ul><h3 id="5、代码托管"><a href="#5、代码托管" class="headerlink" title="5、代码托管"></a>5、代码托管</h3><ul><li>github</li><li>gitee</li><li>coding</li></ul><h3 id="6、电子书网站"><a href="#6、电子书网站" class="headerlink" title="6、电子书网站"></a>6、电子书网站</h3><ul><li>gitbook</li><li>aibooks</li><li>书栈网</li><li>搬书匠</li><li>鸠摩搜索</li><li>IT-ebooks国外免费</li></ul><h3 id="7、程序员交流网站"><a href="#7、程序员交流网站" class="headerlink" title="7、程序员交流网站"></a>7、程序员交流网站</h3><ul><li>V2EX</li><li>知乎</li></ul><h3 id="8、云服务器"><a href="#8、云服务器" class="headerlink" title="8、云服务器"></a>8、云服务器</h3><ul><li>阿里云</li><li>腾讯云</li><li>百度云</li><li>华为云</li><li>七牛云</li><li>西部数据</li><li>金山云</li></ul><h3 id="9、面试刷题"><a href="#9、面试刷题" class="headerlink" title="9、面试刷题"></a>9、面试刷题</h3><ul><li>LinkCode</li><li>LeetCode</li><li>牛客网</li></ul><h3 id="10、找工作"><a href="#10、找工作" class="headerlink" title="10、找工作"></a>10、找工作</h3><ul><li>100offer</li><li>拉勾网</li></ul><h3 id="11、数据资源下载"><a href="#11、数据资源下载" class="headerlink" title="11、数据资源下载"></a>11、数据资源下载</h3><ul><li>国家数据</li><li>MSDN</li><li>PUDN</li><li>OPSX阿里巴巴开源镜像</li><li>TUNA清华开源软件</li><li>163网易开源镜像</li></ul><h3 id="12、编程外包"><a href="#12、编程外包" class="headerlink" title="12、编程外包"></a>12、编程外包</h3><ul><li>大神部落</li><li>程序员客栈</li><li>码市</li><li>开源众包</li></ul><p>本内容为第一版，后序将继续更新。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java学习路线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java中的日志框架体系梳理（简单直白，故事叙述）</title>
    <link href="/2021/01/02/%E4%B8%83%E3%80%81%E5%B7%A5%E5%85%B7/%E6%97%A5%E5%BF%97/java%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%9B%B4%E7%99%BD%EF%BC%8C%E6%95%85%E4%BA%8B%E5%8F%99%E8%BF%B0%EF%BC%89/"/>
    <url>/2021/01/02/%E4%B8%83%E3%80%81%E5%B7%A5%E5%85%B7/%E6%97%A5%E5%BF%97/java%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%9B%B4%E7%99%BD%EF%BC%8C%E6%95%85%E4%BA%8B%E5%8F%99%E8%BF%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>平时写代码目前也开始慢慢体会到了日志的重要作用。日志算是java工具体系的一个知识点，但又是写代码的时候绕不过去的一个知识点，以故事的形式来对目前市场上常见的一些日志框架进行一个介绍和梳理。旨在从整个日志体系的角度进行一次梳理。</p><h2 id="阶段一："><a href="#阶段一：" class="headerlink" title="阶段一："></a><strong>阶段一：</strong></h2><p>从前有一个程序员，名字叫张三，张三呢，每天矜矜业业，业务能力代码能力都很强。老板就让他负责一个比较复杂的系统。于是张三呢，每天使用System.out.println()，在控制台打印出来一些关键的信息。这时候麻烦来了，项目需要上线了，总不能还要把这些没用的信息输出到控制台吧，于是老板让张三把这些语句全部去掉。这么庞大的系统，张三找呀找，终于把所有的System.out语句全部注释掉了。</p><h2 id="阶段二："><a href="#阶段二：" class="headerlink" title="阶段二："></a><strong>阶段二：</strong></h2><p>过了一段时间呢，项目遇到了一些问题，老板突然想起来张三之前写过System.out的相关语句，觉得有必要把一些关键信息打印出来，于是又让张三把所有的System.out语句添加进来，这下子又把张三忙活的不轻，累了一天终于又改过来了。在找出错误之后，然后再重新去掉。</p><h2 id="阶段三："><a href="#阶段三：" class="headerlink" title="阶段三："></a><strong>阶段三：</strong></h2><p>就这样来回折腾了几次，把张三气的不轻，毕竟需求总是会不断的变化的，于是张三考虑做一个框架，记录系统运行的一些必要的信息，而且日志的内容可以随时打印，也可以随时关闭。这个框架就叫做日志框架，在这里且命名为logging-jar。于是开始投入了运行。</p><h2 id="阶段四："><a href="#阶段四：" class="headerlink" title="阶段四："></a><strong>阶段四：</strong></h2><p>又过了一段时间，张三又发现了问题。在设计的第一代日志框架logging-jar中，总是会把各种各样的运行信息打印出来，这对于张三来说只想要找出一些错误信息，他必须要在很长的一个控制台去寻找。于是张三考虑着如何改进这个框架，比如说把输出信息分类，有异常信息，有错误信息，还有警告信息等等。这对于张三来说，开发起来太便利了。叫做logging-good-jar。</p><h2 id="阶段五："><a href="#阶段五：" class="headerlink" title="阶段五："></a><strong>阶段五：</strong></h2><p>老板一看，张三业务能力这么强，干脆把其他的一些项目也让张三带吧，于是张三又负责了一些其他的项目，但是问题又来了，其他的项目使用的不是张三的日志框架，而是其他的日志框架，怎么办呢？张三考虑着把这个项目的去掉，换成自己的不就可以了嘛，于是张三去掉了别人的，换成了自己的，又废了半天功夫更改了大量的日志api代码。</p><h2 id="阶段六："><a href="#阶段六：" class="headerlink" title="阶段六："></a><strong>阶段六：</strong></h2><p>随着张三业务能力的不断增强，负责的项目也越来越多，发现每次都要更改别人的日志框架换成自己的。实在是麻烦。于是张三考虑定义一些规则接口，其他的任何框架都要有相应的实现方法，这样做的好处就是每次张三就不需要去掉别人的，换成自己的。而是调用相应日志框架的相关实现即可。这个规则就叫做日志门面，也叫做日志框架的抽象层。实现这些规则接口的框架就叫做日志实现框架。</p><p><strong>这种就好比是定义好一个接口，这个接口就是日志门面。而日志实现框架就是接口的实现类。</strong></p><p><img src="https://s3.ax1x.com/2021/01/02/sSuqAO.png"></p><p>目前最受欢迎的就是这么几个。按照使用的角度来说，那就是左边选择一个日志门面，右边选择一个日志实现就好了。就这样他们之前进行了激烈的竞争。</p><blockquote><p><strong>Ceki Gülcü是一个java大佬，一开始发明了log4j，后来把这个捐给了Apache基金会，后来觉得这个功能不够牛，又发明了logback。后来又设计了slf4j</strong>。</p></blockquote><h2 id="阶段七："><a href="#阶段七：" class="headerlink" title="阶段七："></a><strong>阶段七：</strong></h2><p>随着时间的流逝，<strong>slf4j门面和logback日志实现框架</strong>脱颖而出。于是平时张三就用这个了。但是我们需要知道的是在使用的时候其实用的是日志门面slf4j的方法，而不用关心是哪一个实现的。springboot开发团队，一看这个搭配使用起来是真的好，于是就选用了他俩了。既然这么好，干脆我们使用springboot来整合一下他们俩。</p><h3 id="第一步：添加依赖"><a href="#第一步：添加依赖" class="headerlink" title="第一步：添加依赖"></a>第一步：添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第二步：配置日志"><a href="#第二步：配置日志" class="headerlink" title="第二步：配置日志"></a>第二步：配置日志</h3><p>在  src\main\resources 路径下创建logback.xml配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_HOME&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/home&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--控制台日志， 控制台输出 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--文件日志， 按照每天生成日志文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志文件输出的文件名--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--日志文件最大的大小--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>10MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--myibatis log configure--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.apache.ibatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;TRACE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.Connection&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.Statement&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.PreparedStatement&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 日志输出级别 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的这些都是模板代码，你可以直接拿来用。下面我们就直接使用。</p><h3 id="第三步：使用"><a href="#第三步：使用" class="headerlink" title="第三步：使用"></a>第三步：使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/logging&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span></span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HelloService helloService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger logger<br>            = LoggerFactory.getLogger(Hello.class);<br>    <span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        logger.info(<span class="hljs-string">&quot;这是日志框架的输出信息&quot;</span>);<br>        <span class="hljs-keyword">return</span> helloService.test();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果就不展示了。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解java中的几种编码方式？解决乱码问题可能并不麻烦</title>
    <link href="/2020/12/31/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/6%E3%80%81java%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BD%A0%E4%BA%86%E8%A7%A3java%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%AF%E8%83%BD%E5%B9%B6%E4%B8%8D%E9%BA%BB%E7%83%A6/"/>
    <url>/2020/12/31/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/6%E3%80%81java%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BD%A0%E4%BA%86%E8%A7%A3java%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%AF%E8%83%BD%E5%B9%B6%E4%B8%8D%E9%BA%BB%E7%83%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编码的转换通常在IO机制中使用，一个好的编码可以为我们节省很多空间，在某种程度上提高我们应用的效率。由于之前就知道String中的转换方式，还有一些工具类，因此今天就好好的整理一下java中jdk提供的几种转换方式，希望对你有帮助。</p><h2 id="一、编码转换原理"><a href="#一、编码转换原理" class="headerlink" title="一、编码转换原理"></a><strong>一、编码转换原理</strong></h2><h3 id="1、为什么需要编码"><a href="#1、为什么需要编码" class="headerlink" title="1、为什么需要编码"></a><strong>1、为什么需要编码</strong></h3><p>我们知道计算机存储信息的最小单位是一个字节8位，能够表示256个字符。这对于早起的英文来说足够了。即使是加上一些常见符号也足够。于是在1965年美国制定了ASCII编码，主要用于英语和西欧语言，一开始128个，后来加到了256。</p><p>后来随着时间的发展，中国、日本等国的计算机也开始蓬勃发展，于是计算机不仅仅要存储英文了，也开始存储中文。但是中文我们都知道几万个太多了，一个字节肯定放不下。怎么办呢？一个字节表示不下，那就多用几个字节就好了。这样不仅可以表示汉字，还可以避免了与ASCII编码的冲突。这几个字节在存储的时候再转化为bit，完美！<strong>划重点哈，编码解决的就是字节和字符之间的转化问题。</strong></p><h2 id="2、编码方式"><a href="#2、编码方式" class="headerlink" title="2、编码方式"></a><strong>2、编码方式</strong></h2><p>既然是编码，那些大佬早就考虑到了这些问题，并提拱了多种编码方式，常见的有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等。它们规定了转化的规则，按照这个规则就可以让计算机正确的表示我们的字符。</p><p>像GB2312、GBK、UTF-8、UTF-16等很多种方式都可以表示汉字，他们有什么区别呢？</p><h4 id="（1）GB2312"><a href="#（1）GB2312" class="headerlink" title="（1）GB2312"></a>（1）GB2312</h4><p>它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。这个是中国1981年搞出来的。<strong>这种编码是一个汉字两个字节。</strong></p><h4 id="（2）GBK"><a href="#（2）GBK" class="headerlink" title="（2）GBK"></a>（2）GBK</h4><p>它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字。这个是中国在1995年搞出来的，主要是用于GB2312编码的补充。<strong>这种编码依然是一个汉字两个字节。</strong></p><h4 id="（3）Unicode"><a href="#（3）Unicode" class="headerlink" title="（3）Unicode"></a>（3）Unicode</h4><p>上面看到，中国可以做出了一个编码，日本也可以做出来一个编码，时间久了每个国家都有着自己的一套编码，就不可避免的造成冲突。于是Unicode出来了，把所有语言统一起来合成一个规则。<strong>这种编码是定长的字节数。</strong></p><h4 id="（4）UTF8"><a href="#（4）UTF8" class="headerlink" title="（4）UTF8"></a>（4）UTF8</h4><p>既然Unicode是定长的字节数，那么存储一个复杂的汉字可能需要三个字节，但是为了保证是2的幂数集，就会自动扩充为4个字节，别看着一个字节之差，存储的字数多了就会极大的浪费空间。是于是而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</p><p>以上这些编码方式会为每一个汉字或者是字母建立一个编码库，在编码的时候字母和编码一一对应。</p><h3 id="3、为什么会出现乱码？"><a href="#3、为什么会出现乱码？" class="headerlink" title="3、为什么会出现乱码？"></a>3、为什么会出现乱码？</h3><p>这个问题就是因为编码和解码是采用了不同的或者是不兼容的编码方案。比如一个用UTF-8编码的后的字符。再用GBK去解码，由于两个字符集的编码库不一样。同一个汉字在两个编码库的位置也不一样。于是就出现了乱码。</p><h3 id="4、java如何解决乱码问题？"><a href="#4、java如何解决乱码问题？" class="headerlink" title="4、java如何解决乱码问题？"></a><strong>4、java如何解决乱码问题？</strong></h3><p>这个问题其实就是java中如何使用编码规则，因为使用好了编码规则。才可以很好地解决乱码问题。</p><h4 id="（1）IO流"><a href="#（1）IO流" class="headerlink" title="（1）IO流"></a><strong>（1）IO流</strong></h4><p>编码的目的上面已经说了，主要是字节和字符之间的转化。既然涉及到字节和字符很容易我们就能想到java中的IO流。也就是说java中编码的转换其实就是IO流中的类来实现的。</p><p><img src="https://s3.ax1x.com/2020/12/31/rjTKkq.png"></p><p>最核心的就是上面几个类，当然这里只是给出了输入的一部分，还有一些输出的类。</p><h4 id="（2）String"><a href="#（2）String" class="headerlink" title="（2）String"></a><strong>（2）String</strong></h4><p>String类中也提供了一些转码的方法。下面我们会通过实例来说明。为什么String可以实现呢？这是因为String底层保存的其实就是一个一个字节，而且String还有方法直接转化为字符。所以String肯定也能实现。</p><h4 id="（3）Charset"><a href="#（3）Charset" class="headerlink" title="（3）Charset"></a><strong>（3）Charset</strong></h4><p>这个Charset是javaNIO中的一个类，整个流程就是读取数据，然后转化为byte，也就是字符。然后重新编码成字符就OK了。</p><p>下面我们使用代码来实现一下：</p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a><strong>二、代码实现</strong></h2><h3 id="1、IO流"><a href="#1、IO流" class="headerlink" title="1、IO流"></a><strong>1、IO流</strong></h3><p>首先是IO流实现，这种通过输入输出流可以直接的指定编码规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertionFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;./愚公要移山.txt&quot;</span>);<br>FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(file);<br>InputStreamReader inReader = <span class="hljs-keyword">new</span> InputStreamReader(fis, <span class="hljs-string">&quot;gbk&quot;</span>);<br>FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>OutputStreamWriter outReader = <span class="hljs-keyword">new</span> OutputStreamWriter(fos, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>       <span class="hljs-comment">//这种输入gbk，输出utf-8肯定会出现错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、String"><a href="#2、String" class="headerlink" title="2、String"></a><strong>2、String</strong></h3><p>使用string是最方便的，代码也比较简洁，适用于字符串的编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertionString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;<br>String s = <span class="hljs-string">&quot;愚公要移山，码农飞上天&quot;</span>;<br><span class="hljs-comment">// 正常情况下转码的过程</span><br><span class="hljs-keyword">byte</span>[] b = s.getBytes(<span class="hljs-string">&quot;gbk&quot;</span>);<span class="hljs-comment">// 编码</span><br>String sa = <span class="hljs-keyword">new</span> String(b, <span class="hljs-string">&quot;gbk&quot;</span>);<span class="hljs-comment">// 解码</span><br>System.out.println(sa);<br><span class="hljs-comment">// 错误状态下转码的过程</span><br>b = sa.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-comment">// 编码使用utf-8</span><br>sa = <span class="hljs-keyword">new</span> String(b, <span class="hljs-string">&quot;gbk&quot;</span>);<span class="hljs-comment">// 解码使用gbk</span><br>System.err.println(sa);<br>&#125;<br><span class="hljs-comment">//控制台输出：</span><br><span class="hljs-comment">//愚公要移山，码农飞上天</span><br><span class="hljs-comment">//鎰氬叕瑕佺Щ灞憋紝鐮佸啘椋炰笂澶?</span><br></code></pre></td></tr></table></figure><h3 id="3、Charset"><a href="#3、Charset" class="headerlink" title="3、Charset"></a><strong>3、Charset</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertionCharset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>Charset charset = StandardCharsets.UTF_8;<br><span class="hljs-comment">// 从字符集中创建相应的编码和解码器</span><br>CharsetEncoder encoder = charset.newEncoder();<br>CharsetDecoder decoder = charset.newDecoder();<br><span class="hljs-comment">// 构造一个buffer</span><br>CharBuffer charBuffer = CharBuffer.allocate(<span class="hljs-number">64</span>);<br>charBuffer.put(<span class="hljs-string">&#x27;A&#x27;</span>);<br>charBuffer.flip();<br><span class="hljs-comment">// 将字符序列转换成字节序列</span><br>ByteBuffer bb = encoder.encode(charBuffer);<br><span class="hljs-comment">// 将字节序列转换成字符序列</span><br>bb.flip();<br>CharBuffer cb = decoder.decode(bb);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是三种基本的实现方式，当然还有一些其他的，比如Spring中提供的编码转换工具等等。在这里就不说了，因为技术太多，实现的方式也太多，我们就看这几种即可。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>碎知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
      <tag>java基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐使用for-each循环代替for循环</title>
    <link href="/2020/12/28/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8for-each%E5%BE%AA%E7%8E%AF%E4%BB%A3%E6%9B%BFfor%E5%BE%AA%E7%8E%AF/"/>
    <url>/2020/12/28/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8for-each%E5%BE%AA%E7%8E%AF%E4%BB%A3%E6%9B%BFfor%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文基于《Effective java》第三版第58条</strong></p></blockquote><p>for循环是平时写代码用的最多的，但是之前看《effectivejava》大佬在某些场景写并不推荐。结合着自己之前刷算法题的经历。收益匪浅。</p><h2 id="一、for循环的缺点"><a href="#一、for循环的缺点" class="headerlink" title="一、for循环的缺点"></a>一、for循环的缺点</h2><p>在以往遍历元素的时候，我们通常采用以下的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//1、数组元素</span><br><span class="hljs-keyword">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//数组的遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num.length;i++) <br>System.out.println(num[i]);<br><span class="hljs-comment">//2、对象元素</span><br>ArrayList&lt;Person&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>lists.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>));<br>lists.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>));<br>lists.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;愚公要移山&quot;</span>));<br><span class="hljs-comment">//对象元素的遍历</span><br><span class="hljs-keyword">for</span>(Iterator&lt;Person&gt; it=lists.iterator();it.hasNext();) &#123;<br>Person p = it.next();<br>System.out.println(p.getName());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法看起来还不错，但是却并不完美。我们来分析一下，有什么缺点。然后给出解决方案。</p><h3 id="问题1：迭代器或索引多次出现，容易造成使用错误"><a href="#问题1：迭代器或索引多次出现，容易造成使用错误" class="headerlink" title="问题1：迭代器或索引多次出现，容易造成使用错误"></a>问题1：迭代器或索引多次出现，容易造成使用错误</h3><p>从上面两种遍历的代码上来看，对于数组元素是通过索引i来遍历的，但是整个for循环出现了四次i，对于对象元素是通过迭代器it来遍历的，但是整个for循环出现了三次it。在for循环遍历元素的时候，就有多次机会使用了错误的变量。而且有时候这些错误编译器无法发现。对整个应用系统造成无法预知的错误。</p><h3 id="问题2：遍历对象元素时，需要注意容器类型"><a href="#问题2：遍历对象元素时，需要注意容器类型" class="headerlink" title="问题2：遍历对象元素时，需要注意容器类型"></a>问题2：遍历对象元素时，需要注意容器类型</h3><p>比如我们这里使用的是list，当然还有可能是其他容器类型，这些类型在更改时比较麻烦。</p><h3 id="问题3：嵌套迭代抛出异常"><a href="#问题3：嵌套迭代抛出异常" class="headerlink" title="问题3：嵌套迭代抛出异常"></a>问题3：嵌套迭代抛出异常</h3><p>这种情况比较复杂一些，先来搞个例子。比如说，我们想要列举每种花，这些花有两种属性一种是颜色，一种是大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-comment">//枚举颜色和尺寸</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, BLUE, BLACK &#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span> </span>&#123; ONE, TWO, THREE, FOUR, FIVE,<br>SIX, SEVEN, EIGHT,NINE, TEN&#125;<br><span class="hljs-comment">//定义花</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flower</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Flower</span><span class="hljs-params">(Color color, Size size)</span> </span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Color&gt; colors = Arrays.asList(Color.values());<br>Collection&lt;Size&gt; sizes = Arrays.asList(Size.values());<br>List&lt;Flower&gt; flowers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">//for循环添加所有的花和尺寸</span><br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; color = colors.iterator(); color.hasNext(); ) &#123;<br><span class="hljs-keyword">for</span> (Iterator&lt;Size&gt; size = sizes.iterator(); size.hasNext(); ) &#123;<br>flowers.add(<span class="hljs-keyword">new</span> Flower(color.next(), size.next()));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看似人畜无害，现在我们运行一波。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.NoSuchElementException<br>at java.util.AbstractList$Itr.next(Unknown Source)<br>at com.f2.Main.main(Main.java:<span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><p>是不是感觉有点奇怪，好像双重循环遍历没啥问题，但是出现了异常，原因是外部的Color迭代器调用了多次，第一层for循环被调用了，但是又在第二层for循环内部被调用了，所以color的next被调用完了。所以出现了NoSuchElementException。但是有时候也不会出现这种情况，场景是外部循环迭代器调用的次数刚好是内部调用的n倍。</p><h3 id="问题4：嵌套迭代不抛异常，但是结果不正确"><a href="#问题4：嵌套迭代不抛异常，但是结果不正确" class="headerlink" title="问题4：嵌套迭代不抛异常，但是结果不正确"></a>问题4：嵌套迭代不抛异常，但是结果不正确</h3><p>这种情况是外部循环迭代器调用的次数刚好是内部调用的n倍。我们再来个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-comment">//枚举颜色</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, BLUE, BLACK &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Color&gt; colors = Arrays.asList(Color.values());<br><span class="hljs-comment">//两层for循环</span><br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; c1 = colors.iterator(); c1.hasNext(); ) &#123;<br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; c2 = colors.iterator(); c2.hasNext(); ) &#123;<br>System.out.println(c1.next()+<span class="hljs-string">&quot; &quot;</span>+c2.next());<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在对颜色进行for循环遍历，一共两层for循环，因为一共有四种颜色，两层for循环应该是打印16个结果。现在运行一遍看看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">RED RED<br>GREEN GREEN<br>BLUE BLUE<br>BLACK BLACK<br></code></pre></td></tr></table></figure><p>没错，确实是打印了四条。原因和<strong>问题三</strong>是一样的。有一种方式可以很好地解决这种嵌套的问题。</p><h3 id="嵌套迭代问题解决："><a href="#嵌套迭代问题解决：" class="headerlink" title="嵌套迭代问题解决："></a>嵌套迭代问题解决：</h3><p>直接看代码。既然是外部的迭代器it在内部使用了，那我在内部和外部之间用一个变量缓存起来不久好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-comment">//枚举颜色</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, BLUE, BLACK &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Color&gt; colors = Arrays.asList(Color.values());<br><span class="hljs-comment">//for循环</span><br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; c1 = colors.iterator(); c1.hasNext(); ) &#123;<br><span class="hljs-comment">//用一个变量缓存起来</span><br>Color c = c1.next();<br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; c2 = colors.iterator(); c2.hasNext(); ) &#123;<br>System.out.println(c+<span class="hljs-string">&quot; &quot;</span>+c2.next());<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在再来运行，就可以很好地得出16种结果了。这种方式也比较不错，但是却不能很好地解决问题1和问题2。因此，为了解决这一现象，大佬Joshua Bloch在书中提出，推荐使用for-each循环来代替for循环。</p><h2 id="二、for-each循环"><a href="#二、for-each循环" class="headerlink" title="二、for-each循环"></a>二、for-each循环</h2><p>既然作者推荐使用for-each循环，我们看看他有什么好处。是如何解决上面的问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-comment">//枚举颜色和尺寸</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, BLUE, BLACK &#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span> </span>&#123; ONE, TWO, THREE, FOUR, FIVE,<br>SIX, SEVEN, EIGHT,NINE, TEN&#125;<br><span class="hljs-comment">//定义花</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flower</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Flower</span><span class="hljs-params">(Color color, Size size)</span> </span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Color&gt; colors = Arrays.asList(Color.values());<br>Collection&lt;Size&gt; sizes = Arrays.asList(Size.values());<br>List&lt;Flower&gt; flowers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">//for-each循环</span><br><span class="hljs-keyword">for</span> (Color color:colors) &#123;<br><span class="hljs-keyword">for</span> (Size size:sizes ) &#123;<br>flowers.add(<span class="hljs-keyword">new</span> Flower(color, size));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看里面的for-each循环。上面的问题就全都解决了。好吧，可能你会感觉，就这？还有一个好处还没说，再往下看。</p><p>for-each 循环不仅允许遍历集合和数组，还允许遍历实现 Iterable 接口的任何对象，该接口由单个方法组成。接<br>口定义如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><span class="hljs-comment">// Returns an iterator over the elements in this iterable</span><br><span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果必须从头开始编写自己的 Iterator 实现，那么实现 Iterable 会有点棘手，但是如果你正在编写表示一组元素<br>的类型，那么你应该强烈考虑让它实现 Iterable 接口，甚至可以选择不让它实现 Collection 接口。这允许用户使用for-each 循环遍历类型，他们会永远感激不尽的 。</p><p>但是，有三种常见的情况是你不能分别使用 for-each 循环的:</p><p><strong>（1）有损过滤（</strong>Destructive filtering）：如果需要遍历集合，并删除指定选元素，则需要使用显式迭代器，以便可以调用其 remove 方法。 通常可以使用在 Java 8 中添加的 Collection 类中的 removeIf 方法，来避免显式遍历。</p><p><strong>（2）转换</strong>：如果需要遍历一个列表或数组并替换其元素的部分或全部值，那么需要列表迭代器或数组索引来替换元素的值。</p><p><strong>（3）并行迭代</strong>：如果需要并行地遍历多个集合，那么需要显式地控制迭代器或索引变量，以便所有迭代器或索引变量都可以同步进行 。</p><p>如果发现自己处于这些情况中的任何一种，请使用传统的 for 循环，并警惕本条目中提到的陷阱 。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>写代码的建议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我在一个构造方法里面写了30个参数，老板看了想骂人</title>
    <link href="/2020/12/26/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%88%91%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E5%86%99%E4%BA%8630%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%81%E6%9D%BF%E7%9C%8B%E4%BA%86%E6%83%B3%E9%AA%82%E4%BA%BA/"/>
    <url>/2020/12/26/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%88%91%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E5%86%99%E4%BA%8630%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%81%E6%9D%BF%E7%9C%8B%E4%BA%86%E6%83%B3%E9%AA%82%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文基于《Effective java》第二条</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般我们写参数如果写个一两个，那就可以了，如果写七八个，那就有点难受了。如果写十几个？尼玛，难受，我要去缓缓。</p><p><img src="https://s3.ax1x.com/2020/12/26/rhBVgK.png"></p><p>于是乎，一种新的方法策略运用而生。那就是builder模式，在构造方法的参数过多时，可以方便的进行创建一个类对象。所以本文的中心主旨一句话总结：<strong>当构造方法的参数过多时，推荐使用builder模式</strong></p><p>既然推荐使用builder模式，那我们一个一个来，分析一下如果不使用builder模式有什么缺点。</p><h2 id="一、传统方式的缺点"><a href="#一、传统方式的缺点" class="headerlink" title="一、传统方式的缺点"></a>一、传统方式的缺点</h2><h3 id="1、可伸缩构造方法"><a href="#1、可伸缩构造方法" class="headerlink" title="1、可伸缩构造方法"></a>1、可伸缩构造方法</h3><p>可伸缩构造方法就是我们平时书写最常见的那种，请看下文代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">//可选</span><br><span class="hljs-comment">//构造函数1：默认构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br><span class="hljs-comment">//构造方法2：必要字段构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-comment">//构造方法3：全部字段构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> sclass, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">float</span> weight, <span class="hljs-keyword">float</span> score)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">this</span>.sclass = sclass;<br><span class="hljs-keyword">this</span>.height = height;<br><span class="hljs-keyword">this</span>.weight = weight;<br><span class="hljs-keyword">this</span>.score = score;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面如果我们要创建一个Student类，一般这样创建，看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//1、可伸缩构造方法</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;愚公要移山&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1</span>,<span class="hljs-number">175</span>,<span class="hljs-number">120</span>,<span class="hljs-number">99</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们列举了一个具有七个字段的例子，比较容易理解，现在我们来分析一下，他有什么缺点：</p><h4 id="缺点1：反转字段，编译器不会报错"><a href="#缺点1：反转字段，编译器不会报错" class="headerlink" title="缺点1：反转字段，编译器不会报错"></a>缺点1：反转字段，编译器不会报错</h4><p>比如上面的字段里面有一个weight和一个score，都是float类型，如果再new一个Student类时，不小心写反了，编译器不会察觉。</p><h4 id="缺点2：难以理解"><a href="#缺点2：难以理解" class="headerlink" title="缺点2：难以理解"></a>缺点2：难以理解</h4><p>这里只是七个字段，如果有十几个，我们就需要不断地去Student类中去查看，看看第几个参数应该写哪些东西，实在是比较麻烦。用户在看到这个Student(2,”愚公要移山”,18,1,175,120,99)无法理解每一个字段属性代表的是什么含义。</p><h4 id="缺点3：不想设置的参数，却不得不设置值"><a href="#缺点3：不想设置的参数，却不得不设置值" class="headerlink" title="缺点3：不想设置的参数，却不得不设置值"></a>缺点3：不想设置的参数，却不得不设置值</h4><p>有时候我们的Student只想着设置ID、name和age字段，其他的无关紧要，但是这种模式必须要设置所有的属性值。</p><p>既然上面有这些缺点，我们可能还想到另外一种方式，那就是javaBean。</p><h3 id="2、javaBean模式"><a href="#2、javaBean模式" class="headerlink" title="2、javaBean模式"></a>2、javaBean模式</h3><p>先看javaBean模式如何写的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">//可选</span><br><span class="hljs-comment">//构造函数1：默认构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">//getter和setter方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> id;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> age;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSclass</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> sclass;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSclass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sclass)</span> </span>&#123;<span class="hljs-keyword">this</span>.sclass = sclass;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> height;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height)</span> </span>&#123;<span class="hljs-keyword">this</span>.height = height;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> weight;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">float</span> weight)</span> </span>&#123;<span class="hljs-keyword">this</span>.weight = weight;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> score;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">float</span> score)</span> </span>&#123;<span class="hljs-keyword">this</span>.score = score;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式，看起来还比较舒服，只是设置了相应的getter和setter方法。再来看看如何使用这种方式去new一个Student类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//2、javaBean模式</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>student1.setId(<span class="hljs-number">1</span>);<br>student1.setName(<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>student1.setSclass(<span class="hljs-number">1</span>);<br>student1.setWeight(<span class="hljs-number">180</span>);<br>student1.setHeight(<span class="hljs-number">175</span>);<br>student1.setScore(<span class="hljs-number">100</span>);<br>student1.setAge(<span class="hljs-number">20</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看起来还可以，不过这只是我自己一个一个敲出来的。实际在用的时候就知道同样恶心了，现在来总结一波他的缺点。</p><h4 id="缺点1：构造过程中-JavaBean可能处于不一致的状态"><a href="#缺点1：构造过程中-JavaBean可能处于不一致的状态" class="headerlink" title="缺点1：构造过程中 JavaBean可能处于不一致的状态"></a>缺点1：构造过程中 JavaBean可能处于不一致的状态</h4><p>JavaBeans 模式本身有严重的缺陷。由于构造方法在多次调用中被分割，所以在构造过程中 JavaBean<br>可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来执行一致性的选项。在不一致的状态下尝试使用对象可能会导致与包含 bug 的代码大相径庭的错误，因此很难调试。</p><p>说一下我对其的理解，在上面的例子中，我们的student1对象被多次调用了set方法，但是可能有时候在用到这个bean时，剩下的setter方法还没有做完，于是再次调用时发现同一个javaBean呈现出了两种状态。于是处于一种不一致的状态。</p><h4 id="缺点2：无法保证javaBean的不可变性"><a href="#缺点2：无法保证javaBean的不可变性" class="headerlink" title="缺点2：无法保证javaBean的不可变性"></a>缺点2：无法保证javaBean的不可变性</h4><p>使用第一种模式可伸缩构造方法实例化之后不会更改可变性，所有的数据都是确定好了的。也可以保证线程安全。但是提供了setter方法，就不能保证了。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//2、javaBean模式</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>student1.setId(<span class="hljs-number">1</span>);<br>student1.setName(<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>student1.setSclass(<span class="hljs-number">1</span>);<br>student1.setWeight(<span class="hljs-number">180</span>);<br>student1.setHeight(<span class="hljs-number">175</span>);<br>student1.setScore(<span class="hljs-number">100</span>);<br>student1.setAge(<span class="hljs-number">20</span>);<br>System.out.println(student1.getName());<br>student1.setName(<span class="hljs-string">&quot;冯冬冬&quot;</span>);<br>System.out.println(student1.getName());<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出结果：愚公要移山  冯冬冬</span><br></code></pre></td></tr></table></figure><p>可以看到，我们可以对Student对象设置多次name，前后是不一致的状态。</p><p>既然前面两种都存在各种各样的问题。现在我们再来看今天的主题builder模式，</p><h2 id="二、builder模式"><a href="#二、builder模式" class="headerlink" title="二、builder模式"></a>二、builder模式</h2><p>还是老样子，我们先看看builder模式长得什么样子。再来分析一下他的优缺点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">// 可选</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = builder.id;<br><span class="hljs-keyword">this</span>.name = builder.name;<br><span class="hljs-keyword">this</span>.age = builder.age;<br><span class="hljs-keyword">this</span>.sclass = builder.sclass;<br><span class="hljs-keyword">this</span>.height = builder.height;<br><span class="hljs-keyword">this</span>.weight = builder.weight;<br><span class="hljs-keyword">this</span>.score = builder.score;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">// 可选</span><br><span class="hljs-comment">// 必要参数的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setSclass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sclass)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.sclass = sclass;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.height = height;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">float</span> weight)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.weight = weight;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">float</span> score)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.score = score;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 对外提供的</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码是在内部构造了一个Builder类，然后我们看看如何去使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//3、Builder模式</span><br>Student stu = <span class="hljs-keyword">new</span> Student.Builder(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;愚公要移山&quot;</span>)<br>.setAge(<span class="hljs-number">20</span>)<br>.setHeight(<span class="hljs-number">175</span>)<br>.setSclass(<span class="hljs-number">1</span>)<br>.setScore(<span class="hljs-number">100</span>)<br>.setWeight(<span class="hljs-number">100</span>).build();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这本书中对其的缺点也进行了介绍，很直观可以看到，Student类中的代码量增加了很多。但是Student类，我们只需要写一次，这却为我们创建对象带来了方便。</p><h3 id="优点1：不存在反转字段的情况"><a href="#优点1：不存在反转字段的情况" class="headerlink" title="优点1：不存在反转字段的情况"></a>优点1：不存在反转字段的情况</h3><p>上面可以看出，每次添加新字段值的时候是通过set方式进行的。具有javaBean的优点。</p><h3 id="优点2：灵活构造参数"><a href="#优点2：灵活构造参数" class="headerlink" title="优点2：灵活构造参数"></a>优点2：灵活构造参数</h3><p>我们把必要的字段一写，那些非必要的字段我们可以自己选择是不是要set。</p><h3 id="优点3：不存在不一致状态"><a href="#优点3：不存在不一致状态" class="headerlink" title="优点3：不存在不一致状态"></a>优点3：不存在不一致状态</h3><p>使用builder模式，对象的创建必须要等到build完成才可以。</p><h3 id="优点4：使用灵活"><a href="#优点4：使用灵活" class="headerlink" title="优点4：使用灵活"></a>优点4：使用灵活</h3><p>单个 builder 可以重复使用来构建多个对象。 builder 的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在性能关键的情况下可能会出现问题。而且，builder 模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。</p><p>但是，如果从构造方法或静态工厂开始，并切换到 builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂就会面临尴尬的处境。因此，所以，最好从一开始就创建一个 builder。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们的参数比较多时，builder模式是一个不错的选择，如果比较少时，由于Builder本身也是个对象占用一定的资源，所以还是使用可伸缩或者是javaBean的那种模式比较好。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>写代码的建议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么MongoDB使用B树，而Mysql使用B+树？（干活总结）</title>
    <link href="/2020/12/26/%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/3%E3%80%81MongoDB/%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%EF%BC%8C%E8%80%8CMysql%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F%EF%BC%88%E5%B9%B2%E6%B4%BB%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2020/12/26/%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/3%E3%80%81MongoDB/%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%EF%BC%8C%E8%80%8CMysql%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F%EF%BC%88%E5%B9%B2%E6%B4%BB%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《MongoDB学习系列》专栏中</strong></p></blockquote><p>本文献给准备面试或者是还在面试的你。常见面试题，送分题目，不拿白不拿。</p><h2 id="一、B树和B-树的区别"><a href="#一、B树和B-树的区别" class="headerlink" title="一、B树和B+树的区别"></a><strong>一、B树和B+树的区别</strong></h2><p>很明显，我们想向弄清楚原因就要知道B树和B+树的区别。为了不长篇大论。我们直接给出他们的形式总结他们的特点。</p><h3 id="1、B树"><a href="#1、B树" class="headerlink" title="1、B树"></a><strong>1、B树</strong></h3><p>B树是一种自平衡的搜索树，形式很简单：</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRAYQ.png"></p><p>这就是一颗B-树。针对我们这个问题的最核心的特点如下：</p><p><strong>（1）多路，非二叉树</strong></p><p><strong>（2）每个节点既保存索引，又保存数据</strong></p><p><strong>（3）搜索时相当于二分查找</strong></p><p>其他的基本上都是一些常见的数据结构，假定都已经了解了B树相关的结构。</p><h3 id="2、B-树"><a href="#2、B-树" class="headerlink" title="2、B+树"></a><strong>2、B+树</strong></h3><p>B+树是B树的变种</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRkFg.png"></p><p>最核心的特点如下：</p><p><strong>（1）多路非二叉</strong></p><p><strong>（2）只有叶子节点保存数据</strong></p><p><strong>（3）搜索时相当于二分查找</strong></p><p><strong>（4）增加了相邻接点的指向指针。</strong></p><p>从上面我们可以看出最核心的区别主要有俩，</p><p><strong>一个是数据的保存位置：B树保存在所有的节点中，B+树保存在叶子节点</strong></p><p><strong>一个是相邻节点的指向：B树叶子节点之间没有指针，B+树有</strong></p><p>这里区别分别给B树和B+树带来了什么好处呢？其实对于数据库来说，选用什么数据结构无非就是为了增删改查和存储更加高效，因为找特点时也要从这个点去回答。</p><h3 id="3、从区别找特点"><a href="#3、从区别找特点" class="headerlink" title="3、从区别找特点"></a><strong>3、从区别找特点</strong></h3><h4 id="第一：查找元素"><a href="#第一：查找元素" class="headerlink" title="第一：查找元素"></a>第一：查找元素</h4><p>（1）B树的数据保存在所有节点，查询复杂度最好是 O(1)。</p><p>（2）B+树的数据保存在叶子节点，查询时间复杂度固定是O(log(n))</p><h4 id="第二：区间查找"><a href="#第二：区间查找" class="headerlink" title="第二：区间查找"></a>第二：区间查找</h4><p>（1）B树每个节点 key 和 data 在一起，则无法区间查找。</p><p>（2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等</p><h4 id="第三：存储"><a href="#第三：存储" class="headerlink" title="第三：存储"></a>第三：存储</h4><p>（1）B树每个节点即保存数据又保存索引，所以每一节点特别大，这一层所有节点加起来数据量将非常大。磁盘每次IO一定量的数据，对于Mysql来说如何衡量查询效率呢？就是磁盘IO次数。既然B树每一层特别大，那每一层就需要对数据分开从而进行多次IO操作。所有Mysql不用。</p><p>（2）B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确，所以不需要用B+树。</p><p>有了他们的区别之后，现在我们再来解释这个原因就好多了。</p><h2 id="二、原因解释"><a href="#二、原因解释" class="headerlink" title="二、原因解释"></a><strong>二、原因解释</strong></h2><p>上面解释了不使用的原因，我们再来看为什么Mysql使用B+树，而MongoDB使用B树，想要解释原因，我们还必须要了解一下MongoDB和Mysql的基本概念。</p><h3 id="1、MongoDB"><a href="#1、MongoDB" class="headerlink" title="1、MongoDB"></a><strong>1、MongoDB</strong></h3><p>MongoDB 是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据。比如之前我们的表可能有用户表、订单表、购物篮表等等，还要建立他们之间的外键关联关系。但是类Json就不一样了。</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRiTS.png"></p><p>我们可以看到这种形式更简单，通俗易懂。那为什么 MongoDB 使用B-树呢？</p><p><strong>MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql</strong>。</p><h3 id="2、Mysql"><a href="#2、Mysql" class="headerlink" title="2、Mysql"></a><strong>2、Mysql</strong></h3><p><strong>Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。</strong></p><p>还有一点，B+树只有叶子节点保存数据，所以每一节点比较小，每一层所有节点加起来数据量也相对比较小。磁盘每次IO一定量的数据，对于Mysql来说。既然B+树每一层小，那每一层只需要少量IO操作。</p><p>这俩区别的核心如果你能看懂B-树和B+树的区别就很容易理解。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>MongoDB专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>MongoDB</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们到底该如何学习《数据结构与算法》</title>
    <link href="/2020/12/24/%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/24/%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《手牵手一起学数据结构》专栏中</strong></p></blockquote><h2 id="前言：我们到底该不该学习算法与数据结构？"><a href="#前言：我们到底该不该学习算法与数据结构？" class="headerlink" title="前言：我们到底该不该学习算法与数据结构？"></a>前言：我们到底该不该学习算法与数据结构？</h2><h3 id="1、真的应该学习"><a href="#1、真的应该学习" class="headerlink" title="1、真的应该学习"></a>1、真的应该学习</h3><p>这个问题本身就不是个问题，所有人都在强调数据结构与算法比较重要，但是好像平时也没用到，无法直观的去感受它的重要性，于是把学习重心放在了常见的哪些框架身上，似乎只要熟悉了哪些框架的API，编程就会所向披靡。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZhJU.gif"></p><p>我举一个我自身的例子，我本科期间想做一个APP，主要是在线预约的功能，既然是在线预约，用户多了之后那就需要排队，当时也不管三七二十一，不管哪种结构，那就先试试ArrayList，当然这种数据结构也能解决，但是当真正操作其增删改查的时候才发现ArrayList确实是比较麻烦一点。</p><p>在网上开始问各种大佬，统一回复的一句话是，你现在学数据结构了吗？你数据结构咋学的？现在想想真的是留下啦悔恨的眼泪。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZfiT.gif"></p><p>既然数据结构与算法重要，到底哪个地方重要呢？下面就来说说：</p><h3 id="2、重要性体现"><a href="#2、重要性体现" class="headerlink" title="2、重要性体现"></a>2、重要性体现</h3><h4 id="第一：面试"><a href="#第一：面试" class="headerlink" title="第一：面试"></a>第一：面试</h4><p>面试确实是第一个体现的点，因为你会发现，面试外企的时候他们第一件事就是啥都不问，上来就是几道算法题。包括国内的字节跳动。现在的阿里、腾讯、华为、美团。凡是大家知道的那些大厂基本上上来就是先敲代码。可以看出国内外大厂对于算法与数据结构的看重。</p><h4 id="第二：工作"><a href="#第二：工作" class="headerlink" title="第二：工作"></a>第二：工作</h4><p>现在的大厂api框架基本上背后的逻辑就是基于算法实现的。其实算法的种类有很多，比如说机器学习、神经网络算法，还有java中的排序算法，互联网的商品推荐、股票预测其背后的逻辑都是算法。就算是熟悉的那些框架，背后的逻辑也是数据结构与算法。我们敲代码解决问题的过程当中也是算法的集中体现。</p><h4 id="第三：学习"><a href="#第三：学习" class="headerlink" title="第三：学习"></a>第三：学习</h4><p>学习数据结构与算法的目的，别人我不知道，对我目前来说，是想了解哪些常见框架，常见机制背后的运行逻辑。进而为以后创造一个更加强大的产品做铺垫。任何一个新东西，都是先了解，再模仿，最后再创造的过程。</p><h4 id="第四：应付学业"><a href="#第四：应付学业" class="headerlink" title="第四：应付学业"></a>第四：应付学业</h4><p>我之前大学学习这门课的时候，学分比重还是比较大的，好几年过去了，不知道现在变没变。不过最起码考研或者是期末考试，这门课都是必须要学习的一门课。可见学校也比较重视。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2Z5z4.gif"></p><h2 id="一、算法与数据结构到底是个什么东东？"><a href="#一、算法与数据结构到底是个什么东东？" class="headerlink" title="一、算法与数据结构到底是个什么东东？"></a>一、算法与数据结构到底是个什么东东？</h2><p>在这里我不想去解释哪些常见的名词了，像什么是数据项、数据对象、元素等等这些概念。稍微有点基础的人，对这些概念都应该很清楚，毕竟都是中国人。我主要想说一下，我们到底该如何理解数据结构与算法。</p><h3 id="1、什么是数据结构？"><a href="#1、什么是数据结构？" class="headerlink" title="1、什么是数据结构？"></a>1、什么是数据结构？</h3><p>高中的时候都学习过化学，什么水的结构，碳原子的结构，这些分子、原子之间不是杂乱无章的，我们总是可以归纳分析出一些规律。对于计算机中的数据元素而言，这些数据元素也不是孤立的，总是有一种或者是几种的内在联系。</p><blockquote><p>数据结构：数据元素相互之间一种或者多种关系的表示</p></blockquote><p>既然数据元素之间有某种关系，那这种关系到底是什么呢？这里直接总结了一下。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2Z2d0.png"></p><p>可以看出分两类，表示了这些数据元素之间的关系。我们在学习数据结构的时候，其实就是学习这些数据元素到底有哪些关系。</p><h3 id="2、什么是算法"><a href="#2、什么是算法" class="headerlink" title="2、什么是算法"></a>2、什么是算法</h3><p>宋丹丹和赵本山有过一个小品，说如何把大象关进冰箱里。第一步先把冰箱门打开，第二步把大象装进去，第三步，把冰箱门关上。整个简单的流程完美的体现了算法的思想。标准定义：</p><blockquote><p>算法：解决问题的步骤的描述</p></blockquote><p>就这么几个字，其实就是描述过程的。当然解决问题的方法有很多，因此算法也有很多种，就比说我们常见的排序算法，就简简单单为了从小到大排序，哪些科学家们活活的搞出了十几种。每一种排序方式都是一个算法。</p><h3 id="3、数据结构与算法的关系（重点）"><a href="#3、数据结构与算法的关系（重点）" class="headerlink" title="3、数据结构与算法的关系（重点）"></a>3、数据结构与算法的关系（重点）</h3><p>我们经常会听到有人说：程序=算法+数据结构，某位大佬科学家就提出了这几个字还得了图灵奖。大学的时候知道这件事还让我一度怀疑图灵奖也不过如此。嘿嘿，不过现在不敢说了，看的越多，越觉得这个简单地公式蕴含了无数的道理。</p><p>既然是讨论他们之间的关系。我们再来看个例子，毕竟例子各位才理解的更加清楚。假如我国要在多个城市之间新建一条高铁。要求是能够链接多个城市，而且成本最低。OK，好了，现在就这么个需求，我们来分析。</p><p>第一目的：修建铁路</p><p>第二要求：连通所有城市，成本最低。</p><p>我们一下子就能想到这是一个最小生成树问题，假如把每一个城市看成一个点，把城市之间的成本看成连线数字，就是找出来一个联通线。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2eAFf.png"></p><p>目的其实就是为了找上图中的那条黑线。这里不是专门讲这个知识体系的。现在我们使用流程图看看，如果遇到了一个问题，我们是如何去使用程序去解决的。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZRoV.png"></p><p>从上图可以看出，为了要解决一个问题，首先我们要分析问题，然后确定解决思路，接下来设计或者是选择已有的算法，再然后就是确定实现的数据结构，最后就是代码的实现与优化。</p><p>数据结构在其中的位置可以看出，是为了更好地实现某种或者是某类算法。在讨论这门课的时候也会结合在一起去学习。</p><h2 id="二、学习数据结构与算法我们最应该关注什么？"><a href="#二、学习数据结构与算法我们最应该关注什么？" class="headerlink" title="二、学习数据结构与算法我们最应该关注什么？"></a>二、学习数据结构与算法我们最应该关注什么？</h2><p>​    如果我们想要学好数据结构与算法，首先脑海中要时刻记住两个关键词汇，<strong>时间效率和空间效率</strong>。这个两个词汇贯穿了整个数据结构与算法的知识体系。</p><p>​    数据结构可以助算法实现问题提供基础，算法为了解决某一问题必须要时间够快，空间足够节省。就好比我们为了能够在茫茫人海当中找寻另一半一样。首先时间要足够快，不能一个一个找，然后我们不可能把茫茫人海所有人的全部信息全给保存了，所以空间上还要足够节省。</p><p>​    <strong>那什么是时间效率和空间效率呢？通俗的理解就是：我们使用两个不同的程序去解决同一个问题，时间短的说明时间效率高，消耗空间小的说明空间效率高。</strong></p><p>​    我们在研究数据结构与算法的时候，其实就是选择不同的数据结构和不同的算法解决某一问题的同时尽可能的提升计算机的时间效率和空间效率。</p><h3 id="1、首先看时间复杂度："><a href="#1、首先看时间复杂度：" class="headerlink" title="1、首先看时间复杂度："></a>1、首先看时间复杂度：</h3><p>​    想要了解时间复杂度，就需要先了解时间频度。一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或<strong>时间频度</strong>。记为T(n)。</p><p>说白了时间复杂度就是描述时间的规模，比如说时间频度是T(n),时间复杂度就是O(n)。时间频度是T(n+n)的时候,时间复杂度还是O(n)。也就是他的时间规模就是n这个层次了。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度**。</p><p><strong>常见的算法的时间 复杂度之间的关系为：</strong></p><p><strong>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</strong> </p><p>举个例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">a=<span class="hljs-number">0</span>；                    <span class="hljs-comment">//（1）</span><br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)       <span class="hljs-comment">//（2）</span><br>      <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)       <span class="hljs-comment">//（3）</span><br>       a++；             <span class="hljs-comment">//（4）</span><br></code></pre></td></tr></table></figure><p>语句（1）执行1次，</p><p>语句（2）执行n次</p><p>语句（3）执行n2次</p><p>语句（4）执行n2次</p><p>T(n) = 1+n+2n2= O(n2)</p><h3 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h3><p>空间复杂度就比较容易理解了，空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个空间规模，我们用 S(n) 来定义。</p><p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，</p><h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><p>在本文中，首先讨论了数据结构与算法的重要性，然后给出了数据结构与算法的理解，最后就是在学习数据结构与算法时，我们最应该关注的点。其中通过数据结构与算进的关系解决某一问题的流程是重点。在以后的文章中，也会惯用这一思路。这个思路是我在刷了力扣几百道题时总结出来的。</p><p>举个例子来说一下：</p><p>面试中经常会遇到一道题，那就是实现LRU（最近最久未使用）。我们按照上面的流程结构可以很清楚的把问题给解决掉，而不是死记硬背哪些现有的代码，比如第一步分析问题，问题是实现最近最久未使用的算法，我们可以画图来看一下到底是个什么问题，然后就是确定算法，比如说第一步我们该干嘛，第二步该干嘛等等。接下来确定数据结构的时候，比如说可以自定义Node实现，还有java中为我们提供的LinkedHashMap等等。最后就是根据数据结构的特点通过我们分析的算法流程去实现。</p><p>这样是不是有点清晰了。本专栏将持续推出。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>数据结构专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
