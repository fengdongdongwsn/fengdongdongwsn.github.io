<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>为什么说不推荐使用finalize方法</title>
    <link href="/2021/01/14/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8finalize%E6%96%B9%E6%B3%95/"/>
    <url>/2021/01/14/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8finalize%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>这个问题是我在刷牛客面经的时候遇到的，还特地整理在了我的常规面试题文档中，所以这道题主要考察的就是finalize方法的影响。</p><p>java提供了一个finalize方法，可以帮助我们进行资源释放，类似于C++中的析构函数。但是目前普遍的认识是不要使用，为什么呢？就是因为对java虚拟机的垃圾回收有影响。这篇文章对其进行一个说明。</p><h2 id="一、为什么有影响"><a href="#一、为什么有影响" class="headerlink" title="一、为什么有影响"></a>一、为什么有影响</h2><p>我们都知道一个对象GCRoot不可达，java虚拟机就认为是垃圾对象，就会进行垃圾回收，但是如果这个对象包含了finalize函数，性质就不一样了。怎么不一样了呢？</p><p>java虚拟机在进行垃圾回收的时候，一看到这个对象类含有finalize函数，就把这个函数交给FinalizerThread处理，而包含了这个finalize的对象就会被添加到FinalizerThread的执行队列，并使用一个链表，把这些包含了finalize的对象串起来。</p><p><img src="https://s3.ax1x.com/2021/01/12/sGzl1s.png"></p><p>他的影响在于只要finalize没有执行，那么这些对象就会一直存在堆区，不过这里只是4个包含了finalize的对象，影响不是那么大，如果有一万个或者是十万个呢？这就影响大了。</p><p>finalize的原理其实很简单，在这里简要的梳理一下：</p><p>（1）对象在初始化的过程中会判断是否重写了finalize，方法是判断两个字段标志has_finalizer_flag和RegisterFinalizersAtInit。</p><p>（2）如果重写了finalize，那就把当前对象注册到FinalizerThread的ReferenceQueue队列中。注册之后的对象就叫做Finalizer。方法是调用register_finalizer函数。此时java虚拟机一看当前有这个对象的引用，于是就不进行垃圾回收了。</p><p>（3）对象开始被调用，FinalizerThread线程负责从ReferenceQueue队列中获取Finalizer对象。开始执行finalize方法，在执行之前，这个对象一直在堆中。</p><p>（4）对象执行完毕之后，将这个Finalizer对象从队列中移除，java虚拟机一看对象没有引用了，就进行垃圾回收了。</p><p>这就是整个过程。不过在这里我们主要看的是finalize方法对垃圾回收的影响，其实就是在第三步，也就是这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。</p><blockquote><p><strong>注意：这里其实就是一道面试题，我在看牛客网上的面经时，看到有人被问到过。也就是GCRoot不可达的对象，会立刻被垃圾回收吗？</strong></p></blockquote><p>我们使用一个案例来分析一波：</p><h2 id="二、案例演示"><a href="#二、案例演示" class="headerlink" title="二、案例演示"></a>二、案例演示</h2><p>我们创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinalizer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fdd</span> </span>&#123;<br>    <span class="hljs-comment">//分配1M</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;finalize被执行&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        Fdd fdd = <span class="hljs-keyword">new</span> Fdd(); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在创建了类，我们设置一下参数。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 最大堆内存</span><br><span class="hljs-meta">-Xmx5m</span> <span class="hljs-string"></span><br><span class="hljs-comment"># 最小堆内存</span><br><span class="hljs-meta">-Xms5m</span>  <span class="hljs-string"></span><br><span class="hljs-comment"># 堆内存溢出错误打印</span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">+HeapDumpOnOutOfMemoryError </span><br><span class="hljs-comment"># 把堆相关信息保存在下列路径</span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">HeapDumpPath=F:/a.dump</span><br></code></pre></td></tr></table></figure><p>在main方法中，创建了1000个Fdd对象，如果不执行finalize方法，那么因为没有调用所以会进行垃圾回收，此时不断我们创建多少个，都不会出现任何问题。但是如果存在finalize方法，就不一样了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">java.lang.OutOfMemoryError</span>: <span class="hljs-string">Java heap space</span><br><span class="hljs-attr">Dumping</span> <span class="hljs-string">heap to F:/a.dump ...</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">Unable</span> <span class="hljs-string">to create F:/a.dump: File exists</span><br><span class="hljs-attr">Exception</span> <span class="hljs-string">in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="hljs-attr">at</span> <span class="hljs-string">com.fdd.chapter2.TestFinalizer$Fdd.&lt;init&gt;(TestFinalizer.java:6)</span><br><span class="hljs-attr">at</span> <span class="hljs-string">com.fdd.chapter2.TestFinalizer.main(TestFinalizer.java:14)</span><br></code></pre></td></tr></table></figure><p>我们看到每个对象都会执行finalize，在执行之前的这段时间一直会在堆区，执行完了就会被清理，所以你看到这里执行了不少于5次的finalize方法。但是对象一旦超出了我们设置的5M，就会出现内存溢出。一句话总结就是出现了对象堆积。现在使用MAT工具来分析一下。</p><blockquote><p>Mat工具是一个插件，也可以自己下载一个。下载完成之后打开我们刚刚生成的a.dump即可。</p></blockquote><p>下面这张图就是分析的结果：</p><p><img src="https://s3.ax1x.com/2021/01/12/sGzQpj.png"></p><p>a这块的内容就是Finalizer，也就是我们的Fdd对象，b包含的比较多，乱七八糟的剩余信息。当然你也可以查看一些其他的信息。都在MAT工具上。还有一些正在执行的finalizer和准备执行的。</p><p><img src="https://s3.ax1x.com/2021/01/12/sGz1cn.png"></p><p>OK，一些其他的信息就不再展示了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一个GCRoot不可达的对象，不会立刻被垃圾回收，首先还会判断是否包含了finalize方法，如果有那就先执行finalize方法，如果这样的对象比较多，那么这部分对象及时GCRoot不可达，变得没用了，也会留在内存中，影响程序的效率。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中如何压缩集合</title>
    <link href="/2021/01/14/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/1%E3%80%81java%E9%9B%86%E5%90%88/java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9%E9%9B%86%E5%90%88/"/>
    <url>/2021/01/14/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/1%E3%80%81java%E9%9B%86%E5%90%88/java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8E%8B%E7%BC%A9%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个问题算是开发当中偶尔会遇到的一个小问题，比如如何将两个集合压缩成为一个逻辑集合。</p><p>如果你不理解，我们可以看一个简单的例子，去说明什么是压缩集合。本文文章不长，但是还算是比较实用的小技巧。主要内容来源于国外小哥Baeldung的博客：下面给出个地址</p><p><a href="https://www.baeldung.com/java-collections-zip">https://www.baeldung.com/java-collections-zip</a></p><blockquote><p><strong>这位大佬虽然写的很详细，但是有一些细节小问题，我在此基础之上，实地验证了一遍，发现有几个坑，不过已经填完了。</strong></p></blockquote><h3 id="案例解释什么是压缩集合"><a href="#案例解释什么是压缩集合" class="headerlink" title="案例解释什么是压缩集合"></a>案例解释什么是压缩集合</h3><p>现在有两个集合：<code>names和ages</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>List&lt;Integer&gt; ages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">27</span>));<br></code></pre></td></tr></table></figure><p>压缩完之后我们遍历压缩对象变成了下面这种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">张三:<span class="hljs-number">24</span><br>李四:<span class="hljs-number">25</span><br>王五:<span class="hljs-number">27</span><br></code></pre></td></tr></table></figure><p>也就是name:age的键值对的形式，当然，如果我们的集合比较多，我们还可以压缩更多的集合。比如一个人的各种信息，<code>id:name:age</code>等等。</p><p>OK，知道了什么是压缩，下面不回长篇大论，直接给出压缩的几种形式，</p><h2 id="压缩集合的几种方式"><a href="#压缩集合的几种方式" class="headerlink" title="压缩集合的几种方式"></a>压缩集合的几种方式</h2><h3 id="方式一：Java-8的IntStream"><a href="#方式一：Java-8的IntStream" class="headerlink" title="方式一：Java 8的IntStream"></a>方式一：Java 8的IntStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>List&lt;Integer&gt; ages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">27</span>));<br><span class="hljs-comment">//方式一：java8的IntSream</span><br>Stream&lt;String&gt; stream = IntStream<br>      .range(<span class="hljs-number">0</span>, Math.min(names.size(), ages.size()))<br>      .mapToObj(i -&gt; names.get(i) + <span class="hljs-string">&quot;:&quot;</span> + ages.get(i));<br><span class="hljs-comment">//遍历输出</span><br>stream.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>这种方式比较简单，获取两个集合的流，然后转化为对象。java8可以直接使用。</p><h3 id="方式二：Guava-Streams"><a href="#方式二：Guava-Streams" class="headerlink" title="方式二：Guava Streams"></a>方式二：Guava Streams</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>List&lt;Integer&gt; ages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">27</span>));<br><br><span class="hljs-comment">//方式二：guava</span><br><span class="hljs-comment">//第一种</span><br>Streams.forEachPair(<br>       Stream.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>),<br>       Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<br>       (name, age) -&gt; System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + age));<br><span class="hljs-comment">//第二种：</span><br>Stream&lt;String&gt; stream2 = Streams.zip(names.stream(), ages.stream(), <br>        (name, age) -&gt; name + <span class="hljs-string">&quot;:&quot;</span> + age);<br>stream2.forEach(System.out::println);<br><span class="hljs-comment">//第三种：</span><br>Stream&lt;String&gt; stream3 = Streams.mapWithIndex(<br>        Stream.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>),<br>        (str, index) -&gt; str + <span class="hljs-string">&quot;:&quot;</span> + index);<br>stream3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>以上是几种实现的方式，这位大佬给出了一种，我又去官网找了其他几种。另外使用guava的时候，版本要求21以上。我们在pom文件添加以下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>30.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里注意使用最新版的就可以。其他的也许会报错。我试了版本21的，也出错。</p><h3 id="方式二：Using-jOOλ-jOOL"><a href="#方式二：Using-jOOλ-jOOL" class="headerlink" title="方式二：Using jOOλ (jOOL)"></a>方式二：Using <em>jOOλ</em> <em>(jOOL)</em></h3><p>jOOL还在Java 8 Lambda上提供了一些有趣的新功能，并且通过对Tuple1到Tuple16的支持，zip操作变得更加有趣:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式三：jool</span><br><span class="hljs-comment">//第一种</span><br>Seq&lt;Tuple2&lt;String,Integer&gt;&gt; s1 = Seq.of(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>)<br>    .zip(Seq.of(<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">27</span>));<br><span class="hljs-comment">//第二种</span><br>Seq&lt;String&gt; s2 = Seq.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>    .zip(Seq.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>), (x, y) -&gt; x + <span class="hljs-string">&quot;:&quot;</span> + y);<br><span class="hljs-comment">//第三种</span><br>Seq&lt;Tuple2&lt;String,Long&gt;&gt; s3 = Seq.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>).zipWithIndex();<br>s1.forEach(System.out::println);<br>s2.forEach(System.out::println);<br>s3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>Seq结果是一个压缩元组，我们可以看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(tuple(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>), tuple(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>), tuple(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>))<br></code></pre></td></tr></table></figure><p>这种方式也是需要添加依赖的。在pom文件添加如下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jooq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jool-java-8<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ok，还有很多，基本思想都是切成流，再合并。这个直接用java实现也可以。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>“zip”操作与标准的“concat”或“merge”稍有不同。“concat”或“merge”操作将简单地在现有集合的末尾添加新集合，而“zip”操作将从每个集合中获取一个元素并将它们组合起来。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCRoot不可达的对象，会立刻被垃圾回收吗？</title>
    <link href="/2021/01/12/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/GCRoot%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BC%9A%E7%AB%8B%E5%88%BB%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F/"/>
    <url>/2021/01/12/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/GCRoot%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BC%9A%E7%AB%8B%E5%88%BB%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《JVM专题》中</strong></p></blockquote><p>这个问题是我在刷牛客面经的时候遇到的，还特地整理在了我的常规面试题文档中，所以这道题主要考察的就是finalize方法的影响。</p><p>java提供了一个finalize方法，可以帮助我们进行资源释放，类似于C++中的析构函数。但是目前普遍的认识是不要使用，为什么呢？就是因为对java虚拟机的垃圾回收有影响。这篇文章对其进行一个说明。</p><h2 id="一、为什么有影响"><a href="#一、为什么有影响" class="headerlink" title="一、为什么有影响"></a>一、为什么有影响</h2><p>我们都知道一个对象GCRoot不可达，java虚拟机就认为是垃圾对象，就会进行垃圾回收，但是如果这个对象包含了finalize函数，性质就不一样了。怎么不一样了呢？</p><p>java虚拟机在进行垃圾回收的时候，一看到这个对象类含有finalize函数，就把这个函数交给FinalizerThread处理，而包含了这个finalize的对象就会被添加到FinalizerThread的执行队列，并使用一个链表，把这些包含了finalize的对象串起来。</p><p><img src="https://s3.ax1x.com/2021/01/12/sGzl1s.png"></p><p>他的影响在于只要finalize没有执行，那么这些对象就会一直存在堆区，不过这里只是4个包含了finalize的对象，影响不是那么大，如果有一万个或者是十万个呢？这就影响大了。</p><p>finalize的原理其实很简单，在这里简要的梳理一下：</p><p>（1）对象在初始化的过程中会判断是否重写了finalize，方法是判断两个字段标志has_finalizer_flag和RegisterFinalizersAtInit。</p><p>（2）如果重写了finalize，那就把当前对象注册到FinalizerThread的ReferenceQueue队列中。注册之后的对象就叫做Finalizer。方法是调用register_finalizer函数。此时java虚拟机一看当前有这个对象的引用，于是就不进行垃圾回收了。</p><p>（3）对象开始被调用，FinalizerThread线程负责从ReferenceQueue队列中获取Finalizer对象。开始执行finalize方法，在执行之前，这个对象一直在堆中。</p><p>（4）对象执行完毕之后，将这个Finalizer对象从队列中移除，java虚拟机一看对象没有引用了，就进行垃圾回收了。</p><p>这就是整个过程。不过在这里我们主要看的是finalize方法对垃圾回收的影响，其实就是在第三步，也就是这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。</p><blockquote><p><strong>注意：这里其实就是一道面试题，我在看牛客网上的面经时，看到有人被问到过。也就是GCRoot不可达的对象，会立刻被垃圾回收吗？</strong></p></blockquote><p>我们使用一个案例来分析一波：</p><h2 id="二、案例演示"><a href="#二、案例演示" class="headerlink" title="二、案例演示"></a>二、案例演示</h2><p>我们创建一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFinalizer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fdd</span> </span>&#123;<br>    <span class="hljs-comment">//分配1M</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;finalize被执行&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        Fdd fdd = <span class="hljs-keyword">new</span> Fdd(); <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在创建了类，我们设置一下参数。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 最大堆内存</span><br><span class="hljs-meta">-Xmx5m</span> <span class="hljs-string"></span><br><span class="hljs-comment"># 最小堆内存</span><br><span class="hljs-meta">-Xms5m</span>  <span class="hljs-string"></span><br><span class="hljs-comment"># 堆内存溢出错误打印</span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">+HeapDumpOnOutOfMemoryError </span><br><span class="hljs-comment"># 把堆相关信息保存在下列路径</span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">HeapDumpPath=F:/a.dump</span><br></code></pre></td></tr></table></figure><p>在main方法中，创建了1000个Fdd对象，如果不执行finalize方法，那么因为没有调用所以会进行垃圾回收，此时不断我们创建多少个，都不会出现任何问题。但是如果存在finalize方法，就不一样了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">java.lang.OutOfMemoryError</span>: <span class="hljs-string">Java heap space</span><br><span class="hljs-attr">Dumping</span> <span class="hljs-string">heap to F:/a.dump ...</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">finalize被执行</span><br><span class="hljs-attr">Unable</span> <span class="hljs-string">to create F:/a.dump: File exists</span><br><span class="hljs-attr">Exception</span> <span class="hljs-string">in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="hljs-attr">at</span> <span class="hljs-string">com.fdd.chapter2.TestFinalizer$Fdd.&lt;init&gt;(TestFinalizer.java:6)</span><br><span class="hljs-attr">at</span> <span class="hljs-string">com.fdd.chapter2.TestFinalizer.main(TestFinalizer.java:14)</span><br></code></pre></td></tr></table></figure><p>我们看到每个对象都会执行finalize，在执行之前的这段时间一直会在堆区，执行完了就会被清理，所以你看到这里执行了不少于5次的finalize方法。但是对象一旦超出了我们设置的5M，就会出现内存溢出。一句话总结就是出现了对象堆积。现在使用MAT工具来分析一下。</p><blockquote><p>Mat工具是一个插件，也可以自己下载一个。下载完成之后打开我们刚刚生成的a.dump即可。</p></blockquote><p>下面这张图就是分析的结果：</p><p><img src="https://s3.ax1x.com/2021/01/12/sGzQpj.png"></p><p>a这块的内容就是Finalizer，也就是我们的Fdd对象，b包含的比较多，乱七八糟的剩余信息。当然你也可以查看一些其他的信息。都在MAT工具上。还有一些正在执行的finalizer和准备执行的。</p><p><img src="https://s3.ax1x.com/2021/01/12/sGz1cn.png"></p><p>OK，一些其他的信息就不再展示了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>一个GCRoot不可达的对象，不会立刻被垃圾回收，首先还会判断是否包含了finalize方法，如果有那就先执行finalize方法，如果这样的对象比较多，那么这部分对象及时GCRoot不可达，变得没用了，也会留在内存中，影响程序的效率。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot启动了哪些bean？这两种方式可以获取</title>
    <link href="/2021/01/07/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/Springboot%E5%90%AF%E5%8A%A8%E4%BA%86%E5%93%AA%E4%BA%9Bbean%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96/"/>
    <url>/2021/01/07/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/Springboot%E5%90%AF%E5%8A%A8%E4%BA%86%E5%93%AA%E4%BA%9Bbean%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文出自公众号《愚公要移山》Springboot系列</strong></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在本文中，我们将探索在容器中获取所有spring管理的bean的相关技术。这有神马用？主要是用于排查问题。一般都是我们创建的某一个bean没有启动的问题。毕竟工作中总是会遇到各种各样的bug。提前了解一些没有坏处。</p><h2 id="2-IoC容器"><a href="#2-IoC容器" class="headerlink" title="2. IoC容器"></a>2. IoC容器</h2><p>bean是spring管理的应用程序的基础，所有bean都驻留在IOC容器中，该容器负责管理它们的生命周期。</p><p>我们可以通过两种方式获取该容器内所有bean的列表:</p><ol><li>使用<em>ListableBeanFactory</em>接口</li><li>使用Spring Boot Actuator</li></ol><h2 id="3-使用ListableBeanFactory接口"><a href="#3-使用ListableBeanFactory接口" class="headerlink" title="3.使用ListableBeanFactory接口"></a>3.使用ListableBeanFactory接口</h2><p>ListableBeanFactory接口提供了getBeanDefinitionNames()方法，该方法返回在这个工厂中定义的所有bean的名称。您可以在官方文档中找到所有已知子接口及其实现类的列表。我们来看这种方式如何获取所有的bean。</p><h3 id="第一步：创建一个Controller"><a href="#第一步：创建一个Controller" class="headerlink" title="第一步：创建一个Controller"></a>第一步：创建一个Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> FooService fooService;<br>    <span class="hljs-meta">@RequestMapping(value=&quot;/displayallbeans&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHeaderAndBody</span><span class="hljs-params">(Map model)</span></span>&#123;<br>        model.put(<span class="hljs-string">&quot;header&quot;</span>, fooService.getHeader());<br>        model.put(<span class="hljs-string">&quot;message&quot;</span>, fooService.getBody());<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;displayallbeans&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个Controller依赖于另一个FooService。</p><h3 id="第二步：创建Service"><a href="#第二步：创建Service" class="headerlink" title="第二步：创建Service"></a>第二步：创建Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHeader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Display All Beans&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBody</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;展示所有beans的案例&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我们在这里创建了两个不同的bean:</p><ul><li><p>fooController</p></li><li><p>fooService</p></li></ul><p>这里使用applicationContext对象并调用它的getBeanDefinitionNames()方法，该方法将返回applicationContext容器中的所有bean:</p><h3 id="第三步：设置SpringBootApplication启动类"><a href="#第三步：设置SpringBootApplication启动类" class="headerlink" title="第三步：设置SpringBootApplication启动类"></a>第三步：设置SpringBootApplication启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        applicationContext = SpringApplication.run(DemoApplication.class, args);<br>        displayAllBeans();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayAllBeans</span><span class="hljs-params">()</span> </span>&#123;<br>        String[] allBeanNames = applicationContext.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span>(String beanName : allBeanNames) &#123;<br>            System.out.println(beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四步：测试打印"><a href="#第四步：测试打印" class="headerlink" title="第四步：测试打印"></a>第四步：测试打印</h3><p>这将打印applicationContext容器中的所有bean:</p><p><img src="https://s3.ax1x.com/2021/01/07/sZWQM9.png"></p><p>注意，除了我们定义的bean之外，它还将记录该容器中的所有其他bean。为了清楚起见，我们在这里省略了它们，因为它们有很多。</p><h2 id="4-使用Spring-Boot-Actuator"><a href="#4-使用Spring-Boot-Actuator" class="headerlink" title="4. 使用Spring Boot Actuator"></a>4. 使用Spring Boot Actuator</h2><p>Spring Boot Actuator提供了用于监控应用程序统计信息的端点。下面看看这种方式：</p><h3 id="第一步：添加依赖"><a href="#第一步：添加依赖" class="headerlink" title="第一步：添加依赖"></a>第一步：添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第二步：修改application-properties"><a href="#第二步：修改application-properties" class="headerlink" title="第二步：修改application.properties"></a>第二步：修改application.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><br></code></pre></td></tr></table></figure><p>把上面代码添加到properties文件中。</p><h3 id="第三步：使用发布端点查看"><a href="#第三步：使用发布端点查看" class="headerlink" title="第三步：使用发布端点查看"></a>第三步：使用发布端点查看</h3><p><img src="https://s3.ax1x.com/2021/01/07/sZWKxJ.png"></p><p>由于这里的Actuator没有配置，所以显示的比较乱。关于Actuator的配置，会在下一篇文章中呈现。</p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>在本文中，我们了解了如何使用ListableBeanFactory接口和Spring Boot Actuator在Spring IoC容器中显示所有bean。希望对你有点帮助。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Springboot专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一步为你的Springboot应用自定义banner</title>
    <link href="/2021/01/07/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/%E4%B8%80%E6%AD%A5%E4%B8%BA%E4%BD%A0%E7%9A%84Springboot%E5%BA%94%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89banner/"/>
    <url>/2021/01/07/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/%E4%B8%80%E6%AD%A5%E4%B8%BA%E4%BD%A0%E7%9A%84Springboot%E5%BA%94%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89banner/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文出自公众号《愚公要移山》Springboot系列</strong></p></blockquote><p>这个小功能据说是Springboot2.x的小彩蛋，出来很久很久了。之前知道没试过，这次试了一下，还可以，挺好玩的。最近因为开始重新看Springboot，看到了这个部分，于是整理到了文章中。烂大街的东西，拿来丢人显眼了。</p><h2 id="什么是banner？"><a href="#什么是banner？" class="headerlink" title="什么是banner？"></a>什么是banner？</h2><p><img src="https://s3.ax1x.com/2021/01/06/sVt9k6.png"></p><p>就是这个默认的Spring标识，有时候看着太难看，所以想换换，没什么卵用，有时候还会使你的Springboot应用启动变慢。所以看着玩玩就好。</p><h2 id="一步实现"><a href="#一步实现" class="headerlink" title="一步实现"></a>一步实现</h2><p>看好了，在你的springboot项目的resource目录下，新建一个banner.txt文件，你在里面写的内容就是要显示的内容。</p><p>比如说我们写上：愚公要移山。</p><p><img src="https://s3.ax1x.com/2021/01/06/sVtSTx.png"></p><p>这样写起来比较难看。还不如以前的格式好看，不过没关系，也有一些好看的网站已经帮我们实现了。转化之后把内容替换掉就可以。</p><ul><li>可以根据输入的字符生成字符画：<a href="http://patorjk.com/software/taag/#p=display&amp;f=Doh&amp;t=fengdongdong">http://patorjk.com/software/taag/#p=display&amp;f=Doh&amp;t=fengdongdong</a></li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sVYz01.png"></p><ul><li>可以根据画显示字符：<a href="https://www.degraeve.com/img2txt.php">https://www.degraeve.com/img2txt.php</a></li></ul><p>使用一张地图试试</p><p><img src="https://file01.16sucai.com/d/file/2011/0801/20110801111724537.jpg"></p><p>效果如下：</p><p><img src="https://s3.ax1x.com/2021/01/06/sVYxmR.png"></p><p>具体的你自己琢磨吧。</p><h2 id="还是难看？没事接着看"><a href="#还是难看？没事接着看" class="headerlink" title="还是难看？没事接着看"></a>还是难看？没事接着看</h2><p>这颜色太难看了。没事，还有配置。</p><p>Spring提供了三个枚举类来设定字符的颜色，分别是：</p><ul><li><p>AnsiColor： 用来设定字符的前景色</p></li><li><p>AnsiBackground： 用来设定字符的背景色</p></li><li><p>AnsiStyle： 用来控制加粗、斜体、下划线等等。</p></li></ul><p>我们设置个颜色试试。</p><p><img src="https://s3.ax1x.com/2021/01/06/sVtPfO.png"></p><p>最后启动，看看效果</p><p><img src="https://s3.ax1x.com/2021/01/06/sVtCtK.png"></p><p>小玩意，东西虽好，不要贪用！！感谢</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Springboot专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为你的Springboot应用配置通用的异常处理吧（实用干货）</title>
    <link href="/2021/01/05/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/%E4%B8%BA%E4%BD%A0%E7%9A%84Springboot%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%90%A7%EF%BC%88%E5%AE%9E%E7%94%A8%E5%B9%B2%E8%B4%A7%EF%BC%89/"/>
    <url>/2021/01/05/%E4%BA%94%E3%80%81Spring%E7%B3%BB%E5%88%97/3%E3%80%81SpringBoot/%E4%B8%BA%E4%BD%A0%E7%9A%84Springboot%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%90%A7%EF%BC%88%E5%AE%9E%E7%94%A8%E5%B9%B2%E8%B4%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文出自公众号《愚公要移山》Springboot系列</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们的项目通常来讲都是一个比较大的项目，包含了各种各样的服务。如果每个服务都以不同的方式返回异常信息，这样排查的时候就会比较凌乱。如果我们定义一个标准的异常处理体系。并在所有的服务中使用。那样开发起来就可以快速定位。页面也会更加的简单和直观。</p><p>本文开发环境基于springboot2.4，IDE环境是IDEA。这里从一个最简单的异常案例。逐步过渡到完全自定义自己的异常。</p><blockquote><p>案例：Springboot查询数据库数据，发现返回的是null，就抛出异常。</p></blockquote><p>OK，基于这个思想，看一下实现的思路。</p><h2 id="一、简单案例代码实现"><a href="#一、简单案例代码实现" class="headerlink" title="一、简单案例代码实现"></a>一、简单案例代码实现</h2><h3 id="1、新建一个Springboot应用"><a href="#1、新建一个Springboot应用" class="headerlink" title="1、新建一个Springboot应用"></a>1、新建一个Springboot应用</h3><p><img src="https://s3.ax1x.com/2021/01/05/skPgte.png"></p><h3 id="2、新建dao包，创建User类"><a href="#2、新建dao包，创建User类" class="headerlink" title="2、新建dao包，创建User类"></a>2、新建dao包，创建User类</h3><p>这个比较简单，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//getter和setter方法</span><br>    <span class="hljs-comment">//toString方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、新建service包，创建UserService"><a href="#3、新建service包，创建UserService" class="headerlink" title="3、新建service包，创建UserService"></a>3、新建service包，创建UserService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">findOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        <span class="hljs-comment">//本来应该向数据库查询User，但是数据库没有</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于演示的是异常的案例，因此这里没有真正实现数据库的增删改查操作。当调用findOne方法时，直接返回为null即可。</p><h3 id="4、新建controller包，创建UserController类"><a href="#4、新建controller包，创建UserController类" class="headerlink" title="4、新建controller包，创建UserController类"></a>4、新建controller包，创建UserController类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService service;<br>    <span class="hljs-meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">retriveUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> <span class="hljs-keyword">int</span> id)</span> </span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> UserNotFoundException </span>&#123;<br>        User user= service.findOne(id);<br>        <span class="hljs-keyword">if</span>(user==<span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UserNotFoundException(<span class="hljs-string">&quot;id: &quot;</span>+ id);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里自定义了一个异常UserNotFoundException，当数据库查询的时候一旦发现返回值为null，就直接抛出这个异常。</p><h3 id="5、在controller包下，创建UserNotFoundException类"><a href="#5、在controller包下，创建UserNotFoundException类" class="headerlink" title="5、在controller包下，创建UserNotFoundException类"></a>5、在controller包下，创建UserNotFoundException类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserNotFoundException</span><span class="hljs-params">(String message)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>        System.out.println(<span class="hljs-string">&quot;异常信息是：&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、postman测试"><a href="#6、postman测试" class="headerlink" title="6、postman测试"></a>6、postman测试</h3><p><img src="https://s3.ax1x.com/2021/01/05/skPyTO.png" alt="1609827005387"></p><p>这时候进行测试会发现服务器代码会报错。我们的资源没有找到总不能提示服务器内部错误吧。现在对抛出的异常进行一个处理。</p><h3 id="7、异常处理"><a href="#7、异常处理" class="headerlink" title="7、异常处理"></a>7、异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserNotFoundException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserNotFoundException</span><span class="hljs-params">(String message)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>        System.out.println(<span class="hljs-string">&quot;异常信息是：&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将添加一个注释@ResponseStatus来生成状态:404 Not Found。当然还有其他的状态。这个可以根据自己的需要去返回。我们使用了HttpStatus.NOT_FOUND用户访问的时候，一旦抛出了异常就会显示404错误。这个你换成其他的状态，还会显示其他的信息。</p><h4 id="8、重新测试"><a href="#8、重新测试" class="headerlink" title="8、重新测试"></a>8、重新测试</h4><p><img src="https://s3.ax1x.com/2021/01/05/skPrm6.png" alt="1609827261976"></p><p>Spring Boot和Spring MVC框架的结合提供了错误处理。其内部已经自动配置一些默认异常处理。所以在开发中为所有服务配置一致的异常消息是很重要的。</p><h2 id="二、通用的异常处理"><a href="#二、通用的异常处理" class="headerlink" title="二、通用的异常处理"></a>二、通用的异常处理</h2><h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、创建异常返回实体类ExceptionResponse"><a href="#2、创建异常返回实体类ExceptionResponse" class="headerlink" title="2、创建异常返回实体类ExceptionResponse"></a>2、创建异常返回实体类ExceptionResponse</h3><p>这个类的作用是，当有异常时，我们想要展示的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionResponse</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Date timestamp;<br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-keyword">private</span> String detail;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExceptionResponse</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExceptionResponse</span><span class="hljs-params">(Date timestamp, String message, String detail)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.timestamp = timestamp;<br>        <span class="hljs-keyword">this</span>.message = message;<br>        <span class="hljs-keyword">this</span>.detail = detail;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getTimestamp</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> timestamp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDetail</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> detail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只需要实现getter方法，setter方法就不需要。</p><h3 id="3、创建通用异常处理类"><a href="#3、创建通用异常处理类" class="headerlink" title="3、创建通用异常处理类"></a>3、创建通用异常处理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomizedResponseEntityExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseEntityExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">//此方法主要处理所有的异常信息</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ResponseEntity&lt;Object&gt; <span class="hljs-title">handleAllExceptions</span><span class="hljs-params">(Exception ex, WebRequest request)</span> </span>&#123;<br>        <span class="hljs-comment">//当出现异常时，我们输出的信息，这里被封装在了ExceptionResponse</span><br>        ExceptionResponse exceptionResponse = <span class="hljs-keyword">new</span> ExceptionResponse(<span class="hljs-keyword">new</span> Date(), ex.getMessage(), request.getDescription(<span class="hljs-keyword">false</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR);<br>    &#125;<br>    <span class="hljs-comment">//当页面资源没有找到时，抛出的异常</span><br>    <span class="hljs-meta">@ExceptionHandler(UserNotFoundException.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ResponseEntity&lt;Object&gt; <span class="hljs-title">handleUserNotFoundExceptions</span><span class="hljs-params">(UserNotFoundException ex, WebRequest request)</span> </span>&#123;<br>        ExceptionResponse exceptionResponse = <span class="hljs-keyword">new</span> ExceptionResponse(<span class="hljs-keyword">new</span> Date(), ex.getMessage(), request.getDescription(<span class="hljs-keyword">false</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很简单。里面有很多API，可以自己根据需要去查即可。</p><h3 id="4、postman测试"><a href="#4、postman测试" class="headerlink" title="4、postman测试"></a>4、postman测试</h3><p><img src="https://s3.ax1x.com/2021/01/05/skPs0K.png" alt="1609828897996"></p><p>万事大吉。赶快为你的程序自定义一个通用的异常处理程序吧。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>Springboot专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序出现了bug如何排查？看看这几款JVM工具</title>
    <link href="/2021/01/04/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E4%BA%86bug%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%EF%BC%9F%E7%9C%8B%E7%9C%8B%E8%BF%99%E5%87%A0%E6%AC%BEJVM%E5%B7%A5%E5%85%B7/"/>
    <url>/2021/01/04/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/5%E3%80%81jvm/%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E4%BA%86bug%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%EF%BC%9F%E7%9C%8B%E7%9C%8B%E8%BF%99%E5%87%A0%E6%AC%BEJVM%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>在平时的开发当中我们总是会遇到各种各样的问题，比如说内存泄漏、死锁、CPU等。遇到问题不可怕，关键是我们如何去排查这些错误，对症下药才是根本。不过对于很多人来说，往往找不到这些问题的根本所在，因此这篇文章主要是让我们掌握一些工具来分析到底是哪里出现了问题。</p><p>在之前的文章中，主要是分析了JVM的内存结构、类加载机制和垃圾回收机制。文章的顺序也是循序渐进的，从这篇文章当中我们主要是分析JDK自带的工具，把理论应用于实践。</p><p>首先我们先对几种要讲的工具进行一个概述，然后再分别分析：</p><h2 id="一、性能监控工具概述"><a href="#一、性能监控工具概述" class="headerlink" title="一、性能监控工具概述"></a>一、性能监控工具概述</h2><p>工具主要是为了解决问题而生的，就是由于我们的程序存在着一些性能问题，才有了这些工具。其实当我们在下载完成JDK之后，那些工具就被SUN公司随之送给我们了。</p><p>我们可以在我们的JDK安装目录，下看看会有很多这样的工具。</p><p><img src="https://s3.ax1x.com/2021/01/04/siBAeI.png"></p><p>我们会发现很多这样的exe文件，这里面有很多都是性能监控工具。我们就抽出来几个进行讲解。</p><table><thead><tr><th>工具名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps（JVM Process Status Tool）</td><td>显示指定系统中所有的HotSpot虚拟机进程</td></tr><tr><td>jstat（JVM Statistics Monitoring Tool）</td><td>收集HotSpot虚拟机各方面的运行数据</td></tr><tr><td>jinfo（Configuration Info for Java）</td><td>显示虚拟机配置信息</td></tr><tr><td>jmap（Memory Map for Java）</td><td>生成虚拟机的内存转储快照（heapdump文件）</td></tr><tr><td>jhat（JVM Heap Dump Browser）</td><td>分析内存转储快照，不推荐使用，消耗资源而且慢</td></tr><tr><td>jstack（Stack Trace for Java）</td><td>显示虚拟机的线程快照</td></tr><tr><td>JConsole</td><td>JMX的可视化管理工具</td></tr><tr><td>VisualVM</td><td>多合一故障管理工具</td></tr></tbody></table><p>常见的几个工具都已经列出来了，还有一些其他的工具，其实用起来比JDK自带的还要好，我会在今后的文章中列出来。OK，我们就一个一个去分析一下这些工具是干嘛的，以及如何去使用的。</p><h2 id="二、工具"><a href="#二、工具" class="headerlink" title="二、工具"></a><strong>二、工具</strong></h2><h3 id="1、jps-虚拟机进程状况工具"><a href="#1、jps-虚拟机进程状况工具" class="headerlink" title="1、jps:虚拟机进程状况工具"></a><strong>1、jps:虚拟机进程状况工具</strong></h3><p>jps主要用来输出JVM中运行的进程状态信息。语法格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">jps</span> <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[hostid]</span><br></code></pre></td></tr></table></figure><p>   <strong>第一个参数：options</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-q 不输出类名、Jar名和传入main方法的参数<br>-m 输出传入main方法的参数<br>-l 输出main类或Jar的全限名<br>-v 输出传入JVM的参数<br></code></pre></td></tr></table></figure><p>​    <strong>第二个参数：hostid</strong></p><p>主机或者是服务器的id，如果不指定，就默认为当前的主机或者是服务器。</p><p>我是在Windows10系统下测试的，当然你可以在linux下试验，方式是一样的，结果可能有不同。你可以选择不同的参数选项来进行测试。打开CMD输入相应命令</p><p><img src="https://s3.ax1x.com/2021/01/04/siBFOA.png"></p><h3 id="2、jstack：堆栈跟踪工具"><a href="#2、jstack：堆栈跟踪工具" class="headerlink" title="2、jstack：堆栈跟踪工具"></a><strong>2、jstack：堆栈跟踪工具</strong></h3><p>jstack用于生成虚拟机当前时刻的线程快照。语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jstack [option] vmid<br></code></pre></td></tr></table></figure><p><strong>第一个参数：option</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被相应时候，强制输出线程堆栈</td></tr><tr><td>-l</td><td>出堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table><p><strong>第二个参数：vmid</strong></p><p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。</p><p>我们直接在CMD中操作一下：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBPQH.png"></p><h3 id="3、jstat-虚拟机统计信息监控工具"><a href="#3、jstat-虚拟机统计信息监控工具" class="headerlink" title="3、jstat:虚拟机统计信息监控工具"></a><strong>3、jstat:虚拟机统计信息监控工具</strong></h3><p>jstat监视虚拟机各种运行状态信息，可以显示本地或者是远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jstat [ generalOption | outputOptions vmid [interval] [count]] ]<br></code></pre></td></tr></table></figure><p><strong>第一个参数：generalOption | outputOptions</strong></p><p>这个参数表示的option，代表着用户希望查询的虚拟机信息，分为类加载、垃圾收集、运行期编译状况3类。</p><p><img src="https://s3.ax1x.com/2021/01/04/siBVTP.png"></p><p><strong>第二个参数：vmid</strong></p><p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。</p><p><strong>第三个参数：interval</strong></p><p>interval是采样时间间隔，</p><p><strong>第四个参数：count</strong></p><p>count表示的是采样数。</p><p>下面我们就是用一下这个工具，打开我们的CMD，输入相应的命令：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBiyd.png"></p><h3 id="4、jinfo：实时地查看和调整虚拟机各项参数"><a href="#4、jinfo：实时地查看和调整虚拟机各项参数" class="headerlink" title="4、jinfo：实时地查看和调整虚拟机各项参数"></a><strong>4、jinfo：实时地查看和调整虚拟机各项参数</strong></h3><p>命令格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jinfo [option] pid<br></code></pre></td></tr></table></figure><p><strong>第一个参数：option</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-v</td><td>查看虚拟机启动时显示指定的参数列表</td></tr><tr><td>-flag</td><td>查看虚拟机启动时未被指定的参数的默认值</td></tr><tr><td>-sysprops</td><td>打印虚拟机进程的System.getProperties()的内容</td></tr></tbody></table><p><strong>第二个参数：pid</strong></p><p>指定显示的进程id。</p><p>在CMD中进行测试：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBEwt.png"></p><h3 id="5、jmap：生成虚拟机的内存转储快照（heapdump文件）"><a href="#5、jmap：生成虚拟机的内存转储快照（heapdump文件）" class="headerlink" title="5、jmap：生成虚拟机的内存转储快照（heapdump文件）"></a><strong>5、jmap：生成虚拟机的内存转储快照（heapdump文件）</strong></h3><p>jmap（Memory Map for Java，内存映像工具），用于生成堆转存的快照，一般是heapdump或者dump文件。如果不适用jmap命令，可以使用-XX:+HeapDumpOnOutOfMemoryError参数，当虚拟机发生内存溢出的时候可以产生快照。或者使用kill -3 pid也可以产生。jmap的作用并不仅仅是为了获取dump文件，它可以查询finalize执行队列，java堆和永久代的详细信息，如空间使用率，当前用的哪种收集器。命令格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">jmap [option] vmid<br></code></pre></td></tr></table></figure><p><strong>第一个参数：</strong></p><p><img src="https://s3.ax1x.com/2021/01/04/siBmY8.png"></p><p><strong>第二个参数：vmid</strong></p><p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID.</p><p>在cmd中测试：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBKSg.png"></p><h3 id="6、jhat：分析内存转储快照，不推荐使用，而且慢"><a href="#6、jhat：分析内存转储快照，不推荐使用，而且慢" class="headerlink" title="6、jhat：分析内存转储快照，不推荐使用，而且慢"></a><strong>6、jhat：分析内存转储快照，不推荐使用，而且慢</strong></h3><p>由于这个工具功能比较简陋，运行起来也比较耗时，所以这个工具不推荐使用，推荐使用MAT。</p><h3 id="7、JConsole：JMX的可视化管理工具"><a href="#7、JConsole：JMX的可视化管理工具" class="headerlink" title="7、JConsole：JMX的可视化管理工具"></a><strong>7、JConsole：JMX的可视化管理工具</strong></h3><p>这个工具相比较前面几个工具，使用率比较高，很重要。它是一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。</p><p>在cmd里面输入 jconsole，选则进程就可以了。（前提是在IDE工具先建立一个线程运行着）</p><p><img src="https://s3.ax1x.com/2021/01/04/siBeFf.png"></p><p>然后我们选择了相应的选项之后，进入这个工具就会出现下面这个界面</p><p><img src="https://s3.ax1x.com/2021/01/04/siBnfS.png"></p><p>在上面有菜单，我们可以选择其中一个进行查看，就可以了，这个用具用起来很方便，也是我之前用的比较多的工具。</p><h3 id="8、VisualVM：多合一故障管理工具"><a href="#8、VisualVM：多合一故障管理工具" class="headerlink" title="8、VisualVM：多合一故障管理工具"></a><strong>8、VisualVM：多合一故障管理工具</strong></h3><p>这个工具也很牛bility。它同jconsole都是一个基于图形化界面的、可以查看本地及远程的JAVA GUI监控工具，Jvisualvm同jconsole的使用方式一样，直接在命令行打入jvisualvm即可启动，jvisualvm界面更美观一些，数据更实时：</p><p><img src="https://s3.ax1x.com/2021/01/04/siBMlQ.png"></p><p>最上面也有菜单，你可以选择不同的选项来展示。自己动手试一遍是最好的。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a><strong>三、总结</strong></h2><p>这些工具就先写这么多，在文章一开始我们其实已经发现了，jdk自带的工具那是超级的多，而且随着jdk版本的不断更新，工具还有不断加强增多的趋势，想要每一个都掌握那太费时间了，我们遇到哪些问题去搜索一下，看看能用到哪些工具就可以了。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>jvm专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java小白到架构师技术图谱</title>
    <link href="/2021/01/03/java%E5%B0%8F%E7%99%BD%E5%88%B0%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    <url>/2021/01/03/java%E5%B0%8F%E7%99%BD%E5%88%B0%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</url>
    
    <content type="html"><![CDATA[<p><strong>本文整理于github上各大star大神仓库。并根据自己的理解重新进行了整理</strong></p><blockquote><p><strong>本文已经收录于<a href="https://github.com/fengdongdongwsn/architect-java">https://github.com/fengdongdongwsn/architect-java</a></strong></p><p><strong>后序会继续更新</strong></p></blockquote><h2 id="👨🏻‍💻-About-Me"><a href="#👨🏻‍💻-About-Me" class="headerlink" title="👨🏻‍💻 About Me"></a>👨🏻‍💻 About Me</h2><table><thead><tr><th>个人网站</th><th>公众号</th><th>掘金</th><th>知乎</th><th><strong>CSDN</strong></th><th><strong>头条</strong></th></tr></thead><tbody><tr><td><a href="https://www.javachat.cc/">点我直达</a></td><td><a href="https://imgchr.com/i/rJnbO1">点我直达</a></td><td><a href="https://juejin.cn/user/1978776660213837/posts">点我直达</a></td><td><a href="https://www.zhihu.com/people/feng-dong-dong-10">点我直达</a></td><td><a href="https://blog.csdn.net/SDDDLLL">点我直达</a></td><td><a href="https://www.toutiao.com/c/user/token/MS4wLjABAAAAfhLQnyWhG1iqEVx_lsnoX7cUOlluuJf07J368xBJ7jU/">点我直达</a></td></tr><tr><td><strong>百家号</strong></td><td><strong>Segmentfault</strong></td><td><strong>教程资源（5T）</strong></td><td><strong>学习路线</strong></td><td><strong>博客文章</strong></td><td></td></tr><tr><td><a href="https://author.baidu.com/home?from=bjh_article&app_id=1634941951856739">点我直达</a></td><td><a href="https://segmentfault.com/u/a_yugong">点我直达</a></td><td><a href="https://mp.weixin.qq.com/s/nIODGnCKFgs3BTZ9Qy5rHQ?scene=25#wechat_redirect">点我直达</a></td><td><a href="https://mp.weixin.qq.com/s/UTV2GXtBdX-oLh7M9LTEvQ">点击直达</a></td><td><a href="https://mp.weixin.qq.com/s/wZ_4fy_F-NecMv3HO4Hfjw">点击直达</a></td><td></td></tr></tbody></table><h2 id="一、计算机基础"><a href="#一、计算机基础" class="headerlink" title="一、计算机基础"></a>一、计算机基础</h2><h3 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h3><h4 id="（1）基本数据结构"><a href="#（1）基本数据结构" class="headerlink" title="（1）基本数据结构"></a>（1）基本数据结构</h4><ul><li>数据结构基本概念（时间复杂度和空间复杂度的计算方法）</li><li>数组</li><li>链表</li><li>集合</li><li>队列</li><li>栈</li><li>关联数组</li><li>跳表</li><li>倒排索引</li><li>BitSet</li></ul><h4 id="（2）树"><a href="#（2）树" class="headerlink" title="（2）树"></a>（2）树</h4><ul><li>二叉树</li><li>平衡二叉树</li><li>完全二叉树</li><li>哈弗曼树</li><li>二叉查找树</li><li>B、B+、B*树</li><li>LSM树</li><li>字典树</li><li>红黑树</li><li>线段树</li></ul><h4 id="（3）图"><a href="#（3）图" class="headerlink" title="（3）图"></a>（3）图</h4><ul><li>最小生成树</li><li>最短路径算法</li><li>拓扑排序</li><li>深搜和广搜</li></ul><h4 id="（4）排序算法"><a href="#（4）排序算法" class="headerlink" title="（4）排序算法"></a>（4）排序算法</h4><ul><li>选择排序</li><li>冒泡排序</li><li>插入排序</li><li>快速排序</li><li>归并排序</li><li>希尔排序</li><li>基数排序</li><li>计数排序</li><li>桶排序</li><li>堆排序</li><li>排序算法使用场景特点总结</li></ul><h4 id="（5）查找算法"><a href="#（5）查找算法" class="headerlink" title="（5）查找算法"></a>（5）查找算法</h4><ul><li>顺序查找</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li><li>树表查找</li></ul><h4 id="（6）常见算法"><a href="#（6）常见算法" class="headerlink" title="（6）常见算法"></a>（6）常见算法</h4><ul><li>KMP算法</li><li>贪心算法</li><li>回溯算法</li><li>剪枝算法</li><li>动态规划</li><li>并查集</li><li>朴素贝叶斯</li><li>递归算法</li><li>符号表</li><li>布隆过滤器</li></ul><h3 id="2、计算机网络"><a href="#2、计算机网络" class="headerlink" title="2、计算机网络"></a>2、计算机网络</h3><h4 id="（1）协议"><a href="#（1）协议" class="headerlink" title="（1）协议"></a>（1）协议</h4><ul><li>OSI七层协议</li><li>TCP/IP协议</li><li>HTTP协议</li></ul><h4 id="（2）网络模型"><a href="#（2）网络模型" class="headerlink" title="（2）网络模型"></a>（2）网络模型</h4><ul><li>阻塞式IO</li><li>非阻塞式IO</li><li>复用IO</li><li>信号驱动IO</li><li>异步IO</li><li>Epoll模型</li><li>javaNIO</li><li>javaAIO</li><li>kqueue</li></ul><h4 id="（3）序列化"><a href="#（3）序列化" class="headerlink" title="（3）序列化"></a>（3）序列化</h4><ul><li>java序列化</li><li>protoBuf</li><li>protoStuff</li><li>avro</li><li>Hessian</li></ul><h3 id="3、操作系统"><a href="#3、操作系统" class="headerlink" title="3、操作系统"></a>3、操作系统</h3><h4 id="（1）基本知识"><a href="#（1）基本知识" class="headerlink" title="（1）基本知识"></a>（1）基本知识</h4><ul><li>操作系统的四个特征</li><li>操作系统的功能</li></ul><h4 id="（2）进程与线程"><a href="#（2）进程与线程" class="headerlink" title="（2）进程与线程"></a>（2）进程与线程</h4><ul><li>进程的概念与分类</li><li>线程的概念与分类</li><li>进程与线程的区别</li><li>进行的状态转换</li><li>CPU调度算法</li><li>管程</li><li>协程</li><li>进程间的通信方式</li><li>进程间同步问题<ul><li>生产者消费者问题</li><li>哲学家就餐问题</li><li>读者-写者问题</li><li>锁死的四个必要条件</li><li>死锁处理</li></ul></li></ul><h4 id="（3）内存管理"><a href="#（3）内存管理" class="headerlink" title="（3）内存管理"></a>（3）内存管理</h4><ul><li>段式管理</li><li>页式管理</li><li>段页式管理</li><li>页面调度算法</li></ul><h4 id="（4）其他"><a href="#（4）其他" class="headerlink" title="（4）其他"></a>（4）其他</h4><ul><li>虚拟内存和逻辑内存</li><li>静态链接和动态链接</li><li>缓存</li><li>僵尸进程与孤儿进程</li></ul><h2 id="二、java基础"><a href="#二、java基础" class="headerlink" title="二、java基础"></a>二、java基础</h2><h3 id="1、面向对象基础"><a href="#1、面向对象基础" class="headerlink" title="1、面向对象基础"></a>1、面向对象基础</h3><ul><li>继承</li><li>封装</li><li>多态</li><li>接口</li><li>抽象类</li></ul><h3 id="2、java集合"><a href="#2、java集合" class="headerlink" title="2、java集合"></a>2、java集合</h3><ul><li>总体框架</li><li>Collection</li><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li><li>快速失败和快速安全</li><li>HashMap</li><li>TreeMap</li><li>LinkedHashMap</li><li>HashSet</li><li>TreeSet</li><li>Hashtable</li><li>WeakHashMap</li></ul><h3 id="3、关键字和类"><a href="#3、关键字和类" class="headerlink" title="3、关键字和类"></a>3、关键字和类</h3><ul><li>transient</li><li>instanceof</li><li>static</li><li>this</li><li>super</li><li>void</li><li>final</li><li>String<ul><li>String为什么不可变</li><li>String、StringBuilder、StringBuffer区别</li><li>String到底新建了几个对象</li></ul></li></ul><h3 id="4、java高级特点"><a href="#4、java高级特点" class="headerlink" title="4、java高级特点"></a>4、java高级特点</h3><ul><li>注解</li><li>反射</li><li>泛型</li><li>异常</li><li>枚举</li><li>IO机制</li><li>编码转换</li><li>java8新特性</li><li>java11新特性</li></ul><h3 id="5、并发库"><a href="#5、并发库" class="headerlink" title="5、并发库"></a>5、并发库</h3><h4 id="（1）并发基础"><a href="#（1）并发基础" class="headerlink" title="（1）并发基础"></a>（1）并发基础</h4><ul><li>Thread生命周期</li><li>线程安全问题</li><li>线程通信模式</li><li>sleep和wait的区别</li><li>ThreadLocal</li></ul><h4 id="（2）原子特性"><a href="#（2）原子特性" class="headerlink" title="（2）原子特性"></a>（2）原子特性</h4><ul><li>AtomicInteger</li><li>AtomicBoolean</li><li>AtomicStampedReference</li><li>Unsafe</li><li>CAS</li></ul><h4 id="（3）并发工具"><a href="#（3）并发工具" class="headerlink" title="（3）并发工具"></a>（3）并发工具</h4><ul><li>CountDownLatch</li><li>CylicBarrier</li><li>Semaphore</li><li>Exchanger</li><li>Phaser</li><li>ForkJoin</li></ul><h4 id="（4）锁机制"><a href="#（4）锁机制" class="headerlink" title="（4）锁机制"></a>（4）锁机制</h4><ul><li>synchronized</li><li>volatile</li><li>Reentrantlock</li><li>ReenReadWriteLock</li><li>StampedLock</li><li>公平锁和非公平锁</li><li>悲观锁和乐观锁</li><li>ABA问题</li><li>互斥锁和共享锁</li><li>可重入锁和不可重入锁</li><li>AQS机制</li><li>RingBuffer</li><li>锁升级</li><li>锁消除</li><li>锁粗化</li></ul><h4 id="（5）并发容器"><a href="#（5）并发容器" class="headerlink" title="（5）并发容器"></a>（5）并发容器</h4><ul><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li><li>ConcurrentSkipSet</li><li>ConcurrentLinkedQueue</li><li>CopyOnWriteArrayList</li><li>阻塞队列</li><li>优先级队列</li></ul><h4 id="（6）线程池"><a href="#（6）线程池" class="headerlink" title="（6）线程池"></a>（6）线程池</h4><ul><li>线程池的几种状态切换</li><li>线程池的参数</li><li>线程池的启动流程</li><li>线程池的分类</li><li>线程池的大小设置</li></ul><h3 id="6、JVM"><a href="#6、JVM" class="headerlink" title="6、JVM"></a>6、JVM</h3><ul><li>java内存结构（jdk1.7和1.8）</li><li>垃圾回收机制</li><li>类加载机制</li><li>内存分类和回收</li><li>四种引用（强、软、弱、虚）</li><li>内存溢出</li><li>JVM调优工具</li><li>垃圾回收器</li><li>ZGC的认识</li><li>JNI</li><li>内存逃逸</li></ul><h2 id="三、必备基础"><a href="#三、必备基础" class="headerlink" title="三、必备基础"></a>三、必备基础</h2><h3 id="1、设计模式"><a href="#1、设计模式" class="headerlink" title="1、设计模式"></a>1、设计模式</h3><ul><li>创建型模式</li><li>结构性模式</li><li>行为性模式</li><li>设计模式的六种原则</li><li>MVC模型</li><li>MVVC模型</li><li>UML</li><li>康威定理</li></ul><h3 id="2、Linux"><a href="#2、Linux" class="headerlink" title="2、Linux"></a>2、Linux</h3><ul><li>Linux目录结构</li><li>常见命令</li><li>文件系统管理</li><li>用户系统管理</li><li>进程管理</li><li>网络管理</li><li>备份与恢复</li><li>文本文件处理命令</li><li>shell编程</li></ul><h3 id="3、代码工具"><a href="#3、代码工具" class="headerlink" title="3、代码工具"></a>3、代码工具</h3><ul><li>Git</li><li>Maven</li><li>gradle</li><li>日志框架</li><li>Junit</li></ul><h2 id="四、数据库"><a href="#四、数据库" class="headerlink" title="四、数据库"></a>四、数据库</h2><h3 id="1、mysql"><a href="#1、mysql" class="headerlink" title="1、mysql"></a>1、mysql</h3><h4 id="（1）基本知识-1"><a href="#（1）基本知识-1" class="headerlink" title="（1）基本知识"></a>（1）基本知识</h4><ul><li>三大范式</li><li>数据库、数据表、字段的增删改查基本操作</li><li>分区表</li><li>视图</li><li>外键约束</li><li>游标</li><li>变量</li><li>存储过程</li><li>函数</li><li>字符集</li></ul><h4 id="（2）存储引擎"><a href="#（2）存储引擎" class="headerlink" title="（2）存储引擎"></a>（2）存储引擎</h4><ul><li>InnoDB</li><li>MyISAM</li><li>转换表的引擎</li></ul><h4 id="（3）事务"><a href="#（3）事务" class="headerlink" title="（3）事务"></a>（3）事务</h4><ul><li>隔离级别</li><li>多版本并发工具</li><li>分布式事务</li><li>ACID特性</li></ul><h4 id="（4）索引"><a href="#（4）索引" class="headerlink" title="（4）索引"></a>（4）索引</h4><ul><li>聚集索引</li><li>非聚集索引</li><li>复合索引</li><li>底层实现原理</li></ul><h4 id="（5）锁"><a href="#（5）锁" class="headerlink" title="（5）锁"></a>（5）锁</h4><h4 id="（6）测试"><a href="#（6）测试" class="headerlink" title="（6）测试"></a>（6）测试</h4><h4 id="（7）优化方案"><a href="#（7）优化方案" class="headerlink" title="（7）优化方案"></a>（7）优化方案</h4><ul><li>数据类型优化</li><li>索引优化</li><li>查询性能优化</li><li>mysql配置优化</li><li>硬件优化</li></ul><h4 id="（8）高可用方案"><a href="#（8）高可用方案" class="headerlink" title="（8）高可用方案"></a>（8）高可用方案</h4><h4 id="（9）复制迁移"><a href="#（9）复制迁移" class="headerlink" title="（9）复制迁移"></a>（9）复制迁移</h4><h3 id="2、Redis"><a href="#2、Redis" class="headerlink" title="2、Redis"></a>2、Redis</h3><ul><li>持久化机制</li><li>缓存三种问题（穿透、击穿、雪崩）</li><li>内存淘汰策略</li><li>哨兵机制</li><li>集群方案</li><li>复制原理</li></ul><h3 id="3、MongoDB"><a href="#3、MongoDB" class="headerlink" title="3、MongoDB"></a>3、MongoDB</h3><h3 id="4、Hbase"><a href="#4、Hbase" class="headerlink" title="4、Hbase"></a>4、Hbase</h3><h2 id="五、常用基本框架"><a href="#五、常用基本框架" class="headerlink" title="五、常用基本框架"></a>五、常用基本框架</h2><h3 id="1、servlet"><a href="#1、servlet" class="headerlink" title="1、servlet"></a>1、servlet</h3><h3 id="2、Spring系列家族"><a href="#2、Spring系列家族" class="headerlink" title="2、Spring系列家族"></a>2、Spring系列家族</h3><h3 id="3、Mybatis"><a href="#3、Mybatis" class="headerlink" title="3、Mybatis"></a>3、Mybatis</h3><h3 id="4、JPA"><a href="#4、JPA" class="headerlink" title="4、JPA"></a>4、JPA</h3><h3 id="5、Netty"><a href="#5、Netty" class="headerlink" title="5、Netty"></a>5、Netty</h3><h3 id="6、websocket"><a href="#6、websocket" class="headerlink" title="6、websocket"></a>6、websocket</h3><h2 id="六、运维统计相关"><a href="#六、运维统计相关" class="headerlink" title="六、运维统计相关"></a>六、运维统计相关</h2><h3 id="1、平台监控"><a href="#1、平台监控" class="headerlink" title="1、平台监控"></a>1、平台监控</h3><ul><li>zabbix、Nagios、Ganglia等</li><li>Linux命令监控：top、sar、tsar、nload等</li><li>JVM监控工具</li></ul><h3 id="2、APM"><a href="#2、APM" class="headerlink" title="2、APM"></a>2、APM</h3><h3 id="3、持续集成"><a href="#3、持续集成" class="headerlink" title="3、持续集成"></a>3、持续集成</h3><ul><li>持续集成工具Jenkins</li><li>TeamCity</li><li>Travis CI</li><li>GitLab CI</li><li>环境分离</li></ul><h3 id="4、容器相关"><a href="#4、容器相关" class="headerlink" title="4、容器相关"></a>4、容器相关</h3><ul><li>Docker</li><li>K8S</li></ul><h3 id="5、虚拟化"><a href="#5、虚拟化" class="headerlink" title="5、虚拟化"></a>5、虚拟化</h3><ul><li>KVM</li><li>Xen</li><li>OpenVZ</li></ul><h3 id="6、自动化运维"><a href="#6、自动化运维" class="headerlink" title="6、自动化运维"></a>6、自动化运维</h3><ul><li>Ansible</li><li>puppet</li><li>chef</li></ul><h3 id="7、测试"><a href="#7、测试" class="headerlink" title="7、测试"></a>7、测试</h3><ul><li>单元测试</li><li>压力测试</li><li>灰度测试</li><li>A/B测试</li><li>蓝绿测试</li><li>TDD测试理论</li><li>全链路测试</li></ul><h2 id="七、中间件"><a href="#七、中间件" class="headerlink" title="七、中间件"></a>七、中间件</h2><h3 id="1、web"><a href="#1、web" class="headerlink" title="1、web"></a>1、web</h3><ul><li>Nginx</li><li>OpenRestry</li><li>Tengine</li><li>ApacheHttpd</li></ul><h3 id="2、服务器"><a href="#2、服务器" class="headerlink" title="2、服务器"></a>2、服务器</h3><ul><li>Tomcat</li><li>Jetty</li><li>WebLogic</li><li>JBoss</li></ul><h3 id="3、缓存"><a href="#3、缓存" class="headerlink" title="3、缓存"></a>3、缓存</h3><ul><li>本地缓存</li><li>客户端缓存</li><li>web缓存</li><li>Memcached</li><li>Redis</li><li>Tair</li><li>cellar</li></ul><h3 id="4、消息队列"><a href="#4、消息队列" class="headerlink" title="4、消息队列"></a>4、消息队列</h3><ul><li>Kafka</li><li>ActiveMQ</li><li>RocketMQ</li><li>RabbitMQ</li><li>Redis消息队列</li><li>ZeroMQ</li></ul><h3 id="5、RPC"><a href="#5、RPC" class="headerlink" title="5、RPC"></a>5、RPC</h3><ul><li>Dubbo</li><li>Thrift</li><li>gRPC</li><li>java的RMI</li></ul><h3 id="6、定时任务"><a href="#6、定时任务" class="headerlink" title="6、定时任务"></a>6、定时任务</h3><ul><li>Quartz</li><li>cron定时调度</li><li>java定时任务</li><li>Elastic-job</li><li>opencron</li><li>LTS</li></ul><h3 id="7、数据库中间件"><a href="#7、数据库中间件" class="headerlink" title="7、数据库中间件"></a>7、数据库中间件</h3><ul><li>Mycat</li><li>Sharding Jdbc</li></ul><h3 id="8、搜索引擎"><a href="#8、搜索引擎" class="headerlink" title="8、搜索引擎"></a>8、搜索引擎</h3><ul><li>Lucene</li><li>Elasticsearch</li><li>Solr</li><li>sphinx</li></ul><h2 id="八、微服务"><a href="#八、微服务" class="headerlink" title="八、微服务"></a>八、微服务</h2><h3 id="1、微服务框架"><a href="#1、微服务框架" class="headerlink" title="1、微服务框架"></a>1、微服务框架</h3><ul><li>Springcloud</li><li>SpringCloud Alibaba</li><li>Dropwizard</li><li>Akka</li></ul><h3 id="2、注册中心"><a href="#2、注册中心" class="headerlink" title="2、注册中心"></a>2、注册中心</h3><ul><li>Eureka</li><li>Zookeeper</li><li>Consul</li></ul><h3 id="3、服务调用"><a href="#3、服务调用" class="headerlink" title="3、服务调用"></a>3、服务调用</h3><ul><li>Feigh</li><li>restTemplete</li></ul><h3 id="4、负载均衡"><a href="#4、负载均衡" class="headerlink" title="4、负载均衡"></a>4、负载均衡</h3><ul><li>Ribbon</li></ul><h3 id="5、网关"><a href="#5、网关" class="headerlink" title="5、网关"></a>5、网关</h3><ul><li>Gateway</li><li>kong</li><li>zuul</li></ul><h3 id="6、配置中心"><a href="#6、配置中心" class="headerlink" title="6、配置中心"></a>6、配置中心</h3><ul><li>Zookeeper</li><li>Apollo</li><li>Springcloud Config</li></ul><h3 id="7、链路跟踪"><a href="#7、链路跟踪" class="headerlink" title="7、链路跟踪"></a>7、链路跟踪</h3><ul><li>SpringCloud Bus</li><li>SpringCloud Sleuth</li><li>Zipkin</li><li>Dapper</li><li>log-based</li><li>HTrace</li></ul><h2 id="九、分布式"><a href="#九、分布式" class="headerlink" title="九、分布式"></a>九、分布式</h2><h3 id="1、分布式理论"><a href="#1、分布式理论" class="headerlink" title="1、分布式理论"></a>1、分布式理论</h3><ul><li>CAP理论</li><li>BASE理论</li><li>幂等性</li><li>分布式锁<ul><li>redis实现</li><li>数据库实现</li><li>Zookeeper实现</li></ul></li></ul><h3 id="2、一致性算法"><a href="#2、一致性算法" class="headerlink" title="2、一致性算法"></a>2、一致性算法</h3><ul><li>Paxos</li><li>ZAB</li><li>Raft</li><li>Gossip</li><li>两阶段提交协议</li><li>节点选举策略</li><li>一致性hash算法</li></ul><h3 id="3、分布式文件系统"><a href="#3、分布式文件系统" class="headerlink" title="3、分布式文件系统"></a>3、分布式文件系统</h3><ul><li>HDFS</li><li>fastDFS</li></ul><h3 id="4、分布式ID"><a href="#4、分布式ID" class="headerlink" title="4、分布式ID"></a>4、分布式ID</h3><ul><li>Snowflake算法</li><li>Flicker算法</li><li>UUID</li><li>MongoDB实现</li></ul><h3 id="5、分布式事务"><a href="#5、分布式事务" class="headerlink" title="5、分布式事务"></a>5、分布式事务</h3><ul><li>多阶段提交</li><li>TCC补偿事务</li><li>本地消息表</li><li>MQ事务消息</li><li>最大努力通知</li></ul><h3 id="6、稳定性高可用方案"><a href="#6、稳定性高可用方案" class="headerlink" title="6、稳定性高可用方案"></a>6、稳定性高可用方案</h3><ul><li>软硬件负载均衡</li><li>限流</li><li>容灾</li><li>平滑启动</li></ul><h2 id="十、安全"><a href="#十、安全" class="headerlink" title="十、安全"></a>十、安全</h2><h3 id="1、web安全"><a href="#1、web安全" class="headerlink" title="1、web安全"></a>1、web安全</h3><ul><li>XSS</li><li>CRSF</li><li>SQL注入</li><li>DDOS</li><li>DNS攻击</li><li>脚本注入</li><li>序列化攻击</li><li>中间人攻击</li></ul><h3 id="2、加密解密算法"><a href="#2、加密解密算法" class="headerlink" title="2、加密解密算法"></a>2、加密解密算法</h3><ul><li>对称加密</li><li>非对称加密</li><li>hash算法</li><li>数字签名</li><li>Base64</li></ul><h3 id="3、框架"><a href="#3、框架" class="headerlink" title="3、框架"></a>3、框架</h3><ul><li>Shiro</li><li>SpringSecurity</li></ul><h3 id="4、授权认证"><a href="#4、授权认证" class="headerlink" title="4、授权认证"></a>4、授权认证</h3><ul><li>RBAC</li><li>OAuth2.0</li><li>OIDC</li><li>SAML</li><li>TLS全链路加密</li><li>JWT用户认证</li><li>Check前置检查</li><li>Quota配额管理</li><li>Telemetry遥测报告</li><li>双因素认证（2FA）</li><li>单点登录SSO</li></ul><h2 id="十一、项目管理"><a href="#十一、项目管理" class="headerlink" title="十一、项目管理"></a>十一、项目管理</h2><h3 id="1、开发设计"><a href="#1、开发设计" class="headerlink" title="1、开发设计"></a>1、开发设计</h3><ul><li>DDD领域驱动模型</li><li>Actor模式</li><li>响应式编程</li><li>DODAF2.0</li><li>Serverless</li><li>Service Mesh</li></ul><h3 id="2、项目管理"><a href="#2、项目管理" class="headerlink" title="2、项目管理"></a>2、项目管理</h3><ul><li>代码规范</li><li>敏捷开发</li><li>极限编程</li><li>结对编程</li><li>RUP</li><li>SCRUM</li><li>PDCA循环质量管理</li><li>FMEA管理模式</li></ul><h3 id="3、架构管理"><a href="#3、架构管理" class="headerlink" title="3、架构管理"></a>3、架构管理</h3><ul><li>DevOps</li><li>OpenGroup</li><li>ABSD架构方法论</li><li>架构设计原则</li><li>异地多活</li><li>Knative弹性伸缩</li></ul><h2 id="十二、大数据云计算"><a href="#十二、大数据云计算" class="headerlink" title="十二、大数据云计算"></a>十二、大数据云计算</h2><h3 id="1、流式计算"><a href="#1、流式计算" class="headerlink" title="1、流式计算"></a>1、流式计算</h3><ul><li>storm</li><li>Flink</li><li>KafkaStream</li></ul><h3 id="2、Hadoop"><a href="#2、Hadoop" class="headerlink" title="2、Hadoop"></a>2、Hadoop</h3><ul><li>HDFS</li><li>MapReduce</li><li>Yarn</li><li>Spark</li></ul><h2 id="十三、开发工具"><a href="#十三、开发工具" class="headerlink" title="十三、开发工具"></a>十三、开发工具</h2><ul><li>IDEA</li><li>VSCode</li><li>VIM</li><li>Gitlab</li><li>Navicat</li><li>XShell</li><li>postman</li><li>Filezilla</li><li>Fiddler</li></ul><h2 id="十四、学习资源"><a href="#十四、学习资源" class="headerlink" title="十四、学习资源"></a>十四、学习资源</h2><h3 id="1、视频网站"><a href="#1、视频网站" class="headerlink" title="1、视频网站"></a>1、视频网站</h3><ul><li>B站</li><li>慕课网</li><li>中国大学MOOC网</li></ul><h3 id="2、博客社区"><a href="#2、博客社区" class="headerlink" title="2、博客社区"></a>2、博客社区</h3><ul><li>CSDN</li><li>开源中国</li><li>简书</li><li>思否</li><li>掘金</li><li>博客园</li><li>阿里云社区</li><li>开发者头条</li><li>Medium</li></ul><h3 id="3、技术手册"><a href="#3、技术手册" class="headerlink" title="3、技术手册"></a>3、技术手册</h3><ul><li>W3Cschool</li><li>Runoob.com</li><li>慕课网教程手册</li></ul><h3 id="4、行业资讯"><a href="#4、行业资讯" class="headerlink" title="4、行业资讯"></a>4、行业资讯</h3><ul><li>知乎</li><li>stackoverflow</li></ul><h3 id="5、代码托管"><a href="#5、代码托管" class="headerlink" title="5、代码托管"></a>5、代码托管</h3><ul><li>github</li><li>gitee</li><li>coding</li></ul><h3 id="6、电子书网站"><a href="#6、电子书网站" class="headerlink" title="6、电子书网站"></a>6、电子书网站</h3><ul><li>gitbook</li><li>aibooks</li><li>书栈网</li><li>搬书匠</li><li>鸠摩搜索</li><li>IT-ebooks国外免费</li></ul><h3 id="7、程序员交流网站"><a href="#7、程序员交流网站" class="headerlink" title="7、程序员交流网站"></a>7、程序员交流网站</h3><ul><li>V2EX</li><li>知乎</li></ul><h3 id="8、云服务器"><a href="#8、云服务器" class="headerlink" title="8、云服务器"></a>8、云服务器</h3><ul><li>阿里云</li><li>腾讯云</li><li>百度云</li><li>华为云</li><li>七牛云</li><li>西部数据</li><li>金山云</li></ul><h3 id="9、面试刷题"><a href="#9、面试刷题" class="headerlink" title="9、面试刷题"></a>9、面试刷题</h3><ul><li>LinkCode</li><li>LeetCode</li><li>牛客网</li></ul><h3 id="10、找工作"><a href="#10、找工作" class="headerlink" title="10、找工作"></a>10、找工作</h3><ul><li>100offer</li><li>拉勾网</li></ul><h3 id="11、数据资源下载"><a href="#11、数据资源下载" class="headerlink" title="11、数据资源下载"></a>11、数据资源下载</h3><ul><li>国家数据</li><li>MSDN</li><li>PUDN</li><li>OPSX阿里巴巴开源镜像</li><li>TUNA清华开源软件</li><li>163网易开源镜像</li></ul><h3 id="12、编程外包"><a href="#12、编程外包" class="headerlink" title="12、编程外包"></a>12、编程外包</h3><ul><li>大神部落</li><li>程序员客栈</li><li>码市</li><li>开源众包</li></ul><p>本内容为第一版，后序将继续更新。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java学习路线</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java中的日志框架体系梳理（简单直白，故事叙述）</title>
    <link href="/2021/01/02/%E4%B8%83%E3%80%81%E5%B7%A5%E5%85%B7/%E6%97%A5%E5%BF%97/java%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%9B%B4%E7%99%BD%EF%BC%8C%E6%95%85%E4%BA%8B%E5%8F%99%E8%BF%B0%EF%BC%89/"/>
    <url>/2021/01/02/%E4%B8%83%E3%80%81%E5%B7%A5%E5%85%B7/%E6%97%A5%E5%BF%97/java%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%9B%B4%E7%99%BD%EF%BC%8C%E6%95%85%E4%BA%8B%E5%8F%99%E8%BF%B0%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><p>平时写代码目前也开始慢慢体会到了日志的重要作用。日志算是java工具体系的一个知识点，但又是写代码的时候绕不过去的一个知识点，以故事的形式来对目前市场上常见的一些日志框架进行一个介绍和梳理。旨在从整个日志体系的角度进行一次梳理。</p><h2 id="阶段一："><a href="#阶段一：" class="headerlink" title="阶段一："></a><strong>阶段一：</strong></h2><p>从前有一个程序员，名字叫张三，张三呢，每天矜矜业业，业务能力代码能力都很强。老板就让他负责一个比较复杂的系统。于是张三呢，每天使用System.out.println()，在控制台打印出来一些关键的信息。这时候麻烦来了，项目需要上线了，总不能还要把这些没用的信息输出到控制台吧，于是老板让张三把这些语句全部去掉。这么庞大的系统，张三找呀找，终于把所有的System.out语句全部注释掉了。</p><h2 id="阶段二："><a href="#阶段二：" class="headerlink" title="阶段二："></a><strong>阶段二：</strong></h2><p>过了一段时间呢，项目遇到了一些问题，老板突然想起来张三之前写过System.out的相关语句，觉得有必要把一些关键信息打印出来，于是又让张三把所有的System.out语句添加进来，这下子又把张三忙活的不轻，累了一天终于又改过来了。在找出错误之后，然后再重新去掉。</p><h2 id="阶段三："><a href="#阶段三：" class="headerlink" title="阶段三："></a><strong>阶段三：</strong></h2><p>就这样来回折腾了几次，把张三气的不轻，毕竟需求总是会不断的变化的，于是张三考虑做一个框架，记录系统运行的一些必要的信息，而且日志的内容可以随时打印，也可以随时关闭。这个框架就叫做日志框架，在这里且命名为logging-jar。于是开始投入了运行。</p><h2 id="阶段四："><a href="#阶段四：" class="headerlink" title="阶段四："></a><strong>阶段四：</strong></h2><p>又过了一段时间，张三又发现了问题。在设计的第一代日志框架logging-jar中，总是会把各种各样的运行信息打印出来，这对于张三来说只想要找出一些错误信息，他必须要在很长的一个控制台去寻找。于是张三考虑着如何改进这个框架，比如说把输出信息分类，有异常信息，有错误信息，还有警告信息等等。这对于张三来说，开发起来太便利了。叫做logging-good-jar。</p><h2 id="阶段五："><a href="#阶段五：" class="headerlink" title="阶段五："></a><strong>阶段五：</strong></h2><p>老板一看，张三业务能力这么强，干脆把其他的一些项目也让张三带吧，于是张三又负责了一些其他的项目，但是问题又来了，其他的项目使用的不是张三的日志框架，而是其他的日志框架，怎么办呢？张三考虑着把这个项目的去掉，换成自己的不就可以了嘛，于是张三去掉了别人的，换成了自己的，又废了半天功夫更改了大量的日志api代码。</p><h2 id="阶段六："><a href="#阶段六：" class="headerlink" title="阶段六："></a><strong>阶段六：</strong></h2><p>随着张三业务能力的不断增强，负责的项目也越来越多，发现每次都要更改别人的日志框架换成自己的。实在是麻烦。于是张三考虑定义一些规则接口，其他的任何框架都要有相应的实现方法，这样做的好处就是每次张三就不需要去掉别人的，换成自己的。而是调用相应日志框架的相关实现即可。这个规则就叫做日志门面，也叫做日志框架的抽象层。实现这些规则接口的框架就叫做日志实现框架。</p><p><strong>这种就好比是定义好一个接口，这个接口就是日志门面。而日志实现框架就是接口的实现类。</strong></p><p><img src="https://s3.ax1x.com/2021/01/02/sSuqAO.png"></p><p>目前最受欢迎的就是这么几个。按照使用的角度来说，那就是左边选择一个日志门面，右边选择一个日志实现就好了。就这样他们之前进行了激烈的竞争。</p><blockquote><p><strong>Ceki Gülcü是一个java大佬，一开始发明了log4j，后来把这个捐给了Apache基金会，后来觉得这个功能不够牛，又发明了logback。后来又设计了slf4j</strong>。</p></blockquote><h2 id="阶段七："><a href="#阶段七：" class="headerlink" title="阶段七："></a><strong>阶段七：</strong></h2><p>随着时间的流逝，<strong>slf4j门面和logback日志实现框架</strong>脱颖而出。于是平时张三就用这个了。但是我们需要知道的是在使用的时候其实用的是日志门面slf4j的方法，而不用关心是哪一个实现的。springboot开发团队，一看这个搭配使用起来是真的好，于是就选用了他俩了。既然这么好，干脆我们使用springboot来整合一下他们俩。</p><h3 id="第一步：添加依赖"><a href="#第一步：添加依赖" class="headerlink" title="第一步：添加依赖"></a>第一步：添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第二步：配置日志"><a href="#第二步：配置日志" class="headerlink" title="第二步：配置日志"></a>第二步：配置日志</h3><p>在  src\main\resources 路径下创建logback.xml配置文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_HOME&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/home&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--控制台日志， 控制台输出 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--文件日志， 按照每天生成日志文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志文件输出的文件名--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">FileNamePattern</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--日志文件保留天数--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">MaxHistory</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--日志文件最大的大小--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">triggeringPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">MaxFileSize</span>&gt;</span>10MB<span class="hljs-tag">&lt;/<span class="hljs-name">MaxFileSize</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">triggeringPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--myibatis log configure--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.apache.ibatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;TRACE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.Connection&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.Statement&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;java.sql.PreparedStatement&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 日志输出级别 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的这些都是模板代码，你可以直接拿来用。下面我们就直接使用。</p><h3 id="第三步：使用"><a href="#第三步：使用" class="headerlink" title="第三步：使用"></a>第三步：使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/logging&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span></span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> HelloService helloService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger logger<br>            = LoggerFactory.getLogger(Hello.class);<br>    <span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        logger.info(<span class="hljs-string">&quot;这是日志框架的输出信息&quot;</span>);<br>        <span class="hljs-keyword">return</span> helloService.test();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果就不展示了。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解java中的几种编码方式？解决乱码问题可能并不麻烦</title>
    <link href="/2020/12/31/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/6%E3%80%81java%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BD%A0%E4%BA%86%E8%A7%A3java%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%AF%E8%83%BD%E5%B9%B6%E4%B8%8D%E9%BA%BB%E7%83%A6/"/>
    <url>/2020/12/31/%E4%BA%8C%E3%80%81java%E5%9F%BA%E7%A1%80/6%E3%80%81java%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BD%A0%E4%BA%86%E8%A7%A3java%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%AF%E8%83%BD%E5%B9%B6%E4%B8%8D%E9%BA%BB%E7%83%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编码的转换通常在IO机制中使用，一个好的编码可以为我们节省很多空间，在某种程度上提高我们应用的效率。由于之前就知道String中的转换方式，还有一些工具类，因此今天就好好的整理一下java中jdk提供的几种转换方式，希望对你有帮助。</p><h2 id="一、编码转换原理"><a href="#一、编码转换原理" class="headerlink" title="一、编码转换原理"></a><strong>一、编码转换原理</strong></h2><h3 id="1、为什么需要编码"><a href="#1、为什么需要编码" class="headerlink" title="1、为什么需要编码"></a><strong>1、为什么需要编码</strong></h3><p>我们知道计算机存储信息的最小单位是一个字节8位，能够表示256个字符。这对于早起的英文来说足够了。即使是加上一些常见符号也足够。于是在1965年美国制定了ASCII编码，主要用于英语和西欧语言，一开始128个，后来加到了256。</p><p>后来随着时间的发展，中国、日本等国的计算机也开始蓬勃发展，于是计算机不仅仅要存储英文了，也开始存储中文。但是中文我们都知道几万个太多了，一个字节肯定放不下。怎么办呢？一个字节表示不下，那就多用几个字节就好了。这样不仅可以表示汉字，还可以避免了与ASCII编码的冲突。这几个字节在存储的时候再转化为bit，完美！<strong>划重点哈，编码解决的就是字节和字符之间的转化问题。</strong></p><h2 id="2、编码方式"><a href="#2、编码方式" class="headerlink" title="2、编码方式"></a><strong>2、编码方式</strong></h2><p>既然是编码，那些大佬早就考虑到了这些问题，并提拱了多种编码方式，常见的有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等。它们规定了转化的规则，按照这个规则就可以让计算机正确的表示我们的字符。</p><p>像GB2312、GBK、UTF-8、UTF-16等很多种方式都可以表示汉字，他们有什么区别呢？</p><h4 id="（1）GB2312"><a href="#（1）GB2312" class="headerlink" title="（1）GB2312"></a>（1）GB2312</h4><p>它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。这个是中国1981年搞出来的。<strong>这种编码是一个汉字两个字节。</strong></p><h4 id="（2）GBK"><a href="#（2）GBK" class="headerlink" title="（2）GBK"></a>（2）GBK</h4><p>它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字。这个是中国在1995年搞出来的，主要是用于GB2312编码的补充。<strong>这种编码依然是一个汉字两个字节。</strong></p><h4 id="（3）Unicode"><a href="#（3）Unicode" class="headerlink" title="（3）Unicode"></a>（3）Unicode</h4><p>上面看到，中国可以做出了一个编码，日本也可以做出来一个编码，时间久了每个国家都有着自己的一套编码，就不可避免的造成冲突。于是Unicode出来了，把所有语言统一起来合成一个规则。<strong>这种编码是定长的字节数。</strong></p><h4 id="（4）UTF8"><a href="#（4）UTF8" class="headerlink" title="（4）UTF8"></a>（4）UTF8</h4><p>既然Unicode是定长的字节数，那么存储一个复杂的汉字可能需要三个字节，但是为了保证是2的幂数集，就会自动扩充为4个字节，别看着一个字节之差，存储的字数多了就会极大的浪费空间。是于是而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。</p><p>以上这些编码方式会为每一个汉字或者是字母建立一个编码库，在编码的时候字母和编码一一对应。</p><h3 id="3、为什么会出现乱码？"><a href="#3、为什么会出现乱码？" class="headerlink" title="3、为什么会出现乱码？"></a>3、为什么会出现乱码？</h3><p>这个问题就是因为编码和解码是采用了不同的或者是不兼容的编码方案。比如一个用UTF-8编码的后的字符。再用GBK去解码，由于两个字符集的编码库不一样。同一个汉字在两个编码库的位置也不一样。于是就出现了乱码。</p><h3 id="4、java如何解决乱码问题？"><a href="#4、java如何解决乱码问题？" class="headerlink" title="4、java如何解决乱码问题？"></a><strong>4、java如何解决乱码问题？</strong></h3><p>这个问题其实就是java中如何使用编码规则，因为使用好了编码规则。才可以很好地解决乱码问题。</p><h4 id="（1）IO流"><a href="#（1）IO流" class="headerlink" title="（1）IO流"></a><strong>（1）IO流</strong></h4><p>编码的目的上面已经说了，主要是字节和字符之间的转化。既然涉及到字节和字符很容易我们就能想到java中的IO流。也就是说java中编码的转换其实就是IO流中的类来实现的。</p><p><img src="https://s3.ax1x.com/2020/12/31/rjTKkq.png"></p><p>最核心的就是上面几个类，当然这里只是给出了输入的一部分，还有一些输出的类。</p><h4 id="（2）String"><a href="#（2）String" class="headerlink" title="（2）String"></a><strong>（2）String</strong></h4><p>String类中也提供了一些转码的方法。下面我们会通过实例来说明。为什么String可以实现呢？这是因为String底层保存的其实就是一个一个字节，而且String还有方法直接转化为字符。所以String肯定也能实现。</p><h4 id="（3）Charset"><a href="#（3）Charset" class="headerlink" title="（3）Charset"></a><strong>（3）Charset</strong></h4><p>这个Charset是javaNIO中的一个类，整个流程就是读取数据，然后转化为byte，也就是字符。然后重新编码成字符就OK了。</p><p>下面我们使用代码来实现一下：</p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a><strong>二、代码实现</strong></h2><h3 id="1、IO流"><a href="#1、IO流" class="headerlink" title="1、IO流"></a><strong>1、IO流</strong></h3><p>首先是IO流实现，这种通过输入输出流可以直接的指定编码规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertionFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;./愚公要移山.txt&quot;</span>);<br>FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(file);<br>InputStreamReader inReader = <span class="hljs-keyword">new</span> InputStreamReader(fis, <span class="hljs-string">&quot;gbk&quot;</span>);<br>FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>OutputStreamWriter outReader = <span class="hljs-keyword">new</span> OutputStreamWriter(fos, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>       <span class="hljs-comment">//这种输入gbk，输出utf-8肯定会出现错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、String"><a href="#2、String" class="headerlink" title="2、String"></a><strong>2、String</strong></h3><p>使用string是最方便的，代码也比较简洁，适用于字符串的编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertionString</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;<br>String s = <span class="hljs-string">&quot;愚公要移山，码农飞上天&quot;</span>;<br><span class="hljs-comment">// 正常情况下转码的过程</span><br><span class="hljs-keyword">byte</span>[] b = s.getBytes(<span class="hljs-string">&quot;gbk&quot;</span>);<span class="hljs-comment">// 编码</span><br>String sa = <span class="hljs-keyword">new</span> String(b, <span class="hljs-string">&quot;gbk&quot;</span>);<span class="hljs-comment">// 解码</span><br>System.out.println(sa);<br><span class="hljs-comment">// 错误状态下转码的过程</span><br>b = sa.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>);<span class="hljs-comment">// 编码使用utf-8</span><br>sa = <span class="hljs-keyword">new</span> String(b, <span class="hljs-string">&quot;gbk&quot;</span>);<span class="hljs-comment">// 解码使用gbk</span><br>System.err.println(sa);<br>&#125;<br><span class="hljs-comment">//控制台输出：</span><br><span class="hljs-comment">//愚公要移山，码农飞上天</span><br><span class="hljs-comment">//鎰氬叕瑕佺Щ灞憋紝鐮佸啘椋炰笂澶?</span><br></code></pre></td></tr></table></figure><h3 id="3、Charset"><a href="#3、Charset" class="headerlink" title="3、Charset"></a><strong>3、Charset</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertionCharset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>Charset charset = StandardCharsets.UTF_8;<br><span class="hljs-comment">// 从字符集中创建相应的编码和解码器</span><br>CharsetEncoder encoder = charset.newEncoder();<br>CharsetDecoder decoder = charset.newDecoder();<br><span class="hljs-comment">// 构造一个buffer</span><br>CharBuffer charBuffer = CharBuffer.allocate(<span class="hljs-number">64</span>);<br>charBuffer.put(<span class="hljs-string">&#x27;A&#x27;</span>);<br>charBuffer.flip();<br><span class="hljs-comment">// 将字符序列转换成字节序列</span><br>ByteBuffer bb = encoder.encode(charBuffer);<br><span class="hljs-comment">// 将字节序列转换成字符序列</span><br>bb.flip();<br>CharBuffer cb = decoder.decode(bb);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是三种基本的实现方式，当然还有一些其他的，比如Spring中提供的编码转换工具等等。在这里就不说了，因为技术太多，实现的方式也太多，我们就看这几种即可。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
      <category>碎知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
      <tag>java基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐使用for-each循环代替for循环</title>
    <link href="/2020/12/28/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8for-each%E5%BE%AA%E7%8E%AF%E4%BB%A3%E6%9B%BFfor%E5%BE%AA%E7%8E%AF/"/>
    <url>/2020/12/28/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8for-each%E5%BE%AA%E7%8E%AF%E4%BB%A3%E6%9B%BFfor%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文基于《Effective java》第三版第58条</strong></p></blockquote><p>for循环是平时写代码用的最多的，但是之前看《effectivejava》大佬在某些场景写并不推荐。结合着自己之前刷算法题的经历。收益匪浅。</p><h2 id="一、for循环的缺点"><a href="#一、for循环的缺点" class="headerlink" title="一、for循环的缺点"></a>一、for循环的缺点</h2><p>在以往遍历元素的时候，我们通常采用以下的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//1、数组元素</span><br><span class="hljs-keyword">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">//数组的遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num.length;i++) <br>System.out.println(num[i]);<br><span class="hljs-comment">//2、对象元素</span><br>ArrayList&lt;Person&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>lists.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>));<br>lists.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>));<br>lists.add(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;愚公要移山&quot;</span>));<br><span class="hljs-comment">//对象元素的遍历</span><br><span class="hljs-keyword">for</span>(Iterator&lt;Person&gt; it=lists.iterator();it.hasNext();) &#123;<br>Person p = it.next();<br>System.out.println(p.getName());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法看起来还不错，但是却并不完美。我们来分析一下，有什么缺点。然后给出解决方案。</p><h3 id="问题1：迭代器或索引多次出现，容易造成使用错误"><a href="#问题1：迭代器或索引多次出现，容易造成使用错误" class="headerlink" title="问题1：迭代器或索引多次出现，容易造成使用错误"></a>问题1：迭代器或索引多次出现，容易造成使用错误</h3><p>从上面两种遍历的代码上来看，对于数组元素是通过索引i来遍历的，但是整个for循环出现了四次i，对于对象元素是通过迭代器it来遍历的，但是整个for循环出现了三次it。在for循环遍历元素的时候，就有多次机会使用了错误的变量。而且有时候这些错误编译器无法发现。对整个应用系统造成无法预知的错误。</p><h3 id="问题2：遍历对象元素时，需要注意容器类型"><a href="#问题2：遍历对象元素时，需要注意容器类型" class="headerlink" title="问题2：遍历对象元素时，需要注意容器类型"></a>问题2：遍历对象元素时，需要注意容器类型</h3><p>比如我们这里使用的是list，当然还有可能是其他容器类型，这些类型在更改时比较麻烦。</p><h3 id="问题3：嵌套迭代抛出异常"><a href="#问题3：嵌套迭代抛出异常" class="headerlink" title="问题3：嵌套迭代抛出异常"></a>问题3：嵌套迭代抛出异常</h3><p>这种情况比较复杂一些，先来搞个例子。比如说，我们想要列举每种花，这些花有两种属性一种是颜色，一种是大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-comment">//枚举颜色和尺寸</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, BLUE, BLACK &#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span> </span>&#123; ONE, TWO, THREE, FOUR, FIVE,<br>SIX, SEVEN, EIGHT,NINE, TEN&#125;<br><span class="hljs-comment">//定义花</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flower</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Flower</span><span class="hljs-params">(Color color, Size size)</span> </span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Color&gt; colors = Arrays.asList(Color.values());<br>Collection&lt;Size&gt; sizes = Arrays.asList(Size.values());<br>List&lt;Flower&gt; flowers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">//for循环添加所有的花和尺寸</span><br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; color = colors.iterator(); color.hasNext(); ) &#123;<br><span class="hljs-keyword">for</span> (Iterator&lt;Size&gt; size = sizes.iterator(); size.hasNext(); ) &#123;<br>flowers.add(<span class="hljs-keyword">new</span> Flower(color.next(), size.next()));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看似人畜无害，现在我们运行一波。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.NoSuchElementException<br>at java.util.AbstractList$Itr.next(Unknown Source)<br>at com.f2.Main.main(Main.java:<span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><p>是不是感觉有点奇怪，好像双重循环遍历没啥问题，但是出现了异常，原因是外部的Color迭代器调用了多次，第一层for循环被调用了，但是又在第二层for循环内部被调用了，所以color的next被调用完了。所以出现了NoSuchElementException。但是有时候也不会出现这种情况，场景是外部循环迭代器调用的次数刚好是内部调用的n倍。</p><h3 id="问题4：嵌套迭代不抛异常，但是结果不正确"><a href="#问题4：嵌套迭代不抛异常，但是结果不正确" class="headerlink" title="问题4：嵌套迭代不抛异常，但是结果不正确"></a>问题4：嵌套迭代不抛异常，但是结果不正确</h3><p>这种情况是外部循环迭代器调用的次数刚好是内部调用的n倍。我们再来个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-comment">//枚举颜色</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, BLUE, BLACK &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Color&gt; colors = Arrays.asList(Color.values());<br><span class="hljs-comment">//两层for循环</span><br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; c1 = colors.iterator(); c1.hasNext(); ) &#123;<br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; c2 = colors.iterator(); c2.hasNext(); ) &#123;<br>System.out.println(c1.next()+<span class="hljs-string">&quot; &quot;</span>+c2.next());<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在对颜色进行for循环遍历，一共两层for循环，因为一共有四种颜色，两层for循环应该是打印16个结果。现在运行一遍看看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">RED RED<br>GREEN GREEN<br>BLUE BLUE<br>BLACK BLACK<br></code></pre></td></tr></table></figure><p>没错，确实是打印了四条。原因和<strong>问题三</strong>是一样的。有一种方式可以很好地解决这种嵌套的问题。</p><h3 id="嵌套迭代问题解决："><a href="#嵌套迭代问题解决：" class="headerlink" title="嵌套迭代问题解决："></a>嵌套迭代问题解决：</h3><p>直接看代码。既然是外部的迭代器it在内部使用了，那我在内部和外部之间用一个变量缓存起来不久好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-comment">//枚举颜色</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, BLUE, BLACK &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Color&gt; colors = Arrays.asList(Color.values());<br><span class="hljs-comment">//for循环</span><br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; c1 = colors.iterator(); c1.hasNext(); ) &#123;<br><span class="hljs-comment">//用一个变量缓存起来</span><br>Color c = c1.next();<br><span class="hljs-keyword">for</span> (Iterator&lt;Color&gt; c2 = colors.iterator(); c2.hasNext(); ) &#123;<br>System.out.println(c+<span class="hljs-string">&quot; &quot;</span>+c2.next());<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在再来运行，就可以很好地得出16种结果了。这种方式也比较不错，但是却不能很好地解决问题1和问题2。因此，为了解决这一现象，大佬Joshua Bloch在书中提出，推荐使用for-each循环来代替for循环。</p><h2 id="二、for-each循环"><a href="#二、for-each循环" class="headerlink" title="二、for-each循环"></a>二、for-each循环</h2><p>既然作者推荐使用for-each循环，我们看看他有什么好处。是如何解决上面的问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-comment">//枚举颜色和尺寸</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123; RED, GREEN, BLUE, BLACK &#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span> </span>&#123; ONE, TWO, THREE, FOUR, FIVE,<br>SIX, SEVEN, EIGHT,NINE, TEN&#125;<br><span class="hljs-comment">//定义花</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flower</span></span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Flower</span><span class="hljs-params">(Color color, Size size)</span> </span>&#123;&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Collection&lt;Color&gt; colors = Arrays.asList(Color.values());<br>Collection&lt;Size&gt; sizes = Arrays.asList(Size.values());<br>List&lt;Flower&gt; flowers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-comment">//for-each循环</span><br><span class="hljs-keyword">for</span> (Color color:colors) &#123;<br><span class="hljs-keyword">for</span> (Size size:sizes ) &#123;<br>flowers.add(<span class="hljs-keyword">new</span> Flower(color, size));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看里面的for-each循环。上面的问题就全都解决了。好吧，可能你会感觉，就这？还有一个好处还没说，再往下看。</p><p>for-each 循环不仅允许遍历集合和数组，还允许遍历实现 Iterable 接口的任何对象，该接口由单个方法组成。接<br>口定义如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><span class="hljs-comment">// Returns an iterator over the elements in this iterable</span><br><span class="hljs-function">Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果必须从头开始编写自己的 Iterator 实现，那么实现 Iterable 会有点棘手，但是如果你正在编写表示一组元素<br>的类型，那么你应该强烈考虑让它实现 Iterable 接口，甚至可以选择不让它实现 Collection 接口。这允许用户使用for-each 循环遍历类型，他们会永远感激不尽的 。</p><p>但是，有三种常见的情况是你不能分别使用 for-each 循环的:</p><p><strong>（1）有损过滤（</strong>Destructive filtering）：如果需要遍历集合，并删除指定选元素，则需要使用显式迭代器，以便可以调用其 remove 方法。 通常可以使用在 Java 8 中添加的 Collection 类中的 removeIf 方法，来避免显式遍历。</p><p><strong>（2）转换</strong>：如果需要遍历一个列表或数组并替换其元素的部分或全部值，那么需要列表迭代器或数组索引来替换元素的值。</p><p><strong>（3）并行迭代</strong>：如果需要并行地遍历多个集合，那么需要显式地控制迭代器或索引变量，以便所有迭代器或索引变量都可以同步进行 。</p><p>如果发现自己处于这些情况中的任何一种，请使用传统的 for 循环，并警惕本条目中提到的陷阱 。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>写代码的建议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我在一个构造方法里面写了30个参数，老板看了想骂人</title>
    <link href="/2020/12/26/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%88%91%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E5%86%99%E4%BA%8630%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%81%E6%9D%BF%E7%9C%8B%E4%BA%86%E6%83%B3%E9%AA%82%E4%BA%BA/"/>
    <url>/2020/12/26/%E5%85%AD%E3%80%81%E9%AB%98%E6%95%88java/%E6%88%91%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E5%86%99%E4%BA%8630%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E8%80%81%E6%9D%BF%E7%9C%8B%E4%BA%86%E6%83%B3%E9%AA%82%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文基于《Effective java》第二条</strong></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般我们写参数如果写个一两个，那就可以了，如果写七八个，那就有点难受了。如果写十几个？尼玛，难受，我要去缓缓。</p><p><img src="https://s3.ax1x.com/2020/12/26/rhBVgK.png"></p><p>于是乎，一种新的方法策略运用而生。那就是builder模式，在构造方法的参数过多时，可以方便的进行创建一个类对象。所以本文的中心主旨一句话总结：<strong>当构造方法的参数过多时，推荐使用builder模式</strong></p><p>既然推荐使用builder模式，那我们一个一个来，分析一下如果不使用builder模式有什么缺点。</p><h2 id="一、传统方式的缺点"><a href="#一、传统方式的缺点" class="headerlink" title="一、传统方式的缺点"></a>一、传统方式的缺点</h2><h3 id="1、可伸缩构造方法"><a href="#1、可伸缩构造方法" class="headerlink" title="1、可伸缩构造方法"></a>1、可伸缩构造方法</h3><p>可伸缩构造方法就是我们平时书写最常见的那种，请看下文代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">//可选</span><br><span class="hljs-comment">//构造函数1：默认构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br><span class="hljs-comment">//构造方法2：必要字段构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-comment">//构造方法3：全部字段构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name, <span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> sclass, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">float</span> weight, <span class="hljs-keyword">float</span> score)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">this</span>.sclass = sclass;<br><span class="hljs-keyword">this</span>.height = height;<br><span class="hljs-keyword">this</span>.weight = weight;<br><span class="hljs-keyword">this</span>.score = score;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面如果我们要创建一个Student类，一般这样创建，看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//1、可伸缩构造方法</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;愚公要移山&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1</span>,<span class="hljs-number">175</span>,<span class="hljs-number">120</span>,<span class="hljs-number">99</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们列举了一个具有七个字段的例子，比较容易理解，现在我们来分析一下，他有什么缺点：</p><h4 id="缺点1：反转字段，编译器不会报错"><a href="#缺点1：反转字段，编译器不会报错" class="headerlink" title="缺点1：反转字段，编译器不会报错"></a>缺点1：反转字段，编译器不会报错</h4><p>比如上面的字段里面有一个weight和一个score，都是float类型，如果再new一个Student类时，不小心写反了，编译器不会察觉。</p><h4 id="缺点2：难以理解"><a href="#缺点2：难以理解" class="headerlink" title="缺点2：难以理解"></a>缺点2：难以理解</h4><p>这里只是七个字段，如果有十几个，我们就需要不断地去Student类中去查看，看看第几个参数应该写哪些东西，实在是比较麻烦。用户在看到这个Student(2,”愚公要移山”,18,1,175,120,99)无法理解每一个字段属性代表的是什么含义。</p><h4 id="缺点3：不想设置的参数，却不得不设置值"><a href="#缺点3：不想设置的参数，却不得不设置值" class="headerlink" title="缺点3：不想设置的参数，却不得不设置值"></a>缺点3：不想设置的参数，却不得不设置值</h4><p>有时候我们的Student只想着设置ID、name和age字段，其他的无关紧要，但是这种模式必须要设置所有的属性值。</p><p>既然上面有这些缺点，我们可能还想到另外一种方式，那就是javaBean。</p><h3 id="2、javaBean模式"><a href="#2、javaBean模式" class="headerlink" title="2、javaBean模式"></a>2、javaBean模式</h3><p>先看javaBean模式如何写的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">//可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">//可选</span><br><span class="hljs-comment">//构造函数1：默认构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-comment">//getter和setter方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> id;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> age;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<span class="hljs-keyword">this</span>.age = age;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSclass</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> sclass;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSclass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sclass)</span> </span>&#123;<span class="hljs-keyword">this</span>.sclass = sclass;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> height;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height)</span> </span>&#123;<span class="hljs-keyword">this</span>.height = height;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> weight;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">float</span> weight)</span> </span>&#123;<span class="hljs-keyword">this</span>.weight = weight;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getScore</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> score;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">float</span> score)</span> </span>&#123;<span class="hljs-keyword">this</span>.score = score;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式，看起来还比较舒服，只是设置了相应的getter和setter方法。再来看看如何使用这种方式去new一个Student类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//2、javaBean模式</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>student1.setId(<span class="hljs-number">1</span>);<br>student1.setName(<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>student1.setSclass(<span class="hljs-number">1</span>);<br>student1.setWeight(<span class="hljs-number">180</span>);<br>student1.setHeight(<span class="hljs-number">175</span>);<br>student1.setScore(<span class="hljs-number">100</span>);<br>student1.setAge(<span class="hljs-number">20</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看起来还可以，不过这只是我自己一个一个敲出来的。实际在用的时候就知道同样恶心了，现在来总结一波他的缺点。</p><h4 id="缺点1：构造过程中-JavaBean可能处于不一致的状态"><a href="#缺点1：构造过程中-JavaBean可能处于不一致的状态" class="headerlink" title="缺点1：构造过程中 JavaBean可能处于不一致的状态"></a>缺点1：构造过程中 JavaBean可能处于不一致的状态</h4><p>JavaBeans 模式本身有严重的缺陷。由于构造方法在多次调用中被分割，所以在构造过程中 JavaBean<br>可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来执行一致性的选项。在不一致的状态下尝试使用对象可能会导致与包含 bug 的代码大相径庭的错误，因此很难调试。</p><p>说一下我对其的理解，在上面的例子中，我们的student1对象被多次调用了set方法，但是可能有时候在用到这个bean时，剩下的setter方法还没有做完，于是再次调用时发现同一个javaBean呈现出了两种状态。于是处于一种不一致的状态。</p><h4 id="缺点2：无法保证javaBean的不可变性"><a href="#缺点2：无法保证javaBean的不可变性" class="headerlink" title="缺点2：无法保证javaBean的不可变性"></a>缺点2：无法保证javaBean的不可变性</h4><p>使用第一种模式可伸缩构造方法实例化之后不会更改可变性，所有的数据都是确定好了的。也可以保证线程安全。但是提供了setter方法，就不能保证了。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//2、javaBean模式</span><br>Student student1 = <span class="hljs-keyword">new</span> Student();<br>student1.setId(<span class="hljs-number">1</span>);<br>student1.setName(<span class="hljs-string">&quot;愚公要移山&quot;</span>);<br>student1.setSclass(<span class="hljs-number">1</span>);<br>student1.setWeight(<span class="hljs-number">180</span>);<br>student1.setHeight(<span class="hljs-number">175</span>);<br>student1.setScore(<span class="hljs-number">100</span>);<br>student1.setAge(<span class="hljs-number">20</span>);<br>System.out.println(student1.getName());<br>student1.setName(<span class="hljs-string">&quot;冯冬冬&quot;</span>);<br>System.out.println(student1.getName());<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出结果：愚公要移山  冯冬冬</span><br></code></pre></td></tr></table></figure><p>可以看到，我们可以对Student对象设置多次name，前后是不一致的状态。</p><p>既然前面两种都存在各种各样的问题。现在我们再来看今天的主题builder模式，</p><h2 id="二、builder模式"><a href="#二、builder模式" class="headerlink" title="二、builder模式"></a>二、builder模式</h2><p>还是老样子，我们先看看builder模式长得什么样子。再来分析一下他的优缺点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">// 可选</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = builder.id;<br><span class="hljs-keyword">this</span>.name = builder.name;<br><span class="hljs-keyword">this</span>.age = builder.age;<br><span class="hljs-keyword">this</span>.sclass = builder.sclass;<br><span class="hljs-keyword">this</span>.height = builder.height;<br><span class="hljs-keyword">this</span>.weight = builder.weight;<br><span class="hljs-keyword">this</span>.score = builder.score;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 必要</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> sclass; <span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> weight;<span class="hljs-comment">// 可选</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> score;<span class="hljs-comment">// 可选</span><br><span class="hljs-comment">// 必要参数的构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.id = id;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setSclass</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sclass)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.sclass = sclass;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> height)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.height = height;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">float</span> weight)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.weight = weight;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">setScore</span><span class="hljs-params">(<span class="hljs-keyword">float</span> score)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.score = score;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 对外提供的</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码是在内部构造了一个Builder类，然后我们看看如何去使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//3、Builder模式</span><br>Student stu = <span class="hljs-keyword">new</span> Student.Builder(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;愚公要移山&quot;</span>)<br>.setAge(<span class="hljs-number">20</span>)<br>.setHeight(<span class="hljs-number">175</span>)<br>.setSclass(<span class="hljs-number">1</span>)<br>.setScore(<span class="hljs-number">100</span>)<br>.setWeight(<span class="hljs-number">100</span>).build();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这本书中对其的缺点也进行了介绍，很直观可以看到，Student类中的代码量增加了很多。但是Student类，我们只需要写一次，这却为我们创建对象带来了方便。</p><h3 id="优点1：不存在反转字段的情况"><a href="#优点1：不存在反转字段的情况" class="headerlink" title="优点1：不存在反转字段的情况"></a>优点1：不存在反转字段的情况</h3><p>上面可以看出，每次添加新字段值的时候是通过set方式进行的。具有javaBean的优点。</p><h3 id="优点2：灵活构造参数"><a href="#优点2：灵活构造参数" class="headerlink" title="优点2：灵活构造参数"></a>优点2：灵活构造参数</h3><p>我们把必要的字段一写，那些非必要的字段我们可以自己选择是不是要set。</p><h3 id="优点3：不存在不一致状态"><a href="#优点3：不存在不一致状态" class="headerlink" title="优点3：不存在不一致状态"></a>优点3：不存在不一致状态</h3><p>使用builder模式，对象的创建必须要等到build完成才可以。</p><h3 id="优点4：使用灵活"><a href="#优点4：使用灵活" class="headerlink" title="优点4：使用灵活"></a>优点4：使用灵活</h3><p>单个 builder 可以重复使用来构建多个对象。 builder 的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在性能关键的情况下可能会出现问题。而且，builder 模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。</p><p>但是，如果从构造方法或静态工厂开始，并切换到 builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂就会面临尴尬的处境。因此，所以，最好从一开始就创建一个 builder。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果我们的参数比较多时，builder模式是一个不错的选择，如果比较少时，由于Builder本身也是个对象占用一定的资源，所以还是使用可伸缩或者是javaBean的那种模式比较好。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>写代码的建议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高效java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么MongoDB使用B树，而Mysql使用B+树？（干活总结）</title>
    <link href="/2020/12/26/%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/3%E3%80%81MongoDB/%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%EF%BC%8C%E8%80%8CMysql%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F%EF%BC%88%E5%B9%B2%E6%B4%BB%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2020/12/26/%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/3%E3%80%81MongoDB/%E4%B8%BA%E4%BB%80%E4%B9%88MongoDB%E4%BD%BF%E7%94%A8B%E6%A0%91%EF%BC%8C%E8%80%8CMysql%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%9F%EF%BC%88%E5%B9%B2%E6%B4%BB%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《MongoDB学习系列》专栏中</strong></p></blockquote><p>本文献给准备面试或者是还在面试的你。常见面试题，送分题目，不拿白不拿。</p><h2 id="一、B树和B-树的区别"><a href="#一、B树和B-树的区别" class="headerlink" title="一、B树和B+树的区别"></a><strong>一、B树和B+树的区别</strong></h2><p>很明显，我们想向弄清楚原因就要知道B树和B+树的区别。为了不长篇大论。我们直接给出他们的形式总结他们的特点。</p><h3 id="1、B树"><a href="#1、B树" class="headerlink" title="1、B树"></a><strong>1、B树</strong></h3><p>B树是一种自平衡的搜索树，形式很简单：</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRAYQ.png"></p><p>这就是一颗B-树。针对我们这个问题的最核心的特点如下：</p><p><strong>（1）多路，非二叉树</strong></p><p><strong>（2）每个节点既保存索引，又保存数据</strong></p><p><strong>（3）搜索时相当于二分查找</strong></p><p>其他的基本上都是一些常见的数据结构，假定都已经了解了B树相关的结构。</p><h3 id="2、B-树"><a href="#2、B-树" class="headerlink" title="2、B+树"></a><strong>2、B+树</strong></h3><p>B+树是B树的变种</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRkFg.png"></p><p>最核心的特点如下：</p><p><strong>（1）多路非二叉</strong></p><p><strong>（2）只有叶子节点保存数据</strong></p><p><strong>（3）搜索时相当于二分查找</strong></p><p><strong>（4）增加了相邻接点的指向指针。</strong></p><p>从上面我们可以看出最核心的区别主要有俩，</p><p><strong>一个是数据的保存位置：B树保存在所有的节点中，B+树保存在叶子节点</strong></p><p><strong>一个是相邻节点的指向：B树叶子节点之间没有指针，B+树有</strong></p><p>这里区别分别给B树和B+树带来了什么好处呢？其实对于数据库来说，选用什么数据结构无非就是为了增删改查和存储更加高效，因为找特点时也要从这个点去回答。</p><h3 id="3、从区别找特点"><a href="#3、从区别找特点" class="headerlink" title="3、从区别找特点"></a><strong>3、从区别找特点</strong></h3><h4 id="第一：查找元素"><a href="#第一：查找元素" class="headerlink" title="第一：查找元素"></a>第一：查找元素</h4><p>（1）B树的数据保存在所有节点，查询复杂度最好是 O(1)。</p><p>（2）B+树的数据保存在叶子节点，查询时间复杂度固定是O(log(n))</p><h4 id="第二：区间查找"><a href="#第二：区间查找" class="headerlink" title="第二：区间查找"></a>第二：区间查找</h4><p>（1）B树每个节点 key 和 data 在一起，则无法区间查找。</p><p>（2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等</p><h4 id="第三：存储"><a href="#第三：存储" class="headerlink" title="第三：存储"></a>第三：存储</h4><p>（1）B树每个节点即保存数据又保存索引，所以每一节点特别大，这一层所有节点加起来数据量将非常大。磁盘每次IO一定量的数据，对于Mysql来说如何衡量查询效率呢？就是磁盘IO次数。既然B树每一层特别大，那每一层就需要对数据分开从而进行多次IO操作。所有Mysql不用。</p><p>（2）B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确，所以不需要用B+树。</p><p>有了他们的区别之后，现在我们再来解释这个原因就好多了。</p><h2 id="二、原因解释"><a href="#二、原因解释" class="headerlink" title="二、原因解释"></a><strong>二、原因解释</strong></h2><p>上面解释了不使用的原因，我们再来看为什么Mysql使用B+树，而MongoDB使用B树，想要解释原因，我们还必须要了解一下MongoDB和Mysql的基本概念。</p><h3 id="1、MongoDB"><a href="#1、MongoDB" class="headerlink" title="1、MongoDB"></a><strong>1、MongoDB</strong></h3><p>MongoDB 是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据。比如之前我们的表可能有用户表、订单表、购物篮表等等，还要建立他们之间的外键关联关系。但是类Json就不一样了。</p><p><img src="https://s3.ax1x.com/2020/12/26/rfRiTS.png"></p><p>我们可以看到这种形式更简单，通俗易懂。那为什么 MongoDB 使用B-树呢？</p><p><strong>MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql</strong>。</p><h3 id="2、Mysql"><a href="#2、Mysql" class="headerlink" title="2、Mysql"></a><strong>2、Mysql</strong></h3><p><strong>Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。</strong></p><p>还有一点，B+树只有叶子节点保存数据，所以每一节点比较小，每一层所有节点加起来数据量也相对比较小。磁盘每次IO一定量的数据，对于Mysql来说。既然B+树每一层小，那每一层只需要少量IO操作。</p><p>这俩区别的核心如果你能看懂B-树和B+树的区别就很容易理解。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>MongoDB专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>MongoDB</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我们到底该如何学习《数据结构与算法》</title>
    <link href="/2020/12/24/%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/24/%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>出自公众号《愚公要移山》中，地址<a href="http://www.javachat.cc/">www.javachat.cc</a></strong><br><strong>本文已收录在《手牵手一起学数据结构》专栏中</strong></p></blockquote><h2 id="前言：我们到底该不该学习算法与数据结构？"><a href="#前言：我们到底该不该学习算法与数据结构？" class="headerlink" title="前言：我们到底该不该学习算法与数据结构？"></a>前言：我们到底该不该学习算法与数据结构？</h2><h3 id="1、真的应该学习"><a href="#1、真的应该学习" class="headerlink" title="1、真的应该学习"></a>1、真的应该学习</h3><p>这个问题本身就不是个问题，所有人都在强调数据结构与算法比较重要，但是好像平时也没用到，无法直观的去感受它的重要性，于是把学习重心放在了常见的哪些框架身上，似乎只要熟悉了哪些框架的API，编程就会所向披靡。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZhJU.gif"></p><p>我举一个我自身的例子，我本科期间想做一个APP，主要是在线预约的功能，既然是在线预约，用户多了之后那就需要排队，当时也不管三七二十一，不管哪种结构，那就先试试ArrayList，当然这种数据结构也能解决，但是当真正操作其增删改查的时候才发现ArrayList确实是比较麻烦一点。</p><p>在网上开始问各种大佬，统一回复的一句话是，你现在学数据结构了吗？你数据结构咋学的？现在想想真的是留下啦悔恨的眼泪。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZfiT.gif"></p><p>既然数据结构与算法重要，到底哪个地方重要呢？下面就来说说：</p><h3 id="2、重要性体现"><a href="#2、重要性体现" class="headerlink" title="2、重要性体现"></a>2、重要性体现</h3><h4 id="第一：面试"><a href="#第一：面试" class="headerlink" title="第一：面试"></a>第一：面试</h4><p>面试确实是第一个体现的点，因为你会发现，面试外企的时候他们第一件事就是啥都不问，上来就是几道算法题。包括国内的字节跳动。现在的阿里、腾讯、华为、美团。凡是大家知道的那些大厂基本上上来就是先敲代码。可以看出国内外大厂对于算法与数据结构的看重。</p><h4 id="第二：工作"><a href="#第二：工作" class="headerlink" title="第二：工作"></a>第二：工作</h4><p>现在的大厂api框架基本上背后的逻辑就是基于算法实现的。其实算法的种类有很多，比如说机器学习、神经网络算法，还有java中的排序算法，互联网的商品推荐、股票预测其背后的逻辑都是算法。就算是熟悉的那些框架，背后的逻辑也是数据结构与算法。我们敲代码解决问题的过程当中也是算法的集中体现。</p><h4 id="第三：学习"><a href="#第三：学习" class="headerlink" title="第三：学习"></a>第三：学习</h4><p>学习数据结构与算法的目的，别人我不知道，对我目前来说，是想了解哪些常见框架，常见机制背后的运行逻辑。进而为以后创造一个更加强大的产品做铺垫。任何一个新东西，都是先了解，再模仿，最后再创造的过程。</p><h4 id="第四：应付学业"><a href="#第四：应付学业" class="headerlink" title="第四：应付学业"></a>第四：应付学业</h4><p>我之前大学学习这门课的时候，学分比重还是比较大的，好几年过去了，不知道现在变没变。不过最起码考研或者是期末考试，这门课都是必须要学习的一门课。可见学校也比较重视。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2Z5z4.gif"></p><h2 id="一、算法与数据结构到底是个什么东东？"><a href="#一、算法与数据结构到底是个什么东东？" class="headerlink" title="一、算法与数据结构到底是个什么东东？"></a>一、算法与数据结构到底是个什么东东？</h2><p>在这里我不想去解释哪些常见的名词了，像什么是数据项、数据对象、元素等等这些概念。稍微有点基础的人，对这些概念都应该很清楚，毕竟都是中国人。我主要想说一下，我们到底该如何理解数据结构与算法。</p><h3 id="1、什么是数据结构？"><a href="#1、什么是数据结构？" class="headerlink" title="1、什么是数据结构？"></a>1、什么是数据结构？</h3><p>高中的时候都学习过化学，什么水的结构，碳原子的结构，这些分子、原子之间不是杂乱无章的，我们总是可以归纳分析出一些规律。对于计算机中的数据元素而言，这些数据元素也不是孤立的，总是有一种或者是几种的内在联系。</p><blockquote><p>数据结构：数据元素相互之间一种或者多种关系的表示</p></blockquote><p>既然数据元素之间有某种关系，那这种关系到底是什么呢？这里直接总结了一下。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2Z2d0.png"></p><p>可以看出分两类，表示了这些数据元素之间的关系。我们在学习数据结构的时候，其实就是学习这些数据元素到底有哪些关系。</p><h3 id="2、什么是算法"><a href="#2、什么是算法" class="headerlink" title="2、什么是算法"></a>2、什么是算法</h3><p>宋丹丹和赵本山有过一个小品，说如何把大象关进冰箱里。第一步先把冰箱门打开，第二步把大象装进去，第三步，把冰箱门关上。整个简单的流程完美的体现了算法的思想。标准定义：</p><blockquote><p>算法：解决问题的步骤的描述</p></blockquote><p>就这么几个字，其实就是描述过程的。当然解决问题的方法有很多，因此算法也有很多种，就比说我们常见的排序算法，就简简单单为了从小到大排序，哪些科学家们活活的搞出了十几种。每一种排序方式都是一个算法。</p><h3 id="3、数据结构与算法的关系（重点）"><a href="#3、数据结构与算法的关系（重点）" class="headerlink" title="3、数据结构与算法的关系（重点）"></a>3、数据结构与算法的关系（重点）</h3><p>我们经常会听到有人说：程序=算法+数据结构，某位大佬科学家就提出了这几个字还得了图灵奖。大学的时候知道这件事还让我一度怀疑图灵奖也不过如此。嘿嘿，不过现在不敢说了，看的越多，越觉得这个简单地公式蕴含了无数的道理。</p><p>既然是讨论他们之间的关系。我们再来看个例子，毕竟例子各位才理解的更加清楚。假如我国要在多个城市之间新建一条高铁。要求是能够链接多个城市，而且成本最低。OK，好了，现在就这么个需求，我们来分析。</p><p>第一目的：修建铁路</p><p>第二要求：连通所有城市，成本最低。</p><p>我们一下子就能想到这是一个最小生成树问题，假如把每一个城市看成一个点，把城市之间的成本看成连线数字，就是找出来一个联通线。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2eAFf.png"></p><p>目的其实就是为了找上图中的那条黑线。这里不是专门讲这个知识体系的。现在我们使用流程图看看，如果遇到了一个问题，我们是如何去使用程序去解决的。</p><p><img src="https://s3.ax1x.com/2020/12/24/r2ZRoV.png"></p><p>从上图可以看出，为了要解决一个问题，首先我们要分析问题，然后确定解决思路，接下来设计或者是选择已有的算法，再然后就是确定实现的数据结构，最后就是代码的实现与优化。</p><p>数据结构在其中的位置可以看出，是为了更好地实现某种或者是某类算法。在讨论这门课的时候也会结合在一起去学习。</p><h2 id="二、学习数据结构与算法我们最应该关注什么？"><a href="#二、学习数据结构与算法我们最应该关注什么？" class="headerlink" title="二、学习数据结构与算法我们最应该关注什么？"></a>二、学习数据结构与算法我们最应该关注什么？</h2><p>​    如果我们想要学好数据结构与算法，首先脑海中要时刻记住两个关键词汇，<strong>时间效率和空间效率</strong>。这个两个词汇贯穿了整个数据结构与算法的知识体系。</p><p>​    数据结构可以助算法实现问题提供基础，算法为了解决某一问题必须要时间够快，空间足够节省。就好比我们为了能够在茫茫人海当中找寻另一半一样。首先时间要足够快，不能一个一个找，然后我们不可能把茫茫人海所有人的全部信息全给保存了，所以空间上还要足够节省。</p><p>​    <strong>那什么是时间效率和空间效率呢？通俗的理解就是：我们使用两个不同的程序去解决同一个问题，时间短的说明时间效率高，消耗空间小的说明空间效率高。</strong></p><p>​    我们在研究数据结构与算法的时候，其实就是选择不同的数据结构和不同的算法解决某一问题的同时尽可能的提升计算机的时间效率和空间效率。</p><h3 id="1、首先看时间复杂度："><a href="#1、首先看时间复杂度：" class="headerlink" title="1、首先看时间复杂度："></a>1、首先看时间复杂度：</h3><p>​    想要了解时间复杂度，就需要先了解时间频度。一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或<strong>时间频度</strong>。记为T(n)。</p><p>说白了时间复杂度就是描述时间的规模，比如说时间频度是T(n),时间复杂度就是O(n)。时间频度是T(n+n)的时候,时间复杂度还是O(n)。也就是他的时间规模就是n这个层次了。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度**。</p><p><strong>常见的算法的时间 复杂度之间的关系为：</strong></p><p><strong>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</strong> </p><p>举个例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">a=<span class="hljs-number">0</span>；                    <span class="hljs-comment">//（1）</span><br>   <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)       <span class="hljs-comment">//（2）</span><br>      <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=n;j++)       <span class="hljs-comment">//（3）</span><br>       a++；             <span class="hljs-comment">//（4）</span><br></code></pre></td></tr></table></figure><p>语句（1）执行1次，</p><p>语句（2）执行n次</p><p>语句（3）执行n2次</p><p>语句（4）执行n2次</p><p>T(n) = 1+n+2n2= O(n2)</p><h3 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h3><p>空间复杂度就比较容易理解了，空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个空间规模，我们用 S(n) 来定义。</p><p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，</p><h2 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h2><p>在本文中，首先讨论了数据结构与算法的重要性，然后给出了数据结构与算法的理解，最后就是在学习数据结构与算法时，我们最应该关注的点。其中通过数据结构与算进的关系解决某一问题的流程是重点。在以后的文章中，也会惯用这一思路。这个思路是我在刷了力扣几百道题时总结出来的。</p><p>举个例子来说一下：</p><p>面试中经常会遇到一道题，那就是实现LRU（最近最久未使用）。我们按照上面的流程结构可以很清楚的把问题给解决掉，而不是死记硬背哪些现有的代码，比如第一步分析问题，问题是实现最近最久未使用的算法，我们可以画图来看一下到底是个什么问题，然后就是确定算法，比如说第一步我们该干嘛，第二步该干嘛等等。接下来确定数据结构的时候，比如说可以自定义Node实现，还有java中为我们提供的LinkedHashMap等等。最后就是根据数据结构的特点通过我们分析的算法流程去实现。</p><p>这样是不是有点清晰了。本专栏将持续推出。</p><P class="note note-warning">如需转载，请提前联系作者，否则追究法律责任</P><p> <strong><P class="note note-primary">这有5T资源，涵盖了java小白到架构师整个体系各种相关资源（视频、电子书、面试、简历、IDE破解等），更多文章请关注：</P></strong></p><p align="center"><img src="https://s3.ax1x.com/2020/12/18/rJnbO1.jpg" height="250" width="480" /></p>]]></content>
    
    
    <categories>
      
      <category>数据结构专题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
